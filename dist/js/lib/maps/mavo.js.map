{"version":3,"sources":["../deps.js","../../src/mavo.js","../../src/util.js","../../src/locale.js","../../src/locale.en.js","../../src/plugins.js","../../src/ui.bar.js","../../src/ui.message.js","../../src/permissions.js","../../src/backend.js","../../src/formats.js","../../src/node.js","../../src/group.js","../../src/primitive.js","../../src/ui.popup.js","../../src/elements.js","../../src/collection.js","../../src/implicit-collection.js","../../src/ui.itembar.js","../../src/expression.js","../../src/domexpression.js","../../src/expressions.js","../../src/mv-if.js","../../src/functions.js","../../src/functions.date.js","../../src/mavoscript.js","../../src/actions.js","../../src/data.js","../../src/backend.github.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/pCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACh+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACprBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACn2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC78BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../mavo.js","sourcesContent":["!function(){\"use strict\";function e(o,i,t){return i=void 0===i?1:i,(t=t||i+1)-i<=1?function(){if(arguments.length<=i||\"string\"===c.type(arguments[i]))return o.apply(this,arguments);var t,e,n=arguments[i];for(e in n){var r=Array.prototype.slice.call(arguments);r.splice(i,1,e,n[e]),t=o.apply(this,r)}return t}:e(e(o,i+1,t),i,t-1)}function s(e,n,t){var r=a(t);if(\"string\"===r){var o=Object.getOwnPropertyDescriptor(n,t);!o||o.writable&&o.configurable&&o.enumerable&&!o.get&&!o.set?e[t]=n[t]:(delete e[t],Object.defineProperty(e,t,o))}else if(\"array\"===r)t.forEach(function(t){t in n&&s(e,n,t)});else for(var i in n)t&&(\"regexp\"===r&&!t.test(i)||\"function\"===r&&!t.call(n,i))||s(e,n,i);return e}function a(t){if(null===t)return\"null\";if(void 0===t)return\"undefined\";var e=(Object.prototype.toString.call(t).match(/^\\[object\\s+(.*?)\\]$/)[1]||\"\").toLowerCase();return\"number\"==e&&isNaN(t)?\"nan\":e}var c=self.Bliss=s(function(t,e){return 2==arguments.length&&!e||!t?null:\"string\"===c.type(t)?(e||document).querySelector(t):t||null},self.Bliss);s(c,{extend:s,overload:e,type:a,property:c.property||\"_\",listeners:new(self.WeakMap?WeakMap:Map),original:{addEventListener:(self.EventTarget||Node).prototype.addEventListener,removeEventListener:(self.EventTarget||Node).prototype.removeEventListener},sources:{},noop:function(){},$:function(t,e){return t instanceof Node||t instanceof Window?[t]:2!=arguments.length||e?Array.prototype.slice.call(\"string\"==typeof t?(e||document).querySelectorAll(t):t||[]):[]},defined:function(){for(var t=0;t<arguments.length;t++)if(void 0!==arguments[t])return arguments[t]},create:function(t,e){return t instanceof Node?c.set(t,e):(1===arguments.length&&(e=\"string\"===c.type(t)?{}:(t=(e=t).tag,c.extend({},e,function(t){return\"tag\"!==t}))),c.set(document.createElement(t||\"div\"),e))},each:function(t,e,n){for(var r in n=n||{},t)n[r]=e.call(t,r,t[r]);return n},ready:function(e,t,n){if(\"function\"!=typeof e||t||(t=e,e=void 0),e=e||document,t&&(\"loading\"!==e.readyState?t():c.once(e,\"DOMContentLoaded\",function(){t()})),!n)return new Promise(function(t){c.ready(e,t,!0)})},Class:function(t){var e,n,r=[\"constructor\",\"extends\",\"abstract\",\"static\"].concat(Object.keys(c.classProps)),o=t.hasOwnProperty(\"constructor\")?t.constructor:c.noop;2==arguments.length?(n=arguments[0],t=arguments[1]):((n=function(){if(this.constructor.__abstract&&this.constructor===n)throw new Error(\"Abstract classes cannot be directly instantiated.\");n.super&&!e&&n.super.apply(this,arguments),o.apply(this,arguments)}).super=t.extends||null,!n.super||(e=0===(n.super+\"\").indexOf(\"class \"))&&console.error(`You are using $.Class() to create a fake function-based class that extends a native JS class. This will not work.\nYou should convert your code to use native JS classes too. You can still pass a class into $.Class() to use its conveniences.`),n.prototype=c.extend(Object.create(n.super?n.super.prototype:Object),{constructor:n}),n.prototype.super=n.super?n.super.prototype:null,n.__abstract=!!t.abstract);function i(t){return this.hasOwnProperty(t)&&-1===r.indexOf(t)}if(t.static)for(var s in c.extend(n,t.static,i),c.classProps)s in t.static&&c.classProps[s](n,t.static[s]);for(s in c.extend(n.prototype,t,i),c.classProps)s in t&&c.classProps[s](n.prototype,t[s]);return n},classProps:{lazy:e(function(t,e,n){return Object.defineProperty(t,e,{get:function(){var t=n.call(this);return Object.defineProperty(this,e,{value:t,configurable:!0,enumerable:!0,writable:!0}),t},set:function(t){Object.defineProperty(this,e,{value:t,configurable:!0,enumerable:!0,writable:!0})},configurable:!0,enumerable:!0}),t}),live:e(function(t,n,r){return\"function\"===c.type(r)&&(r={set:r}),Object.defineProperty(t,n,{get:function(){var t=this[\"_\"+n],e=r.get&&r.get.call(this,t);return void 0!==e?e:t},set:function(t){var e=this[\"_\"+n],e=r.set&&r.set.call(this,t,e);this[\"_\"+n]=void 0!==e?e:t},configurable:r.configurable,enumerable:r.enumerable}),t})},include:function(){var n=arguments[arguments.length-1],t=2===arguments.length&&arguments[0],r=document.createElement(\"script\");return t?Promise.resolve():new Promise(function(t,e){c.set(r,{async:!0,onload:function(){t(r),r.parentNode&&r.parentNode.removeChild(r)},onerror:function(){e(r)},src:n,inside:document.head})})},load:function t(r,e){e=e?new URL(e,location.href):location.href,r=new URL(r,e);e=t.loading=t.loading||{};return e[r+\"\"]||(/\\.css$/.test(r.pathname)?e[r+\"\"]=new Promise(function(t,e){var n=c.create(\"link\",{href:r,rel:\"stylesheet\",inside:document.head,onload:function(){t(n)},onerror:function(){e(n)}})}):e[r+\"\"]=c.include(r))},fetch:function(t,e){if(!t)throw new TypeError(\"URL parameter is mandatory and cannot be \"+t);var n,r=s({url:new URL(t,location),data:\"\",method:\"GET\",headers:{},xhr:new XMLHttpRequest},e);for(n in r.method=r.method.toUpperCase(),c.hooks.run(\"fetch-args\",r),\"GET\"===r.method&&r.data&&(r.url.search+=r.data),document.body.setAttribute(\"data-loading\",r.url),r.xhr.open(r.method,r.url.href,!1!==r.async,r.user,r.password),e)if(\"upload\"===n)r.xhr.upload&&\"object\"==typeof e[n]&&c.extend(r.xhr.upload,e[n]);else if(n in r.xhr)try{r.xhr[n]=e[n]}catch(t){self.console&&console.error(t)}var o,t=Object.keys(r.headers).map(function(t){return t.toLowerCase()});for(o in\"GET\"!==r.method&&-1===t.indexOf(\"content-type\")&&r.xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"),r.headers)void 0!==r.headers[o]&&r.xhr.setRequestHeader(o,r.headers[o]);t=new Promise(function(t,e){r.xhr.onload=function(){document.body.removeAttribute(\"data-loading\"),0===r.xhr.status||200<=r.xhr.status&&r.xhr.status<300||304===r.xhr.status?t(r.xhr):e(c.extend(Error(r.xhr.statusText),{xhr:r.xhr,get status(){return this.xhr.status}}))},r.xhr.onerror=function(){document.body.removeAttribute(\"data-loading\"),e(c.extend(Error(\"Network Error\"),{xhr:r.xhr}))},r.xhr.ontimeout=function(){document.body.removeAttribute(\"data-loading\"),e(c.extend(Error(\"Network Timeout\"),{xhr:r.xhr}))},r.xhr.send(\"GET\"===r.method?null:r.data)});return t.xhr=r.xhr,t},value:function(t){var e=\"string\"!=typeof t;return c.$(arguments).slice(+e).reduce(function(t,e){return t&&t[e]},e?t:self)}}),c.Hooks=new c.Class({add:function(t,e,n){if(\"string\"==typeof arguments[0])(Array.isArray(t)?t:[t]).forEach(function(t){this[t]=this[t]||[],e&&this[t][n?\"unshift\":\"push\"](e)},this);else for(var t in arguments[0])this.add(t,arguments[0][t],e)},run:function(t,e){this[t]=this[t]||[],this[t].forEach(function(t){t.call(e&&e.context?e.context:e,e)})}}),c.hooks=new c.Hooks;c.property;c.Element=function(t){this.subject=t,this.data={},this.bliss={}},c.Element.prototype={set:e(function(t,e){t in c.setProps?c.setProps[t].call(this,e):t in this?this[t]=e:this.setAttribute(t,e)},0),transition:function(o,i){return new Promise(function(t,e){var n,r;\"transition\"in this.style&&0!==i?(n=c.extend({},this.style,/^transition(Duration|Property)$/),c.style(this,{transitionDuration:(i||400)+\"ms\",transitionProperty:Object.keys(o).join(\", \")}),c.once(this,\"transitionend\",function(){clearTimeout(r),c.style(this,n),t(this)}),r=setTimeout(t,i+50,this),c.style(this,o)):(c.style(this,o),t(this))}.bind(this))},fire:function(t,e){var n=document.createEvent(\"HTMLEvents\");return n.initEvent(t,!0,!0),this.dispatchEvent(c.extend(n,e))},bind:e(function(t,n){var e;1<arguments.length&&(\"function\"===c.type(n)||n.handleEvent)&&(e=n,(n=\"object\"===c.type(arguments[2])?arguments[2]:{capture:!!arguments[2]}).callback=e);var r=c.listeners.get(this)||{};t.trim().split(/\\s+/).forEach(function(t){var e;-1<t.indexOf(\".\")&&(e=(t=t.split(\".\"))[1],t=t[0]),r[t]=r[t]||[],0===r[t].filter(function(t){return t.callback===n.callback&&t.capture==n.capture}).length&&r[t].push(c.extend({className:e},n)),c.original.addEventListener.call(this,t,n.callback,n)},this),c.listeners.set(this,r)},0),unbind:e(function(t,i){var e;i&&(\"function\"===c.type(i)||i.handleEvent)&&(e=i,i=arguments[2]),(i=(i=\"boolean\"==c.type(i)?{capture:i}:i)||{}).callback=i.callback||e;var s=c.listeners.get(this);(t||\"\").trim().split(/\\s+/).forEach(function(t){var e,n;if(-1<t.indexOf(\".\")&&(e=(t=t.split(\".\"))[1],t=t[0]),!s)return t&&i.callback?c.original.removeEventListener.call(this,t,i.callback,i.capture):void 0;for(n in s)if(!t||n===t)for(var r,o=0;r=s[n][o];o++)e&&e!==r.className||i.callback&&i.callback!==r.callback||!!i.capture!=!!r.capture&&(t||i.callback||void 0!==i.capture)||(s[n].splice(o,1),c.original.removeEventListener.call(this,n,r.callback,r.capture),o--)},this)},0),when:function(r,o){var t=this;return new Promise(function(n){t.addEventListener(r,function t(e){o&&!o.call(this,e)||(this.removeEventListener(r,t),n(e))})})},toggleAttribute:function(t,e,n){(n=arguments.length<3?null!==e:n)?this.setAttribute(t,e):this.removeAttribute(t)}},c.setProps={style:function(t){for(var e in t)e in this.style?this.style[e]=t[e]:this.style.setProperty(e,t[e])},attributes:function(t){for(var e in t)this.setAttribute(e,t[e])},properties:function(t){c.extend(this,t)},events:function(t){if(1!=arguments.length||!t||!t.addEventListener)return c.bind.apply(this,[this].concat(c.$(arguments)));var e,n=this;if(c.listeners){var r,o=c.listeners.get(t);for(r in o)o[r].forEach(function(t){c.bind(n,r,t.callback,t.capture)})}for(e in t)0===e.indexOf(\"on\")&&(this[e]=t[e])},once:e(function(t,e){function n(){return c.unbind(r,t,n),e.apply(r,arguments)}var r=this;c.bind(this,t,n,{once:!0})},0),delegate:e(function(t,e,n){c.bind(this,t,function(t){t.target.closest(e)&&n.call(this,t)})},0,2),contents:function(t){!t&&0!==t||(Array.isArray(t)?t:[t]).forEach(function(t){var e=c.type(t);/^(string|number)$/.test(e)?t=document.createTextNode(t+\"\"):\"object\"===e&&(t=c.create(t)),t instanceof Node&&this.appendChild(t)},this)},inside:function(t){t&&t.appendChild(this)},before:function(t){t&&t.parentNode.insertBefore(this,t)},after:function(t){t&&t.parentNode.insertBefore(this,t.nextSibling)},start:function(t){t&&t.insertBefore(this,t.firstChild)},around:function(t){t&&t.parentNode&&c.before(this,t),this.appendChild(t)}},c.Array=function(t){this.subject=t},c.Array.prototype={all:function(t){var e=c.$(arguments).slice(1);return this[t].apply(this,e)}},c.add=e(function(r,n,o,t){o=c.extend({$:!0,element:!0,array:!0},o),\"function\"==c.type(n)&&(!o.element||r in c.Element.prototype&&t||(c.Element.prototype[r]=function(){return this.subject&&c.defined(n.apply(this.subject,arguments),this.subject)}),!o.array||r in c.Array.prototype&&t||(c.Array.prototype[r]=function(){var e=arguments;return this.subject.map(function(t){return t&&c.defined(n.apply(t,e),t)})}),o.$&&(c.sources[r]=c[r]=n,(o.array||o.element)&&(c[r]=function(){var t=[].slice.apply(arguments),e=t.shift(),n=o.array&&Array.isArray(e)?\"Array\":\"Element\";return c[n].prototype[r].apply({subject:e},t)})))},0),c.add(c.Array.prototype,{element:!1}),c.add(c.Element.prototype),c.add(c.setProps),c.add(c.classProps,{element:!1,array:!1});var n=document.createElement(\"_\");c.add(c.extend({},HTMLElement.prototype,function(t){return\"function\"===c.type(n[t])}),null,!0)}();\nvar jsep=function(e){\"use strict\";const t=\"Compound\",r=\"MemberExpression\",n=\"Literal\";let o=function(e,t){let r=new Error(e+\" at character \"+t);throw r.index=t,r.description=e,r},i={\"-\":1,\"!\":1,\"~\":1,\"+\":1},u={\"||\":1,\"&&\":2,\"|\":3,\"^\":4,\"&\":5,\"==\":6,\"!=\":6,\"===\":6,\"!==\":6,\"<\":7,\">\":7,\"<=\":7,\">=\":7,\"<<\":8,\">>\":8,\">>>\":8,\"+\":9,\"-\":9,\"*\":10,\"/\":10,\"%\":10},a={$:1,_:1},l=function(e){return Math.max(0,...Object.keys(e).map((e=>e.length)))},s=l(i),f=l(u),c={true:!0,false:!1,null:null},p=function(e){return u[e]||0},h=function(e,t,r){return{type:\"BinaryExpression\",operator:e,left:t,right:r}},d=function(e){return e>=48&&e<=57},y=function(e){return e>=65&&e<=90||e>=97&&e<=122||e>=128&&!u[String.fromCharCode(e)]||a.hasOwnProperty(String.fromCharCode(e))},x=function(e){return y(e)||d(e)},g=function(e){let a,l,g=0,m=e.charAt,v=e.charCodeAt,b=function(t){return m.call(e,t)},E=function(t){return v.call(e,t)},C=e.length,O=function(){let e=E(g);for(;32===e||9===e||10===e||13===e;)e=E(++g)},U=function(){let e,t,r=w();return O(),63!==E(g)?r:(g++,e=U(),e||o(\"Expected expression\",g),O(),58===E(g)?(g++,t=U(),t||o(\"Expected expression\",g),{type:\"ConditionalExpression\",test:r,consequent:e,alternate:t}):void o(\"Expected :\",g))},k=function(){O();let t=e.substr(g,f),r=t.length;for(;r>0;){if(u.hasOwnProperty(t)&&(!y(E(g))||g+t.length<e.length&&!x(E(g+t.length))))return g+=r,t;t=t.substr(0,--r)}return!1},w=function(){let e,t,r,n,i,u,a,l,s;if(u=P(),t=k(),!t)return u;for(i={value:t,prec:p(t)},a=P(),a||o(\"Expected expression after \"+t,g),n=[u,i,a];(t=k())&&(r=p(t),0!==r);){for(i={value:t,prec:r},s=t;n.length>2&&r<=n[n.length-2].prec;)a=n.pop(),t=n.pop().value,u=n.pop(),e=h(t,u,a),n.push(e);e=P(),e||o(\"Expected expression after \"+s,g),n.push(i,e)}for(l=n.length-1,e=n[l];l>1;)e=h(n[l-1].value,n[l-2],e),l-=2;return e},P=function(){let t,n,u,a;if(O(),t=E(g),d(t)||46===t)return S();if(39===t||34===t)a=A();else if(91===t)a=L();else{for(n=e.substr(g,s),u=n.length;u>0;){if(i.hasOwnProperty(n)&&(!y(E(g))||g+n.length<e.length&&!x(E(g+n.length))))return g+=u,{type:\"UnaryExpression\",operator:n,argument:P(),prefix:!0};n=n.substr(0,--u)}y(t)?a=j():40===t&&(a=B())}if(!a)return!1;for(O(),t=E(g);46===t||91===t||40===t;)g++,46===t?(O(),a={type:r,computed:!1,object:a,property:j()}):91===t?(a={type:r,computed:!0,object:a,property:U()},O(),t=E(g),93!==t&&o(\"Unclosed [\",g),g++):40===t&&(a={type:\"CallExpression\",arguments:M(41),callee:a}),O(),t=E(g);return a},S=function(){let e,t,r=\"\";for(;d(E(g));)r+=b(g++);if(46===E(g))for(r+=b(g++);d(E(g));)r+=b(g++);if(e=b(g),\"e\"===e||\"E\"===e){for(r+=b(g++),e=b(g),\"+\"!==e&&\"-\"!==e||(r+=b(g++));d(E(g));)r+=b(g++);d(E(g-1))||o(\"Expected exponent (\"+r+b(g)+\")\",g)}return t=E(g),y(t)?o(\"Variable names cannot start with a number (\"+r+b(g)+\")\",g):46===t&&o(\"Unexpected period\",g),{type:n,value:parseFloat(r),raw:r}},A=function(){let e=\"\",t=b(g++),r=!1;for(;g<C;){let n=b(g++);if(n===t){r=!0;break}if(\"\\\\\"===n)switch(n=b(g++),n){case\"n\":e+=\"\\n\";break;case\"r\":e+=\"\\r\";break;case\"t\":e+=\"\\t\";break;case\"b\":e+=\"\\b\";break;case\"f\":e+=\"\\f\";break;case\"v\":e+=\"\\v\";break;default:e+=n}else e+=n}return r||o('Unclosed quote after \"'+e+'\"',g),{type:n,value:e,raw:t+e+t}},j=function(){let t,r=E(g),i=g;for(y(r)?g++:o(\"Unexpected \"+b(g),g);g<C&&(r=E(g),x(r));)g++;return t=e.slice(i,g),c.hasOwnProperty(t)?{type:n,value:c[t],raw:t}:\"this\"===t?{type:\"ThisExpression\"}:{type:\"Identifier\",name:t}},M=function(e){let r=[],n=!1,i=0;for(;g<C;){O();let u=E(g);if(u===e){n=!0,g++,41===e&&i&&i>=r.length&&o(\"Unexpected token \"+String.fromCharCode(e),g);break}if(44===u){if(g++,i++,i!==r.length)if(41===e)o(\"Unexpected token ,\",g);else if(93===e)for(let e=r.length;e<i;e++)r.push(null)}else{let e=U();e&&e.type!==t||o(\"Expected comma\",g),r.push(e)}}return n||o(\"Expected \"+String.fromCharCode(e),g),r},B=function(){g++;let e=U();if(O(),41===E(g))return g++,e;o(\"Unclosed (\",g)},L=function(){return g++,{type:\"ArrayExpression\",elements:M(93)}},I=[];for(;g<C;)a=E(g),59===a||44===a?g++:(l=U())?I.push(l):g<C&&o('Unexpected \"'+b(g)+'\"',g);return 1===I.length?I[0]:{type:t,body:I}};return g.version=\"0.4.0\",g.toString=function(){return\"JavaScript Expression Parser (JSEP) v\"+g.version},g.addUnaryOp=function(e){return s=Math.max(e.length,s),i[e]=1,this},g.addBinaryOp=function(e,t){return f=Math.max(e.length,f),u[e]=t,this},g.addIdentifierChar=function(e){return a[e]=1,this},g.addLiteral=function(e,t){return c[e]=t,this},g.removeUnaryOp=function(e){return delete i[e],e.length===s&&(s=l(i)),this},g.removeAllUnaryOps=function(){return i={},s=0,this},g.removeIdentifierChar=function(e){return delete a[e],this},g.removeBinaryOp=function(e){return delete u[e],e.length===f&&(f=l(u)),this},g.removeAllBinaryOps=function(){return u={},f=0,this},g.removeLiteral=function(e){return delete c[e],this},g.removeAllLiterals=function(){return c={},this},e.default=g,Object.defineProperty(e,\"__esModule\",{value:!0}),e}({});\n\n\n/* jsep v0.3.4 (http://jsep.from.so/) */\n!function(e){\"use strict\";var C=\"Compound\",U=\"MemberExpression\",w=\"Literal\",k=function(e,r){var t=new Error(e+\" at character \"+r);throw t.index=r,t.description=e,t},O={\"-\":!0,\"!\":!0,\"~\":!0,\"+\":!0},S={\"||\":1,\"&&\":2,\"|\":3,\"^\":4,\"&\":5,\"==\":6,\"!=\":6,\"===\":6,\"!==\":6,\"<\":7,\">\":7,\"<=\":7,\">=\":7,\"<<\":8,\">>\":8,\">>>\":8,\"+\":9,\"-\":9,\"*\":10,\"/\":10,\"%\":10},r=function(e){var r,t=0;for(var n in e)(r=n.length)>t&&e.hasOwnProperty(n)&&(t=r);return t},j=r(O),A=r(S),P={true:!0,false:!1,null:null},L=function(e){return S[e]||0},B=function(e,r,t){return{type:\"||\"===e||\"&&\"===e?\"LogicalExpression\":\"BinaryExpression\",operator:e,left:r,right:t}},M=function(e){return 48<=e&&e<=57},q=function(e){return 36===e||95===e||65<=e&&e<=90||97<=e&&e<=122||128<=e&&!S[String.fromCharCode(e)]},J=function(e){return 36===e||95===e||65<=e&&e<=90||97<=e&&e<=122||48<=e&&e<=57||128<=e&&!S[String.fromCharCode(e)]},t=function(n){for(var e,r,p=0,t=n.charAt,o=n.charCodeAt,i=function(e){return t.call(n,e)},u=function(e){return o.call(n,e)},s=n.length,f=function(){for(var e=u(p);32===e||9===e||10===e||13===e;)e=u(++p)},c=function(){var e,r,t=a();return f(),63!==u(p)?t:(p++,(e=c())||k(\"Expected expression\",p),f(),58===u(p)?(p++,(r=c())||k(\"Expected expression\",p),{type:\"ConditionalExpression\",test:t,consequent:e,alternate:r}):void k(\"Expected :\",p))},l=function(){f();for(var e=n.substr(p,A),r=e.length;0<r;){if(S.hasOwnProperty(e)&&(!q(u(p))||p+e.length<n.length&&!J(u(p+e.length))))return p+=r,e;e=e.substr(0,--r)}return!1},a=function(){var e,r,t,n,o,i,a,u,s;if(i=h(),!(r=l()))return i;for(o={value:r,prec:L(r)},(a=h())||k(\"Expected expression after \"+r,p),n=[i,o,a];(r=l())&&0!==(t=L(r));){for(o={value:r,prec:t},s=r;2<n.length&&t<=n[n.length-2].prec;)a=n.pop(),r=n.pop().value,i=n.pop(),e=B(r,i,a),n.push(e);(e=h())||k(\"Expected expression after \"+s,p),n.push(o,e)}for(e=n[u=n.length-1];1<u;)e=B(n[u-1].value,n[u-2],e),u-=2;return e},h=function(){var e,r,t;if(f(),e=u(p),M(e)||46===e)return d();if(39===e||34===e)return v();if(91===e)return b();for(t=(r=n.substr(p,j)).length;0<t;){if(O.hasOwnProperty(r)&&(!q(u(p))||p+r.length<n.length&&!J(u(p+r.length))))return p+=t,{type:\"UnaryExpression\",operator:r,argument:h(),prefix:!0};r=r.substr(0,--t)}return!(!q(e)&&40!==e)&&g()},d=function(){for(var e,r,t=\"\";M(u(p));)t+=i(p++);if(46===u(p))for(t+=i(p++);M(u(p));)t+=i(p++);if(\"e\"===(e=i(p))||\"E\"===e){for(t+=i(p++),\"+\"!==(e=i(p))&&\"-\"!==e||(t+=i(p++));M(u(p));)t+=i(p++);M(u(p-1))||k(\"Expected exponent (\"+t+i(p)+\")\",p)}return r=u(p),q(r)?k(\"Variable names cannot start with a number (\"+t+i(p)+\")\",p):46===r&&k(\"Unexpected period\",p),{type:w,value:parseFloat(t),raw:t}},v=function(){for(var e,r=\"\",t=i(p++),n=!1;p<s;){if((e=i(p++))===t){n=!0;break}if(\"\\\\\"===e)switch(e=i(p++)){case\"n\":r+=\"\\n\";break;case\"r\":r+=\"\\r\";break;case\"t\":r+=\"\\t\";break;case\"b\":r+=\"\\b\";break;case\"f\":r+=\"\\f\";break;case\"v\":r+=\"\\v\";break;default:r+=e}else r+=e}return n||k('Unclosed quote after \"'+r+'\"',p),{type:w,value:r,raw:t+r+t}},x=function(){var e,r=u(p),t=p;for(q(r)?p++:k(\"Unexpected \"+i(p),p);p<s&&(r=u(p),J(r));)p++;return e=n.slice(t,p),P.hasOwnProperty(e)?{type:w,value:P[e],raw:e}:\"this\"===e?{type:\"ThisExpression\"}:{type:\"Identifier\",name:e}},y=function(e){for(var r,t,n=[],o=!1,i=0;p<s;){if(f(),(r=u(p))===e){o=!0,p++,41===e&&i&&i>=n.length&&k(\"Unexpected token \"+String.fromCharCode(e),p);break}if(44===r){if(p++,++i!==n.length)if(41===e)k(\"Unexpected token ,\",p);else if(93===e)for(var a=n.length;a<i;a++)n.push(null)}else(t=c())&&t.type!==C||k(\"Expected comma\",p),n.push(t)}return o||k(\"Expected \"+String.fromCharCode(e),p),n},g=function(){var e,r;for(r=40===(e=u(p))?m():x(),f(),e=u(p);46===e||91===e||40===e;)p++,46===e?(f(),r={type:U,computed:!1,object:r,property:x()}):91===e?(r={type:U,computed:!0,object:r,property:c()},f(),93!==(e=u(p))&&k(\"Unclosed [\",p),p++):40===e&&(r={type:\"CallExpression\",arguments:y(41),callee:r}),f(),e=u(p);return r},m=function(){p++;var e=c();if(f(),41===u(p))return p++,e;k(\"Unclosed (\",p)},b=function(){return p++,{type:\"ArrayExpression\",elements:y(93)}},E=[];p<s;)59===(e=u(p))||44===e?p++:(r=c())?E.push(r):p<s&&k('Unexpected \"'+i(p)+'\"',p);return 1===E.length?E[0]:{type:C,body:E}};if(t.version=\"0.3.4\",t.toString=function(){return\"JavaScript Expression Parser (JSEP) v\"+t.version},t.addUnaryOp=function(e){return j=Math.max(e.length,j),O[e]=!0,this},t.addBinaryOp=function(e,r){return A=Math.max(e.length,A),S[e]=r,this},t.addLiteral=function(e,r){return P[e]=r,this},t.removeUnaryOp=function(e){return delete O[e],e.length===j&&(j=r(O)),this},t.removeAllUnaryOps=function(){return O={},j=0,this},t.removeBinaryOp=function(e){return delete S[e],e.length===A&&(A=r(S)),this},t.removeAllBinaryOps=function(){return S={},A=0,this},t.removeLiteral=function(e){return delete P[e],this},t.removeAllLiterals=function(){return P={},this},\"undefined\"==typeof exports){var n=e.jsep;(e.jsep=t).noConflict=function(){return e.jsep===t&&(e.jsep=n),t}}else\"undefined\"!=typeof module&&module.exports?exports=module.exports=t:exports.parse=t}(this);\n\n!function(){if(self.Element&&(Element.prototype.matches||(Element.prototype.matches=Element.prototype.webkitMatchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||null),Element.prototype.matches)){var p=self.Stretchy={selectors:{base:'textarea, select:not([size]), input:not([type]), input[type=\"'+\"text number url email tel\".split(\" \").join('\"], input[type=\"')+'\"]',filter:\"*\"},script:document.currentScript||t(\"script\").pop(),resize:function(e){if(p.resizes(e)){var t,i=getComputedStyle(e),n=0;!e.value&&e.placeholder&&(t=!0,e.value=e.placeholder);var o=e.nodeName.toLowerCase();if(\"textarea\"==o)e.style.height=\"0\",\"border-box\"==i.boxSizing?n=e.offsetHeight:\"content-box\"==i.boxSizing&&(n=-e.clientHeight+parseFloat(i.minHeight)),e.style.height=e.scrollHeight+n+\"px\";else if(\"input\"==o)if(e.style.width=\"1000px\",e.offsetWidth){e.style.width=\"0\",\n\"border-box\"==i.boxSizing?n=e.offsetWidth:\"padding-box\"==i.boxSizing?n=e.clientWidth:\"content-box\"==i.boxSizing&&(n=parseFloat(i.minWidth));var r=Math.max(n,e.scrollWidth-e.clientWidth);e.style.width=r+\"px\";for(var l=0;l<10&&(e.scrollLeft=1e10,0!=e.scrollLeft);l++)r+=e.scrollLeft,e.style.width=r+\"px\"}else e.style.width=e.value.length+1+\"ch\";else if(\"select\"==o){if(-1==e.selectedIndex)return;var s,c=0<e.selectedIndex?e.selectedIndex:0,a=document.createElement(\"_\");for(var d in a.textContent=e.options[c].textContent,e.parentNode.insertBefore(a,e.nextSibling),i){var h=i[d];/^(width|webkitLogicalWidth|length)$/.test(d)||\"string\"!=typeof h||(a.style[d]=h,/appearance$/i.test(d)&&(s=d))}a.style.width=\"\",0<a.offsetWidth&&(e.style.width=a.offsetWidth+\"px\",i[s]&&\"none\"===i[s]||(e.style.width=\"calc(\"+e.style.width+\" + 2em)\")),a.parentNode.removeChild(a),a=null}t&&(e.value=\"\")}},resizeAll:function(e){t(e||p.selectors.base).forEach(function(e){p.resize(e)})},active:!0,resizes:function(e){\nreturn e&&e.parentNode&&e.matches&&e.matches(p.selectors.base)&&e.matches(p.selectors.filter)},init:function(){p.selectors.filter=p.script.getAttribute(\"data-filter\")||(t(\"[data-stretchy-filter]\").pop()||document.body).getAttribute(\"data-stretchy-filter\")||p.selectors.filter,p.resizeAll(),self.MutationObserver&&!p.observer&&(p.observer=new MutationObserver(function(e){p.active&&e.forEach(function(e){\"childList\"==e.type&&p.resizeAll(e.addedNodes)})}),p.observer.observe(document.documentElement,{childList:!0,subtree:!0}))},$$:t};\"loading\"!==document.readyState?requestAnimationFrame(p.init):document.addEventListener(\"DOMContentLoaded\",p.init),window.addEventListener(\"load\",function(){p.resizeAll()});var e=function(e){p.active&&p.resize(e.target)};document.documentElement.addEventListener(\"input\",e),document.documentElement.addEventListener(\"change\",e)}function t(e,t){return e instanceof Node||e instanceof Window?[e]:[].slice.call(\"string\"==typeof e?(t||document).querySelectorAll(e):e||[])\n}}();\n\n\n\n","/**\n * Mavo: Create web applications by writing HTML and CSS!\n * @author Lea Verou and contributors\n * @version %%VERSION%%\n */\n\n Stretchy.selectors.filter = \".mv-editor:not([property]), .mv-autosize\";\n\n(async function ($, $$) {\n\n// Define $ and $$ if they are not already defined\n// Primarily for backwards compat since we used to use Bliss Full.\nself.$ = self.$ || $;\nself.$$ = self.$$ || $$;\n\nlet _ = self.Mavo = $.Class(class Mavo {\n\tconstructor(element) {\n\t\tthis.treeBuilt = Mavo.promise();\n\t\tthis.dataLoaded = Mavo.promise();\n\t\tthis.deleted = [];\n\n\t\tthis.element = element;\n\n\t\tthis.inProgress = false;\n\n\t\t// Index among other mavos in the page, 1 is first\n\t\tthis.index = Object.keys(_.all).length + 1;\n\t\tObject.defineProperty(_.all, this.index - 1, {value: this, configurable: true});\n\n\t\t// Assign a unique (for the page) id to this mavo instance\n\t\tthis.id = Mavo.getAttribute(this.element, \"mv-app\", \"id\") || `mavo${this.index}`;\n\n\t\tif (this.id in _.all) {\n\t\t\t// Duplicate app name\n\t\t\tfor (var i=2; this.id + i in _.all; i++) {}\n\t\t\tthis.id = this.id + i;\n\t\t}\n\n\t\t_.all[this.id] = this;\n\t\tthis.element.setAttribute(\"mv-app\", this.id);\n\n\t\tthis.observe({attribute: \"lang\", deep: false}, () => {\n\t\t\tvar lang = Mavo.getClosestAttribute(this.element, \"lang\") || Mavo.locale;\n\t\t\tthis.locale = Mavo.Locale.get(lang);\n\t\t})();\n\n\t\t// Should we start in edit mode?\n\t\tthis.autoEdit = this.element.classList.contains(\"mv-autoedit\");\n\n\t\t// Should we save automatically?\n\t\tthis.autoSave = this.element.hasAttribute(\"mv-autosave\");\n\t\tthis.autoSaveDelay = (this.element.getAttribute(\"mv-autosave\") || 0) * 1000;\n\n\t\tMavo.setAttributeShy(this.element, \"typeof\", \"\");\n\n\t\tMavo.hooks.run(\"init-start\", this);\n\n\t\t// ----- Heuristic for groups ------\n\n\t\t// Now, turn properties that contain other properties into groups\n\t\t$$(_.selectors.primitive, this.element).forEach(element => {\n\t\t\tif ($(_.selectors.property, element)) { // contains other properties\n\t\t\t\tlet config = Mavo.Primitive.getConfig(element);\n\n\t\t\t\tif (!config.attribute && !config.hasChildren || element.hasAttribute(\"mv-list-item\")) {\n\t\t\t\t\telement.setAttribute(\"mv-group\", \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.expressions = new Mavo.Expressions(this);\n\n\t\t_.observers = _.observers || new Mavo.Observers();\n\t\t_.observers.observer.observe(this.element, {\n\t\t\t// Observe everything\n\t\t\tcharacterData: true,\n\t\t\tchildList: true,\n\t\t\tsubtree: true,\n\t\t\tattributes: true\n\t\t});\n\n\t\t// Build mavo objects\n\t\tMavo.hooks.run(\"init-tree-before\", this);\n\n\t\tthis.root = new Mavo.Group(this.element, this);\n\t\tthis.treeBuilt.resolve();\n\n\t\tMavo.hooks.run(\"init-tree-after\", this);\n\n\t\tthis.permissions = new Mavo.Permissions();\n\n\t\tvar backendTypes = [\"source\", \"storage\", \"init\", \"uploads\"]; // order is significant!\n\n\t\t// Figure out backends for storage, data reads, and initialization respectively\n\t\tbackendTypes.forEach(role => this.updateBackend(role));\n\n\t\tthis.observe({deep: false, attribute: true}, ({attribute}) => {\n\t\t\tif (attribute.indexOf(\"mv-\") === 0) {\n\t\t\t\t// We want to observe changes both in a backend (the mv-role attribute)\n\t\t\t\t// and its metadata (provided via the mv-role-* family of attributes)\n\t\t\t\tlet role = attribute?.replace(/^mv-/, \"\")?.split(\"-\")?.[0];\n\n\t\t\t\tif (backendTypes.includes(role)) {\n\t\t\t\t\tthis.updateBackend(role);\n\n\t\t\t\t\t// Do we need to re-load data?\n\t\t\t\t\tif (role === \"source\" || (!this.source && (role === \"storage\" || role === \"init\" && !this.root.data))) {\n\t\t\t\t\t\tthis.load();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\n\t\tthis.permissions.can(\"login\", () => {\n\t\t\t// We also support a URL param to trigger login, in case the user doesn't want visible login UI\n\t\t\tlet loginUrlParam;\n\t\t\tif (Mavo.Functions.url(\"login\") !== null && this.index === 1) {\n\t\t\t\tloginUrlParam = \"login\";\n\t\t\t}\n\t\t\telse if (Mavo.Functions.url(this.id + \"-login\") !== null) {\n\t\t\t\tloginUrlParam = this.id + \"-login\";\n\t\t\t}\n\n\t\t\tif (loginUrlParam !== undefined) {\n\t\t\t\t// Remove param from url\n\t\t\t\tconst currentURL = new URL(location.href);\n\t\t\t\tcurrentURL.searchParams.delete(loginUrlParam);\n\t\t\t\thistory.replaceState(null, \"\", currentURL);\n\t\t\t\tthis.primaryBackend.login();\n\t\t\t}\n\t\t});\n\n\t\t// Update login status\n\t\t$.bind(this.element, \"mv-login.mavo\", evt => {\n\t\t\tif (evt.backend == (this.source || this.storage)) {\n\t\t\t\t// If last time we rendered we got nothing, maybe now we'll have better luck?\n\t\t\t\tif (!this.root.data && !this.unsavedChanges) {\n\t\t\t\t\tthis.load();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.bar = new Mavo.UI.Bar(this);\n\n\t\t// Is there any control that requires an edit button?\n\t\tthis.needsEdit = this.calculateNeedsEdit();\n\n\t\tthis.setUnsavedChanges(false);\n\n\t\tthis.permissions.onchange(({action, value}) => {\n\t\t\tvar permissions = this.element.getAttribute(\"mv-permissions\") || \"\";\n\t\t\tpermissions = permissions.trim().split(/\\s+/).filter(a => a != action);\n\n\t\t\tif (value) {\n\t\t\t\tpermissions.push(action);\n\t\t\t}\n\n\t\t\tthis.element.setAttribute(\"mv-permissions\", permissions.join(\" \"));\n\t\t});\n\n\t\tthis.permissions.can([\"edit\", \"add\", \"delete\"], () => {\n\t\t\tif (this.autoEdit) {\n\t\t\t\tthis.edit();\n\t\t\t}\n\t\t});\n\n\t\t// Observe entire tree for mv-mode changes\n\t\tthis.observe({attribute: \"mv-mode\"}, ({element}) => {\n\t\t\tif (!this.permissions.edit && !this.permissions.add && !this.permissions.delete) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet nodes = _.Node.children(element);\n\n\t\t\tnodeloop: for (let i=0; i<nodes.length; i++) {\n\t\t\t\tlet node = nodes[i];\n\t\t\t\tlet previousMode = node.mode, mode;\n\n\t\t\t\tif (node.element == element) {\n\t\t\t\t\t// If attribute set directly on a Mavo node, then it forces it into that mode\n\t\t\t\t\t// otherwise, descendant nodes still inherit, unless they are also mode-restricted\n\t\t\t\t\tmode = node.element.getAttribute(\"mv-mode\");\n\t\t\t\t\tnode.modes = mode;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Inherited\n\t\t\t\t\tif (node.modes) {\n\t\t\t\t\t\t// Mode-restricted, we cannot change to the other mode\n\t\t\t\t\t\tcontinue nodeloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tmode = _.getStyle(node.element.parentNode, \"--mv-mode\");\n\t\t\t\t}\n\n\t\t\t\tnode.mode = mode;\n\n\t\t\t\tif (previousMode != node.mode) {\n\t\t\t\t\tnode[node.mode == \"edit\"? \"edit\" : \"done\"]();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (this.primaryBackend) {\n\t\t\t// Fetch existing data\n\t\t\tthis.permissions.can(\"read\", () => this.load());\n\t\t}\n\t\telse {\n\t\t\t// No storage or source\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tthis.dataLoaded.resolve();\n\t\t\t\tthis.expressions.update();\n\t\t\t\tthis.element.dispatchEvent(new Event(\"mv-load\", {bubbles: true}));\n\t\t\t});\n\t\t}\n\n\t\t// Dynamic ids\n\t\t$.bind(this.element, \"mv-load.mavo\", evt => {\n\t\t\tif (location.hash) {\n\t\t\t\tvar callback = () => {\n\t\t\t\t\tvar target = document.getElementById(location.hash.slice(1));\n\n\t\t\t\t\tif (target || !location.hash) {\n\t\t\t\t\t\tif (this.element.contains(target)) {\n\t\t\t\t\t\t\trequestAnimationFrame(() => { // Give the browser a chance to render\n\t\t\t\t\t\t\t\tMavo.scrollIntoViewIfNeeded(target);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn target;\n\t\t\t\t};\n\n\t\t\t\tif (!callback()) {\n\t\t\t\t\t// No target, perhaps not yet?\n\t\t\t\t\tthis.observe({attribute: \"id\", once: true}, callback);\n\t\t\t\t\t// FIXME if expressions take multiple cycles to resolve, this will not scroll to the proper id\n\t\t\t\t\t// FIXME also, if the user has started interacting with the document, we shouldn't scroll\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequestAnimationFrame(() => Stretchy.resizeAll());\n\t\t});\n\n\t\tthis.dataLoaded.then(async evt => {\n\t\t\tawait Mavo.defer();\n\n\t\t\tthis.permissions.can(\"save\", () => {\n\t\t\t\tif (this.autoSave) {\n\t\t\t\t\tlet debouncedSave = _.debounce(() => {\n\t\t\t\t\t\tthis.save();\n\t\t\t\t\t}, this.autoSaveDelay);\n\n\t\t\t\t\t$.bind(this.element, \"mv-change.mavo:autosave\", evt => {\n\t\t\t\t\t\tif (evt.node.saved && this.autoSave) {\n\t\t\t\t\t\t\tdebouncedSave();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, () => {\n\t\t\t\t$.unbind(this.element, \"mv-change.mavo:autosave\");\n\t\t\t});\n\t\t});\n\n\t\t// Keyboard navigation\n\t\tthis.element.addEventListener(\"keydown\", evt => {\n\t\t\tvar element = evt.target;\n\n\t\t\t// Ctrl + S or Cmd + S to save\n\t\t\tif (this.permissions.save && evt.key == \"S\" && evt[_.superKey] && !evt.altKey) {\n\t\t\t\tevt.preventDefault();\n\t\t\t\tthis.save();\n\t\t\t}\n\t\t\telse if (evt.key === \"ArrowUp\" || evt.key === \"ArrowDown\") {\n\t\t\t\tif (element.matches(\"textarea, input[type=range], input[type=number]\")) {\n\t\t\t\t\t// Up/down arrow keys are meaningful here\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (element.matches(\".mv-editor\")) {\n\t\t\t\t\tvar editor = true;\n\t\t\t\t\telement = element.parentNode;\n\t\t\t\t}\n\n\t\t\t\tvar node = Mavo.Node.get(element);\n\n\t\t\t\tif (node?.closestCollection) {\n\t\t\t\t\tvar nextNode = node.getCousin(evt.key === \"ArrowUp\"? -1 : 1, {wrap: true});\n\n\t\t\t\t\tif (nextNode) {\n\t\t\t\t\t\tif (editor && nextNode.editing) {\n\t\t\t\t\t\t\tnextNode.edit();\n\t\t\t\t\t\t\tnextNode.editor.focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnextNode.element.focus();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t$.bind(this.element, \"click submit\", _.Actions.listener);\n\n\t\tMavo.hooks.run(\"init-end\", this);\n\t}\n\n\tget editing() {\n\t\treturn this.root.editing;\n\t}\n\n\tobserve (o = {}, callback) {\n\t\tlet options = Object.assign({element: this.element}, o);\n\t\treturn _.observers?.observe(options, callback);\n\t}\n\n\tunobserve (o, callback) {\n\t\tlet options = Object.assign({element: this.element}, o);\n\t\treturn _.observers?.unobserve(options, callback);\n\t}\n\n\tgetData (o) {\n\t\tlet env = {context: this, options: o};\n\t\tenv.data = this.root.getData(o);\n\t\t_.hooks.run(\"getdata-end\", env);\n\t\treturn env.data;\n\t}\n\n\ttoJSON () {\n\t\treturn _.toJSON(this.getData());\n\t}\n\n\tmessage (message, options = {}) {\n\t\treturn new _.UI.Message(this, message, options);\n\t}\n\n\terror (message, ...log) {\n\t\tthis.message(message, {\n\t\t\ttype: \"error\",\n\t\t\tdismiss: [\"button\", \"timeout\"]\n\t\t});\n\n\t\t// Log more info for programmers\n\t\tif (log.length > 0) {\n\t\t\tconsole.log(`%c${this.id}: ${message}`, \"color: red; font-weight: bold\", ...log);\n\t\t}\n\t}\n\n\trender (data) {\n\t\tvar env = {context: this, data};\n\t\t_.hooks.run(\"render-start\", env);\n\n\t\tif (env.data) {\n\t\t\tthis.root.render(env.data);\n\t\t}\n\n\t\tthis.unsavedChanges = false;\n\n\t\t_.hooks.run(\"render-end\", env);\n\t}\n\n\tedit () {\n\t\tif (this.bar?.edit) {\n\t\t\tthis.bar.edit.click();\n\t\t}\n\n\t\tthis.root.edit();\n\n\t\t// Highlight collection item when item controls are hovered\n\t\t$.bind(this.element, \"mouseenter.mavo:edit mouseleave.mavo:edit\", evt => {\n\t\t\tif (evt.target.matches(_.selectors.multiple)) {\n\t\t\t\tevt.target.classList.remove(\"mv-has-hovered-item\");\n\n\t\t\t\tvar parent = evt.target.parentNode.closest(_.selectors.multiple);\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tparent.classList.toggle(\"mv-has-hovered-item\", evt.type == \"mouseenter\");\n\t\t\t\t}\n\t\t\t}\n\t\t}, true);\n\n\t\tthis.setUnsavedChanges();\n\t}\n\n\t// Conclude editing\n\tdone () {\n\t\tthis.root.done();\n\t\t$.unbind(this.element, \".mavo:edit\");\n\t\tthis.unsavedChanges = false;\n\t}\n\n\t/**\n\t * Set this mavo instances unsavedChanges flag.\n\t * @param {Boolean} [value]\n\t *        If true, just sets the flag to true, no traversal.\n\t *        If false, sets the flag of the Mavo instance and every tree node to false\n\t *        If not provided, traverses the tree and recalculates the flag value.\n\t */\n\tsetUnsavedChanges (value) {\n\t\tvar unsavedChanges = !!value;\n\n\t\tif (!value) {\n\t\t\tthis.walk(obj => {\n\t\t\t\tif (obj.unsavedChanges) {\n\t\t\t\t\tunsavedChanges = true;\n\n\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\tobj.unsavedChanges = false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this.unsavedChanges = unsavedChanges;\n\t}\n\n\t/**\n\t * Update the backend for a given role\n\t * @return {Boolean} true if a change occurred, false otherwise\n\t */\n\tupdateBackend (role) {\n\t\tlet existing = this[role], backend, changed;\n\t\tconst attribute = \"mv-\" + role;\n\n\t\tif (this.index == 1) {\n\t\t\t// This app is the first one in the page, so we can override its backend\n\t\t\t// via URL params such as ?storage=...\n\t\t\tbackend = _.Functions.url(role);\n\t\t}\n\n\t\tif (!backend) {\n\t\t\tbackend = _.Functions.url(`${this.id}-${role}`)\n\t\t\t          || _.Functions.url(`${this.id.toLowerCase()}-${role}`)\n\t\t\t          || this.element.getAttribute(attribute) || null;\n\t\t}\n\n\t\tif (backend) {\n\t\t\tbackend = backend.trim();\n\n\t\t\tif (backend == \"none\") {\n\t\t\t\tbackend = null;\n\t\t\t}\n\t\t}\n\n\t\tif (backend) {\n\t\t\t// Do we have any other attributes?\n\t\t\tlet prefix = attribute + \"-\";\n\t\t\tlet roleAttributes = Mavo.getAttributes(this.element, RegExp(\"^\" + prefix));\n\t\t\tlet options = Object.fromEntries(roleAttributes.map(n => [n.replace(prefix, \"\"), this.element.getAttribute(n)]));\n\n\t\t\tif (!existing?.equals?.(backend)) {\n\t\t\t\t// We have a string, convert to a backend object if different than existing\n\t\t\t\tthis[role] = backend = _.Backend.create(backend, {\n\t\t\t\t\tformat: this.element.getAttribute(\"mv-format\"), // can be overwritten by options below\n\t\t\t\t\t...options,\n\t\t\t\t\tmavo: this\n\t\t\t\t}, existing);\n\n\t\t\t\tchanged = true;\n\n\t\t\t\t// Shim for previous mv-login and mv-logout events that were on the Mavo root\n\t\t\t\t$.bind(backend, \"mv-login mv-logout\", evt => {\n\t\t\t\t\t$.fire(this.element, evt.type, {backend});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We had a backend and now we will un-have it\n\t\t\tthis[role] = null;\n\t\t}\n\n\t\tchanged = changed || (backend? !backend.equals(existing) : Boolean(existing));\n\n\t\tif (changed) {\n\t\t\t// A change occured\n\t\t\tif (!this.storage && !this.source && this.init) {\n\t\t\t\t// If init is present with no storage and no source, init is equivalent to source\n\t\t\t\tthis.source = this.init;\n\t\t\t\tthis.init = null;\n\t\t\t}\n\n\t\t\tvar permissions = this.storage? this.storage.permissions : new Mavo.Permissions({edit: true, save: false});\n\t\t\tpermissions.parent = this.source?.permissions;\n\t\t\tthis.permissions.parent = permissions;\n\n\t\t\tthis.primaryBackend = this.storage || this.source;\n\t\t\tthis.sourceBackend = this.source || this.storage || this.init;\n\n\t\t\tlet updateListener = evt => {\n\t\t\t\tif (evt.target !== this.sourceBackend) {\n\t\t\t\t\tevt.target.removeEventListener(\"mv-remotedatachange\", updateListener);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.push(evt.data);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sourceBackend?.addEventListener(\"mv-remotedatachange\", updateListener);\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\t/*\n\t * Push new data from the remote\n\t * @param {Object} data The data\n\t * @param options\n\t * @param {(\"ask\", \"force\", \"stop\")} options.conflictPolicy What to do when there are unsaved changes?\n\t */\n\tasync push(data, {conflictPolicy = \"stop\"} = {}) {\n\t\tif (this.unsavedChanges) {\n\t\t\tif (conflictPolicy === \"ask\") {\n\t\t\t\t// TODO non-modal confirmation\n\t\t\t\tif (!confirm(this._(\"remote-data-conflict\"))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (conflictPolicy === \"stop\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\treturn this.load({data});\n\t}\n\n\t/**\n\t * load - Fetch data from source and render it.\n\t *\n\t * @return {Promise}  A promise that resolves when the data is loaded.\n\t */\n\tasync load ({backend, data} = {}) {\n\t\tlet specificBackend = backend;\n\t\tbackend = backend ?? this.sourceBackend;\n\n\t\tif (!backend && !data) {\n\t\t\t// Nothing to do here\n\t\t\treturn;\n\t\t}\n\n\t\tlet autoSaveState = this.autoSave;\n\t\tthis.autoSave = false;\n\n\t\tif (data === undefined) {\n\t\t\tthis.inProgress = \"Loading\";\n\n\t\t\tawait backend.ready;\n\n\t\t\tdata = null;\n\n\t\t\ttry {\n\t\t\t\tdata = await backend.load();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tif (!specificBackend && this.init && this.init !== backend) {\n\t\t\t\t\tawait this.init.ready;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdata = await this.init.load();\n\t\t\t\t\t\tbackend = this.init;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {}\n\t\t\t\t}\n\n\t\t\t\tif (err && data === null) {\n\t\t\t\t\tlet response = err instanceof Response || err instanceof XMLHttpRequest? err : err.xhr;\n\n\t\t\t\t\tif (response?.status !== 404) {\n\t\t\t\t\t\tlet message = this._(\"problem-loading\");\n\n\t\t\t\t\t\tif (response) {\n\t\t\t\t\t\t\tmessage += response.status? this._(\"http-error\", err) : \": \" + this._(\"cant-connect\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.error(message, err);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.inProgress = false;\n\t\t}\n\n\t\tthis.render(data);\n\n\t\tawait Mavo.defer();\n\n\t\tthis.dataLoaded.resolve();\n\t\tthis.element.dispatchEvent(new CustomEvent(\"mv-load\", {detail: backend, bubbles: true}));\n\t\tthis.autoSave = autoSaveState;\n\t}\n\n\tasync store () {\n\t\tif (!this.storage) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.inProgress = \"Saving\";\n\n\t\tlet saved;\n\n\t\ttry {\n\t\t\tsaved = await this.storage.store(this.getData());\n\t\t}\n\t\tcatch (err) {\n\t\t\tif (err) {\n\t\t\t\tvar message = this._(\"problem-saving\");\n\n\t\t\t\tif (err instanceof XMLHttpRequest) {\n\t\t\t\t\tmessage += \": \" + (err.status? this._(\"http-error\", err) : this._(\"cant-connect\"));\n\t\t\t\t}\n\n\t\t\t\tthis.error(message, err);\n\t\t\t}\n\n\t\t\tsaved = null;\n\t\t}\n\n\t\tthis.inProgress = false;\n\t\treturn saved;\n\t}\n\n\tupload (file, path = \"images/\" + file.name) {\n\t\tif (!this.uploadBackend) {\n\t\t\treturn Promise.reject();\n\t\t}\n\n\t\tthis.inProgress = \"Uploading\";\n\n\t\treturn this.uploadBackend.upload(file, path)\n\t\t\t.then(url => {\n\t\t\t\tthis.inProgress = false;\n\t\t\t\treturn url;\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.error(this._(\"error-uploading\"), err);\n\t\t\t\tthis.inProgress = false;\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\tasync save () {\n\t\t_.hooks.run(\"save-start\", this);\n\t\tlet saved = await this.store();\n\n\t\tif (saved) {\n\t\t\t$.fire(this.element, \"mv-save\", saved);\n\n\t\t\tthis.lastSaved = Date.now();\n\t\t\tthis.root.save();\n\t\t\tthis.unsavedChanges = false;\n\t\t}\n\t}\n\n\twalk () {\n\t\treturn this.root.walk(...arguments);\n\t}\n\n\tcalculateNeedsEdit () {\n\t\tvar needsEdit = false;\n\n\t\tthis.walk((obj, path) => {\n\t\t\tif (needsEdit) {\n\t\t\t\t// If already true, no need to descend further\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// True if both modes are allowed and node is not group\n\t\t\tneedsEdit = !obj.modes && !(obj instanceof Mavo.Group);\n\n\t\t\treturn !obj.modes;\n\t\t}, undefined, {descentReturn: true});\n\n\t\treturn needsEdit;\n\t}\n\n\tchanged (change) {\n\t\tif (!this.root) {\n\t\t\t// No tree yet\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.expressions.active) {\n\t\t\tthis.expressions.updateThrottled(change);\n\t\t}\n\t}\n\n\tsetDeleted (...nodes) {\n\t\t// Clear previous deleted item(s)\n\t\tthis.deleted.forEach(node => node.destroy());\n\t\tthis.deleted.length = 0;\n\n\t\tthis.deletionNotice?.close();\n\n\t\tif (!nodes.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deleted.push(...nodes);\n\n\t\tif (nodes.length == 1) {\n\t\t\tvar phrase = nodes[0].name;\n\t\t}\n\t\telse { // Multiple items deleted, possibly from multiple collections\n\t\t\tvar counts = {}, ret = [];\n\n\t\t\tnodes.forEach(n => {\n\t\t\t\tcounts[n.name] = (counts[n.name] || 0) + 1;\n\t\t\t});\n\n\t\t\tfor (var name in counts) {\n\t\t\t\tret.push(this._(\"n-items\", {name, n: counts[name]}));\n\t\t\t}\n\n\t\t\tvar phrase = ret.join(\", \");\n\t\t}\n\n\t\tvar notice = this.deletionNotice = this.message(\n\t\t\t[\n\t\t\t\tthis._(\"item-deleted\", {name: phrase}),\n\t\t\t\t{\n\t\t\t\t\ttag: \"button\",\n\t\t\t\t\ttype: \"button\",\n\t\t\t\t\ttextContent: this._(\"undo\"),\n\t\t\t\t\tevents: {\n\t\t\t\t\t\tclick: evt => {\n\t\t\t\t\t\t\tthis.undoDelete();\n\t\t\t\t\t\t\tthis.deletionNotice.close(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t], {\n\t\t\t\tclasses: \"mv-deleted\",\n\t\t\t\tdismiss: {\n\t\t\t\t\tbutton: true,\n\t\t\t\t\ttimeout: 20000\n\t\t\t\t}\n\t\t\t});\n\n\t\tnotice.closed.then(undone => {\n\t\t\tif (!undone && this.deleted.length) {\n\t\t\t\t// Gone forever now\n\t\t\t\tthis.deleted.forEach(node => node.destroy());\n\t\t\t\tthis.deleted.length = 0;\n\t\t\t}\n\n\t\t\tif (this.deletionNotice == notice) {\n\t\t\t\tthis.deletionNotice = null;\n\t\t\t}\n\t\t});\n\t}\n\n\tundoDelete () {\n\t\tthis.deleted.forEach(node => node.collection.add(node, node.index));\n\t\tthis.deleted.length = 0;\n\t}\n\n\t// A lot of this is inspired by @hopeful2's work in https://github.com/mavoweb/mavo/pull/430\n\tdestroy () {\n\t\tMavo.hooks.run(\"mavo-destroy-start\", this);\n\n\t\tif (this.editing) {\n\t\t\tthis.done();\n\t\t}\n\n\t\t// first remove observers.\n\t\tthis.observer.destroy();\n\n\t\tthis.bar?.destroy();\n\n\t\t// .index starts from 1, .all starts from 0\n\t\t// ISSUE Should we just delete this and rearrange the other indices?\n\t\tMavo.all[this.id] = Mavo.all[this.index - 1] = null;\n\n\t\tthis.root.destroy();\n\n\t\tMavo.hooks.run(\"mavo-destroy-end\", this);\n\t}\n\n\tstatic version = \"%%VERSION%%\"\n\n\tstatic all = {}\n\n\tstatic get (id) {\n\t\tif (id instanceof Element) {\n\t\t\t// Get by element\n\t\t\tfor (let name in _.all) {\n\t\t\t\tif (_.all[name].element == id) {\n\t\t\t\t\treturn _.all[name];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tlet name = typeof id === \"number\"? Object.keys(_.all)[id] : id;\n\n\t\treturn _.all[name] || null;\n\t}\n\n\tstatic superKey = navigator.platform.indexOf(\"Mac\") === 0? \"metaKey\" : \"ctrlKey\"\n\tstatic base = [\"blob:\", \"about:\"].includes(location.protocol)? (document.currentScript?.src || \"https://mavo.io\") : location\n\tstatic dependencies = [\n\t\t// Plugins.load() must be run after DOM load to pick up all mv-plugins attributes\n\t\t$.ready().then(() => _.Plugins.load()),\n\t]\n\n\t// Only naive tests here (no false positives, but false negatives are ok).\n\t// polyfill.io will do more proper checking\n\tstatic polyfillsNeeded = {\n\t\t\"blissfuljs\": Array.from && document.documentElement.closest && self.URL && \"searchParams\" in URL.prototype,\n\t\t\"Intl.~locale.en\": self.Intl,\n\t\t\"IntersectionObserver\": self.IntersectionObserver,\n\t\t\"Symbol\": self.Symbol,\n\t\t\"Element.prototype.remove\": Element.prototype.remove,\n\t\t\"Element.prototype.before\": Element.prototype.before,\n\t\t\"Element.prototype.after\": Element.prototype.after,\n\t\t\"Element.prototype.prepend\": Element.prototype.prepend,\n\t\t\"Array.prototype.flat\": Array.prototype.flat,\n\t\t\"Array.prototype.flatMap\": Array.prototype.flatMap,\n\t}\n\tstatic polyfills = []\n\n\tstatic init (container = document) {\n\t\tlet mavos = Array.isArray(arguments[0])? arguments[0] : $$(_.selectors.init, container);\n\n\t\tlet ret = mavos.filter(element => !_.get(element)) // not already inited\n\t\t\t.map(element => new _(element));\n\n\t\treturn ret;\n\t}\n\n\tstatic observe (options, callback) {\n\t\t_.observers = _.observers || new Mavo.Observers();\n\t\treturn _.observers.observe(options, callback);\n\t}\n\n\tstatic unobserve (options, callback) {\n\t\t_.observers.unobserve(options, callback);\n\t}\n\n\tstatic warn (message, o = {}) {\n\t\t_.warn.history = _.warn.history || new Set();\n\n\t\tif (!_.warn.history.has(message)) {\n\t\t\tconsole.warn(message);\n\t\t}\n\n\t\tif (o.once !== false) {\n\t\t\t_.warn.history.add(message);\n\t\t}\n\t}\n\n\t/**\n\t * Similar to Promise.all() but can handle post-hoc additions\n\t * and does not reject if one promise rejects.\n\t */\n\tstatic thenAll (iterable) {\n\t\t// Turn rejected promises into resolved ones\n\t\t$$(iterable).forEach(promise => {\n\t\t\tif ($.type(promise) == \"promise\") {\n\t\t\t\tpromise = promise.catch(err => err);\n\t\t\t}\n\t\t});\n\n\t\treturn Promise.all(iterable).then(resolved => {\n\t\t\tif (iterable.length != resolved.length) {\n\t\t\t\t// The list of promises or values changed. Return a new Promise.\n\t\t\t\t// The original promise won't resolve until the new one does.\n\t\t\t\treturn _.thenAll(iterable);\n\t\t\t}\n\n\t\t\t// The list of promises or values stayed the same.\n\t\t\t// Return results immediately.\n\t\t\treturn resolved;\n\t\t});\n\t}\n\n\tstatic promise (constructor) {\n\t\tlet res, rej;\n\n\t\tlet promise = new Promise((resolve, reject) => {\n\t\t\tif (typeof constructor === \"function\") {\n\t\t\t\tconstructor(resolve, reject);\n\t\t\t}\n\t\t\telse if (constructor instanceof Promise) {\n\t\t\t\tconstructor.then(resolve);\n\t\t\t\tconstructor.catch(reject);\n\t\t\t}\n\n\t\t\tres = resolve;\n\t\t\trej = reject;\n\t\t});\n\n\t\tpromise.resolve = a => {\n\t\t\tres(a);\n\t\t\treturn promise;\n\t\t};\n\n\t\tpromise.reject = a => {\n\t\t\trej(a);\n\t\t\treturn promise;\n\t\t};\n\n\t\treturn promise;\n\t}\n\n\tstatic defer = delay => new Promise(resolve => delay === undefined? requestAnimationFrame(resolve) : setTimeout(resolve, delay))\n\n\tstatic UI = {}\n\n\tstatic hooks = new $.Hooks()\n\n\t// Will be filled with a union of all properties across all Mavos\n\tstatic properties = new Set()\n\n\tstatic attributes = [\n\t\t\"mv-app\", \"mv-storage\", \"mv-source\", \"mv-init\", \"mv-path\", \"mv-format\",\n\t\t\"mv-attribute\", \"mv-default\", \"mv-mode\", \"mv-edit\", \"mv-editor\", \"mv-permisssions\",\n\t\t\"mv-rel\", \"mv-value\"\n\t]\n}, {\n\tlive: {\n\t\tinProgress (value) {\n\t\t\t$.toggleAttribute(this.element, \"mv-progress\", value, value);\n\t\t\t$.toggleAttribute(this.element, \"aria-busy\", !!value, !!value);\n\t\t\tthis.element.style.setProperty(\"--mv-progress-text\", value? `\"${this._(value)}\"` : \"\");\n\t\t},\n\n\t\tunsavedChanges (value) {\n\t\t\tthis.element.classList.toggle(\"mv-unsaved-changes\", value);\n\t\t},\n\n\t\tneedsEdit (value) {\n\t\t\tif (this.bar) {\n\t\t\t\tthis.bar.toggle(\"edit\", value && this.permissions.edit);\n\t\t\t}\n\t\t},\n\n\t\tstorage (value) {\n\t\t\tif (value !== this._storage && !value) {\n\t\t\t\tlet permissions = new Mavo.Permissions({edit: true, save: false});\n\t\t\t\tpermissions.parent = this.permissions.parent;\n\t\t\t\tthis.permissions.parent = permissions;\n\t\t\t}\n\t\t},\n\n\t\tprimaryBackend (value) {\n\t\t\tvalue = value || null;\n\n\t\t\tif (value != this._primaryBackend) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t},\n\n\t\tuploadBackend: {\n\t\t\tget() {\n\t\t\t\tconst backend = this.uploads;\n\n\t\t\t\tif (backend?.upload) {\n\t\t\t\t\t// We need to authenticate a user if we haven't done that earlier\n\t\t\t\t\tif (backend.permissions.login) {\n\t\t\t\t\t\tbackend.login();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this.uploads;\n\t\t\t\t}\n\n\t\t\t\tif (this.storage?.upload) {\n\t\t\t\t\t// Prioritize storage\n\t\t\t\t\treturn this.storage;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tlazy: {\n\t\tlocale: () => document.documentElement.lang || \"en-GB\"\n\t}\n});\n\n// Define symbols\n// These are lazy to give the Symbol polyfill a chance to load if needed\n[\"toNode\", \"isProxy\", \"route\", \"parent\", \"property\", \"mavo\", \"groupedBy\", \"as\"].forEach(symbol => {\n\t$.lazy(_, symbol, () => Symbol(symbol));\n});\n\nObject.defineProperty(_.all, \"length\", {\n\tget: function() {\n\t\treturn Object.keys(this).length;\n\t}\n});\n\n{\n\nlet s = _.selectors = {\n\tinit: \"[mv-app], [data-mv-app]\",\n\tproperty: \"[property]\",\n\tgroup: \"[typeof], [mv-group]\",\n\tlist: \"[mv-list]\",\n\tmultiple: \"[mv-list-item]\",\n\tformControl: \"input, select, option, textarea\",\n\ttextInput: [\"text\", \"email\", \"url\", \"tel\", \"search\", \"number\"].map(t => `input[type=${t}]`).join(\", \") + \", input:not([type]), textarea\",\n\tui: \".mv-ui\"\n};\n\ns.primitive = s.property + `:not(${s.group}, ${s.list})`;\ns.childGroup = s.property + `:is(${s.group})`;\ns.scope = `:is(${s.group}, ${s.multiple}, ${s.list})`;\ns.item = s.multiple + \", \" + s.group;\ns.output = \"[property=output], .mv-output\";\n\n}\n\n$.each(_.polyfillsNeeded, (id, supported) => {\n\tif (!supported) {\n\t\t_.polyfills.push(id);\n\t}\n});\n\n_.ready = _.thenAll(_.dependencies);\n_.inited = _.promise();\n\n// Init mavo. Async to give other scripts a chance to modify stuff.\nawait _.defer();\n\nif (_.polyfills.length > 0) {\n\tvar polyfillURL = \"https://cdn.polyfill.io/v2/polyfill.min.js?unknown=polyfill&features=\" + _.polyfills.map(a => a + \"|gated\").join(\",\");\n\t_.dependencies.push($.include(polyfillURL));\n}\n\nawait $.ready();\n\n/***********************\n * Various HTML fixups\n ***********************/\n\n// Convert any data-mv-* attributes to mv-*\nMavo.attributeStartsWith(\"data-mv-\").forEach(attribute => {\n\tlet element = attribute.ownerElement;\n\tlet name = attribute.name.replace(\"data-\", \"\");\n\tMavo.setAttributeShy(element, name, attribute.value);\n});\n\n// Expand mv-list=\"foo\" to mv-list property=\"foo\" and same for items\n$$(\"[mv-list]:not([property])\").forEach(e => e.setAttribute(\"property\", e.getAttribute(\"mv-list\")));\n$$(\"[mv-list-item]:not([property])\").forEach(e => e.setAttribute(\"property\", e.getAttribute(\"mv-list-item\")));\n\n_.containers = {\n\t\"TR\": \"TBODY\",\n\t\"OPTION\": \"OPTGROUP\",\n};\n\n// mv-list without mv-list-item child\n$$(\"[mv-list]\").forEach(list => {\n\tif (!$(\":scope > [mv-list-item]\", list)) {\n\t\tif (list.children.length === 1 && !list.children[0].matches(\"[property]\")) {\n\t\t\t// A single non-Mavo node child, make that the list item\n\t\t\tlist.children[0].setAttribute(\"mv-list-item\", \"\");\n\t\t}\n\t\telse {\n\t\t\t// Wrap contents in list item\n\t\t\tlet itemTags = Object.entries(_.containers).filter(([_, i]) => i === list.tagName);\n\t\t\tlet itemTag = itemTags[0] || \"div\";\n\t\t\t$.create(itemTag, {\n\t\t\t\tclassName: \"mv-container\",\n\t\t\t\t\"mv-list-item\": \"\",\n\t\t\t\tcontents: [...list.childNodes],\n\t\t\t\tinside: list\n\t\t\t});\n\t\t}\n\t}\n});\n\n$$(\"[mv-list-item], [mv-multiple]\").forEach(item => {\n\tlet wasLegacy;\n\n\tif (!item.hasAttribute(\"mv-list-item\")) {\n\t\t// Transition legacy mv-multiple syntax to new mv-list/mv-list-item syntax\n\t\tlet multiple = item.getAttribute(\"mv-multiple\");\n\t\titem.setAttribute(\"mv-list-item\", multiple);\n\n\t\tif (!item.hasAttribute(\"property\")) {\n\t\t\tif (multiple) { // mv-multiple has a value\n\t\t\t\titem.setAttribute(\"property\", multiple);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet property = _.Node.getImplicitPropertyName(item)\n\t\t\t\t        || _.Node.generatePropertyName(\"collection\", item);\n\t\t\t\titem.setAttribute(\"property\", property);\n\t\t\t}\n\t\t}\n\n\t\twasLegacy = true;\n\t\tMavo.warn(\"@mv-multiple is deprecated. Please use @mv-list-item and @mv-list instead\");\n\t}\n\n\tif (!item.hasAttribute(\"property\")) {\n\t\t// Expand mv-list-item=\"foo\" to mv-list-item property=\"foo\" and same for items\n\t\titem.setAttribute(\"property\", item.getAttribute(\"mv-list-item\"));\n\t}\n\n\tlet parent = item.parentNode;\n\tlet list = parent;\n\tlet property = Mavo.Node.getProperty(item);\n\n\tif (!parent.hasAttribute(\"mv-list\")) {\n\t\t// Wrap mv-list-item without mv-list parent\n\t\tif (parent.children.length !== 1 || parent.matches(\"[mv-app], [property], [mv-list-item]\")) {\n\t\t\t// Parent is a Mavo node and cannot just become the collection,\n\t\t\t// create a new element for that\n\t\t\tlet listTag = _.containers[item.tagName] || \"div\";\n\t\t\tlist = $.create(listTag, {\n\t\t\t\tclassName: \"mv-container\",\n\t\t\t\taround: item\n\t\t\t});\n\t\t}\n\n\t\tlist.setAttribute(\"mv-list\", \"\");\n\n\t\tif (property) {\n\t\t\tlist.setAttribute(\"property\", property);\n\t\t}\n\n\t\t// Transfer list-specific attributes to list\n\t\tMavo.moveAttribute(\"mv-initial-items\", item, list);\n\t\tMavo.moveAttribute(\"mv-order\", item, list);\n\t\tMavo.moveAttribute(\"mv-accepts\", item, list);\n\n\t\tif (wasLegacy) {\n\t\t\tMavo.moveAttribute(\"mv-value\", item, list);\n\t\t\tMavo.moveAttribute(\"mv-mode\", item, list);\n\t\t\tMavo.moveAttribute(\"mv-multiple-path\", item, list, {rename: \"mv-path\"});\n\t\t}\n\t\telse {\n\t\t\tMavo.warn(\"Please wrap @mv-list-item elements with @mv-list elements\");\n\t\t}\n\t}\n\n\tlet listProperty = list.getAttribute(\"property\");\n\tlet itemProperty = item.getAttribute(\"property\");\n\n\t// Make sure mv-list and mv-list-item have the same property (and that one exists)\n\tif (!listProperty && itemProperty) {\n\t\tlist.setAttribute(\"property\", itemProperty);\n\t}\n\telse if (listProperty !== itemProperty || !listProperty) {\n\t\t // Normalize list property\n\t\tlet property = Mavo.Node.getProperty(list) || Mavo.Node.generatePropertyName(\"item\", list);\n\n\t\tif (!listProperty) {\n\t\t\tlist.setAttribute(\"property\", property);\n\t\t}\n\n\t\titem.setAttribute(\"property\", property);\n\t}\n});\n\n// Resolve empty property attributes\n$$(\"[property='']\").forEach(element => {\n\tlet property = Mavo.Node.getProperty(element) || Mavo.Node.generatePropertyName(\"prop\", element);\n\telement.setAttribute(\"property\", property);\n})\n\n$$(_.selectors.init).forEach(function(elem) {\n\t// Skip if an instance has been created, for example by another script.\n\tif (!_.get(elem)) {\n\t\telem.setAttribute(\"mv-progress\", \"Loading\");\n\t}\n});\n\nif (window.CSSPropertyRule) {\n\tlet root = document.documentElement;\n\troot.classList.add(\"mv-supports-atproperty\");\n}\n\nawait _.ready;\n\n_.init();\n_.inited.resolve();\n\n})(Bliss, Bliss.$);\n","(function ($, $$) {\n\nvar _ = $.extend(Mavo, {\n\t/**\n\t * Load a file, only once\n\t */\n\tload: (url, base = document.currentScript?.src ?? location) => {\n\t\treturn $.load(url, base);\n\t},\n\n\treadFile: (file, format = \"DataURL\") => {\n\t\tvar reader = new FileReader();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treader.onload = f => resolve(reader.result);\n\t\t\treader.onerror = reader.onabort = reject;\n\t\t\treader[\"readAs\" + format](file);\n\t\t});\n\t},\n\n\ttoJSON: data => {\n\t\tif (data === null) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (typeof data === \"string\") {\n\t\t\t// Do not stringify twice!\n\t\t\treturn data;\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.stringify(data, null, \"\\t\");\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn e;\n\t\t}\n\t},\n\n\t/**\n\t * toJSON without cycles\n\t */\n\tsafeToJSON: function(o) {\n\t\tvar cache = new WeakSet();\n\n\t\treturn JSON.stringify(o, (key, value) => {\n\t\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\t\t// No circular reference found\n\n\t\t\t\tif (cache.has(value)) {\n\t\t\t\t\treturn; // Circular reference found!\n\t\t\t\t}\n\n\t\t\t\tcache.add(value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t});\n\t},\n\n\t// Detect if this is a plain object, not an instance of some other class\n\tisPlainObject: o => {\n\t\tif ($.type(o) !== \"object\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar proto = Object.getPrototypeOf(o);\n\t\treturn proto.constructor?.name === \"Object\";\n\t},\n\n\t// Specifiy a primitive fallback for an object\n\tprimitivify: (object, primitive) => {\n\t\tif (object) {\n\t\t\tif (primitive && typeof primitive === \"object\") {\n\t\t\t\t// Primitive is objectified, must copy its metadata to avoid losing it\n\t\t\t\tObject.assign(object, primitive);\n\t\t\t\tprimitive = Mavo.value(primitive);\n\t\t\t}\n\n\t\t\tobject.valueOf = object.toJSON = object[Symbol.toPrimitive] = () => primitive;\n\t\t}\n\n\t\treturn object;\n\t},\n\n\tobjectify: (value, properties) => {\n\t\tvar primitive = Mavo.value(value);\n\n\t\tif (typeof value !== \"object\" || value === null) {\n\t\t\tif (value === null) {\n\t\t\t\tvalue = {\n\t\t\t\t\t[Symbol.toStringTag]: \"Null\",\n\t\t\t\t\ttoJSON: () => null\n\t\t\t\t};\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar constructor = value.constructor;\n\t\t\t\tvalue = new constructor(primitive);\n\t\t\t\tvalue[Symbol.toStringTag] = constructor.name;\n\t\t\t}\n\n\t\t\t_.primitivify(value, primitive);\n\t\t}\n\n\t\treturn $.extend(value, properties);\n\t},\n\n\tvalue: value => value?.valueOf? value.valueOf() : value,\n\n\t/**\n\t * Array & set utlities\n\t */\n\n\t// If the passed value is not an array, convert to an array\n\ttoArray: arr => {\n\t\treturn arr === undefined? [] : Array.isArray(arr)? arr : [arr];\n\t},\n\n\t// Adds items from set2 into set1, turns set1 into a set if it's not\n\tunion: (set1, set2) => {\n\t\tif (set1 instanceof Set && set2) {\n\t\t\tset2.forEach(x => set1.add(x));\n\t\t\treturn set1;\n\t\t}\n\n\t\treturn new Set([...(set1 || []), ...(set2 || [])]);\n\t},\n\n\t/**\n\t * DOM element utilities\n\t */\n\n\t/**\n\t * Get the current value of a CSS property on an element\n\t */\n\tgetStyle: (element, property) => {\n\t\tif (element) {\n\t\t\tvar value = getComputedStyle(element).getPropertyValue(property);\n\n\t\t\treturn value?.trim();\n\t\t}\n\t},\n\t/**\n\t * Get/set data on an element\n\t */\n\tdata: function(element, name, value) {\n\t\tif (!element) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar data = _.elementData.get(element) || {}, ret;\n\n\t\tif (arguments.length == 2) {\n\t\t\tret = data[name];\n\t\t}\n\t\telse if (value === undefined) {\n\t\t\tdelete data[name];\n\t\t}\n\t\telse {\n\t\t\tret = data[name] = value;\n\t\t}\n\n\t\t_.elementData.set(element, data);\n\t\treturn ret;\n\t},\n\n\telementData: new WeakMap(),\n\n\t/**\n\t * Get node from path or get path of a node to an ancestor\n\t * For maximum robustness, all but the last path segment refer to elements only.\n\t * The last part of the path is a decimal: the integer part of the decimal is element index,\n\t * the decimal part is node index *after* that element and starts from 1.\n\t * If the node has no previous element sibling, the integer part of the index will be -1.\n\t */\n\telementPath: function (ancestor, element) {\n\t\tif (Array.isArray(element)) {\n\t\t\t// Get element by path\n\t\t\tvar path = element;\n\n\t\t\tvar ret = path.reduce((acc, cur) => {\n\t\t\t\treturn acc.children[cur >> 0] || acc;\n\t\t\t}, ancestor);\n\n\t\t\tvar last = path[path.length - 1];\n\n\t\t\tif (last != (last >> 0)) {\n\t\t\t\t// We are returning a non-element node\n\t\t\t\tvar offset = +(last + \"\").split(\".\")[1];\n\n\t\t\t\tif (last >> 0 < 0) {\n\t\t\t\t\tret = ret.firstChild;\n\t\t\t\t\toffset--;\n\t\t\t\t}\n\n\t\t\t\tfor (var i=0; i<offset; i++) {\n\t\t\t\t\tret = ret.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\t// Get path\n\t\t\tvar path = [];\n\n\t\t\tfor (var parent = element; parent && parent != ancestor; parent = parent.parentNode) {\n\t\t\t\tvar index = 0;\n\t\t\t\tvar countNonElementSiblings = parent === element && element.nodeType !== 1;\n\t\t\t\tvar offset = countNonElementSiblings? 1 : 0;\n\t\t\t\tvar sibling = parent;\n\n\t\t\t\twhile (sibling = sibling[`previous${countNonElementSiblings? \"\" : \"Element\"}Sibling`]) {\n\t\t\t\t\tif (countNonElementSiblings) {\n\t\t\t\t\t\toffset++;\n\n\t\t\t\t\t\tif (sibling.nodeType == 1) {\n\t\t\t\t\t\t\tcountNonElementSiblings = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\tindex = index - 1 + \".\" + offset;\n\t\t\t\t}\n\n\t\t\t\tpath.unshift(index);\n\t\t\t}\n\n\t\t\treturn parent? path : null;\n\t\t}\n\t},\n\n\t/**\n\t * Revocably add/remove elements from the DOM\n\t */\n\trevocably: {\n\t\tadd: function(element, insert) {\n\t\t\tvar comment = _.revocably.isRemoved(element);\n\n\t\t\tif (comment?.parentNode) {\n\t\t\t\tcomment.parentNode.replaceChild(element, comment);\n\t\t\t}\n\t\t\telse if (element && insert && !element.parentNode) {\n\t\t\t\t// Has not been revocably removed because it has never even been added\n\t\t\t\tif (typeof insert === \"function\") {\n\t\t\t\t\tinsert(element);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinsert.appendChild(element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn comment;\n\t\t},\n\n\t\tremove: function(element, commentText) {\n\t\t\tif (!element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar comment = _.data(element, \"commentstub\");\n\n\t\t\tif (!comment) {\n\t\t\t\tcommentText = commentText || element.id || element.className || element.nodeName;\n\t\t\t\tcomment = _.data(element, \"commentstub\", document.createComment(commentText));\n\t\t\t}\n\n\t\t\tif (element.parentNode) {\n\t\t\t\t// In DOM, remove\n\t\t\t\telement.parentNode.replaceChild(comment, element);\n\t\t\t}\n\n\t\t\treturn comment;\n\t\t},\n\n\t\tisRemoved: function(element) {\n\t\t\tif (!element || element.parentNode) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar comment = _.data(element, \"commentstub\");\n\n\t\t\tif (comment?.parentNode) {\n\t\t\t\treturn comment;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\tsetAttribute: function(element, attribute, value) {\n\t\t\tvar previousValue = _.data(element, \"attribute-\" + attribute);\n\n\t\t\tif (previousValue === undefined) {\n\t\t\t\t// Only set this when there's no old value stored, otherwise\n\t\t\t\t// if called multiple times, it could result in losing the original value\n\t\t\t\t_.data(element, \"attribute-\" + attribute, element.getAttribute(attribute));\n\t\t\t}\n\n\t\t\telement.setAttribute(attribute, value);\n\t\t},\n\n\t\trestoreAttribute: function(element, attribute) {\n\t\t\tvar previousValue = _.data(element, \"attribute-\" + attribute);\n\n\t\t\tif (previousValue !== undefined) {\n\t\t\t\t$.toggleAttribute(element, attribute, previousValue);\n\t\t\t\t_.data(element, \"attribute-\" + attribute, undefined);\n\t\t\t}\n\t\t}\n\t},\n\n\tinView: {\n\t\tis: element => {\n\t\t\tvar r = element.getBoundingClientRect();\n\n\t\t\treturn (0 <= r.bottom && r.bottom <= innerHeight || 0 <= r.top && r.top <= innerHeight) // vertical\n\t\t\t       && (0 <= r.right && r.right <= innerWidth || 0 <= r.left && r.left <= innerWidth); // horizontal\n\t\t},\n\n\t\twhen: (element, rootMargin = `${innerHeight / 2}px ${innerWidth/2}px`) => {\n\t\t\tvar observer = _.inView.observer = _.inView.observer || new IntersectionObserver(function(entries, observer) {\n\t\t\t\tentries.forEach(entry => {\n\t\t\t\t\tif (entry.intersectionRatio > 0) {\n\t\t\t\t\t\tobserver.unobserve(entry.target);\n\t\t\t\t\t\t$.fire(entry.target, \"mv-inview\", {entry});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, {rootMargin});\n\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tif (_.inView.is(element)) {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\n\t\t\t\tobserver.observe(element);\n\n\t\t\t\tvar callback = evt => {\n\t\t\t\t\telement.removeEventListener(\"mv-inview\", callback);\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\n\t\t\t\telement.addEventListener(\"mv-inview\", callback);\n\t\t\t});\n\t\t}\n\t},\n\n\tscrollIntoViewIfNeeded: element => {\n\t\tif (element && !Mavo.inView.is(element)) {\n\t\t\telement.scrollIntoView({behavior: \"smooth\"});\n\t\t}\n\t},\n\n\t/**\n\t * Set attribute only if it doesnt exist\n\t */\n\tsetAttributeShy: function(element, attribute, value) {\n\t\tif (!element.hasAttribute(attribute)) {\n\t\t\telement.setAttribute(attribute, value);\n\t\t}\n\t},\n\n\t/**\n\t * Get the value of an attribute, with fallback attributes in priority order.\n\t */\n\tgetAttribute: function(element, ...attributes) {\n\t\tfor (let i=0, attribute; attribute = attributes[i]; i++) {\n\t\t\tlet value = element.getAttribute(attribute);\n\n\t\t\tif (value) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tgetClosestAttribute: function(element, attribute) {\n\t\treturn element.closest(`[${attribute}]`)?.getAttribute(attribute) ?? null;\n\t},\n\n\tmoveAttribute (name, from, to, o = {}) {\n\t\tlet value = from.getAttribute(name);\n\n\t\tif (value === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet newName = o.rename || name;\n\n\t\tto.setAttribute(newName, value);\n\t\tfrom.removeAttribute(name);\n\t},\n\n\t/**\n\t * Get the element identified by the URL hash\n\t */\n\tgetTarget: function() {\n\t\tvar id = location.hash.substr(1);\n\t\treturn document.getElementById(id);\n\t},\n\n\tXPath: function(query, context = document) {\n\t\tvar doc = context.ownerDocument || context;\n\t\tvar ret = [], node;\n\n\t\tif (doc.evaluate) {\n\t\t\tvar result = doc.evaluate(query, context, null, XPathResult.ANY_TYPE, null);\n\n\t\t\twhile (node = result.iterateNext()) {\n\t\t\t\tret.push(node);\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// Returns attribute nodes that start with `str` on or inside `context`\n\t// Use getAttributes() instead if you are only looking at the element itself and not its subtree\n\t// Use attr.ownerElement to get element\n\tattributeStartsWith: function(str, context = document.documentElement) {\n\t\treturn _.XPath(`.//@*[starts-with(name(), \"${str}\")]`, context);\n\t},\n\n\t// Returns attribute names that match a regex\n\tgetAttributes: function(element, regex) {\n\t\treturn element.getAttributeNames().filter(name => regex.test(name));\n\t},\n\n\t/**\n\t *  Set/get a property or an attribute?\n\t * @return {Boolean} true to use a property, false to use the attribute\n\t */\n\tusePropertyInsteadOfAttribute: function (element, attribute) {\n\t\tif ([\"href\", \"src\"].indexOf(attribute) > -1) {\n\t\t\t// URL properties resolve \"\" as location.href, fucking up emptiness checks\n\t\t\treturn false;\n\t\t}\n\n\t\tif (attribute.startsWith(\"on\")){\n\t\t\t// Event listener attributes should be set as attributes,\n\t\t\t// the properties expect functions and break with strings\n\t\t\treturn false;\n\t\t}\n\n\t\tif (element.namespaceURI == \"http://www.w3.org/2000/svg\") {\n\t\t\t// SVG has a fucked up DOM, do not use these properties\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Object utilities\n\t */\n\n\t/**\n\t * Check if property exists in object. Like the in operator but more robust and does not throw.\n\t * Why not just in? E.g. \"foo\".length is 3 but \"length\" in \"foo\" throws\n\t */\n\tin: function(property, obj) {\n\t\tif (obj) {\n\t\t\treturn (typeof obj === \"object\" && property in obj) || obj[property] !== undefined;\n\t\t}\n\t},\n\n\t/**\n\t * Get real property name from case insensitive property\n\t */\n\tgetCanonicalProperty: function(obj, property) {\n\t\tif (obj && (property || property === 0)) {\n\t\t\t// Property in object?\n\t\t\tif (_.in(property, obj)) {\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tif (property.toLowerCase) {\n\t\t\t\t// Lowercase property in object?\n\t\t\t\tvar propertyL = property.toLowerCase();\n\n\t\t\t\tif (_.in(propertyL, obj)) {\n\t\t\t\t\treturn propertyL;\n\t\t\t\t}\n\n\t\t\t\t// Any case property in object?\n\t\t\t\tvar properties = Object.keys(obj);\n\t\t\t\tvar i = properties.map(p => p.toLowerCase()).indexOf(propertyL);\n\n\t\t\t\tif (i > -1) {\n\t\t\t\t\treturn properties[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsubset: function(obj, path, value) {\n\t\tif (arguments.length == 3) {\n\t\t\t// Put\n\t\t\tif (path.length) {\n\t\t\t\tvar last = path[path.length - 1];\n\t\t\t\tvar parent = $.value(obj, ...path.slice(0, -1));\n\n\t\t\t\tif (Array.isArray(parent) && Array.isArray(value)) {\n\t\t\t\t\t// Merge arrays instead of adding array inside array\n\t\t\t\t\tparent.splice(last, 1, ...value);\n\t\t\t\t}\n\t\t\t\telse if (parent) {\n\t\t\t\t\tparent[path[path.length - 1]] = value;\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\telse if (typeof obj == \"object\" && path?.length) { // Get\n\t\t\treturn path.reduce((obj, property, i) => {\n\t\t\t\tlet ret;\n\t\t\t\tlet idQuery = property?.startsWith?.(\"id=\")? property.substring(3) : null;\n\n\t\t\t\tif (idQuery !== null) {\n\t\t\t\t\tlet index = obj.findIndex(o => Mavo.Functions.get(o, \"id\") == idQuery);\n\t\t\t\t\tret = index > -1? obj[index] : {id: idQuery}; // if not found, return dummy\n\t\t\t\t\tpath[i] = index > -1? index : obj.length;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = Mavo.Functions.get(obj, property);\n\t\t\t\t\tpath[i] = property;\n\t\t\t\t}\n\n\t\t\t\treturn ret;\n\t\t\t}, obj);\n\t\t}\n\t\telse {\n\t\t\treturn obj;\n\t\t}\n\t},\n\n\tclone: function(o) {\n\t\tif (!o || typeof o !== \"object\") {\n\t\t\treturn o;\n\t\t}\n\n\t\treturn JSON.parse(_.safeToJSON(o));\n\t},\n\n\t// Will not work for symbols\n\tshallowClone: function(o) {\n\t\tif (!o || typeof o !== \"object\") {\n\t\t\treturn o;\n\t\t}\n\n\t\tif (Array.isArray(o)) {\n\t\t\treturn [...o];\n\t\t}\n\n\t\treturn $.extend({}, o);\n\t},\n\n\t// Credit: https://remysharp.com/2010/07/21/throttling-function-calls\n\tdebounce: function (fn, delay) {\n\t\tif (!delay) {\n\t\t\t// No throttling\n\t\t\treturn fn;\n\t\t}\n\n\t\tvar timer = null, code;\n\n\t\treturn function () {\n\t\t\tvar context = this, args = arguments;\n\n\t\t\tcode = function () {\n\t\t\t\tfn.apply(context, args);\n\t\t\t\tremoveEventListener(\"beforeunload\", code);\n\t\t\t};\n\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = setTimeout(code, delay);\n\t\t\taddEventListener(\"beforeunload\", code);\n\t\t};\n\t},\n\n\tescapeRegExp: s => s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"),\n\n\tobserveResize: function(element, callbackOrObserver) {\n\t\tif (!self.ResizeObserver) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar previousRect = null;\n\t\tvar ro = callbackOrObserver instanceof ResizeObserver? callbackOrObserver : new ResizeObserver(entries => {\n\t\t\tvar contentRect = entries[entries.length - 1].contentRect;\n\n\t\t\tif (previousRect\n\t\t\t\t&& previousRect.width == contentRect.width\n\t\t\t\t&& previousRect.height == contentRect.height) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallbackOrObserver(entries);\n\n\t\t\tpreviousRect = contentRect;\n\t\t});\n\n\t\tro.observe(element);\n\n\t\treturn ro;\n\t},\n\n\tObserver: class Observer {\n\t\tconstructor (element, attribute, callback, o = {}) {\n\t\t\tif (callback instanceof MutationObserver) {\n\t\t\t\tthis.observer = callback;\n\t\t\t}\n\n\t\t\tthis.observer = this.observer || new MutationObserver(callback);\n\t\t\tthis.callback = callback;\n\t\t\tthis.update(element, attribute, o);\n\n\t\t\tthis.run();\n\t\t}\n\n\t\tupdate (element, attribute, options) {\n\t\t\tthis.element = element;\n\t\t\tthis.attribute = attribute;\n\t\t\tthis.options = $.extend({}, options);\n\n\t\t\t// We use the user-provided options object verbatim if it exists and\n\t\t\t// is valid, i.e. has at least one of the required properties\n\t\t\tif (options === undefined || !options.attributes && !options.childList && !options.characterData) {\n\t\t\t\tif (this.attribute) {\n\t\t\t\t\tObject.assign(this.options, {\n\t\t\t\t\t\tattributes: true,\n\t\t\t\t\t\tattributeFilter: this.attribute == \"all\"? undefined : Mavo.toArray(this.attribute),\n\t\t\t\t\t\tattributeOldValue: !!options.oldValue\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!this.attribute || this.attribute == \"all\") {\n\t\t\t\t\tObject.assign(this.options, {\n\t\t\t\t\t\tcharacterData: true,\n\t\t\t\t\t\tchildList: true,\n\t\t\t\t\t\tsubtree: true,\n\t\t\t\t\t\tcharacterDataOldValue: !!options.oldValue\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.observer?.running) {\n\t\t\t\tthis.stop();\n\t\t\t\tthis.run();\n\t\t\t}\n\t\t}\n\n\t\tflush () {\n\t\t\tlet records = this.observer?.takeRecords();\n\n\t\t\tif (records) {\n\t\t\t\tthis.callback(records);\n\t\t\t}\n\t\t}\n\n\t\tstop () {\n\t\t\tthis.observer?.disconnect();\n\t\t\tthis.running = false;\n\t\t\treturn this;\n\t\t}\n\n\t\trun () {\n\t\t\tif (this.observer) {\n\t\t\t\tthis.observer.observe(this.element, this.options);\n\t\t\t\tthis.running = true;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Like stop(), but saves running state and then resumes it\n\t\t */\n\t\tpause () {\n\t\t\tthis.runOnResume = this.running;\n\t\t\tthis.stop();\n\t\t}\n\n\t\t/**\n\t\t * Like run(), but runs only if observer was running before pause().\n\t\t */\n\t\tresume () {\n\t\t\tif (this.runOnResume !== false) {\n\t\t\t\tthis.run();\n\t\t\t}\n\n\t\t\tdelete this.runOnResume;\n\t\t}\n\n\t\tdestroy () {\n\t\t\tthis.stop();\n\t\t\tthis.observer = this.element = null;\n\t\t}\n\t},\n\n\t/**\n\t * Run & Return a function\n\t */\n\trr: function(f) {\n\t\tf();\n\t\treturn f;\n\t},\n\n\t// Get out of bounds array index to wrap around\n\twrap: (index, length) => index < 0? length - 1 : index >= length? 0 : index,\n\n\t/**\n\t * Parses a simple CSS-like text format for declaring key-value options:\n\t * Pairs are comma or semicolon-separated, key and value are colon separated.\n\t * Escapes are supported, via backslash. Useful for attributes.\n\t */\n\toptions: (str, {map} = {}) => {\n\t\tvar ret = map? new Map() : {};\n\n\t\tstr.trim().match(/(?:\\\\[,;]|[^,;])+/g)?.forEach(option => {\n\t\t\tif (option) {\n\t\t\t\toption = option.trim().replace(/\\\\([,;])/g, \"$1\");\n\t\t\t\tvar pair = option.match(/^\\s*((?:\\\\:|[^:])*?)\\s*:\\s*(.+)$/);\n\t\t\t\tlet key, value;\n\n\t\t\t\tif (pair) {\n\t\t\t\t\tkey = pair[1].replace(/\\\\:/g, \":\");\n\t\t\t\t\tvalue = pair[2] === \"false\" ? false : pair[2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If no value, it's boolean\n\t\t\t\t\tkey = option;\n\t\t\t\t\tvalue = true;\n\t\t\t\t}\n\n\t\t\t\tif (map) {\n\t\t\t\t\tret.set(key, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn ret;\n\t},\n\n\t/**\n\t * Map that can hold multiple values per key\n\t */\n\tBucketMap: class BucketMap {\n\t\tconstructor({arrays = false} = {}) {\n\t\t\tthis.map = new Map();\n\t\t\tthis[Symbol.iterator] = this.map[Symbol.iterator];\n\t\t\tthis.arrays = arrays;\n\t\t}\n\n\t\tset(key, value) {\n\t\t\tif (this.arrays) {\n\t\t\t\tvar values = this.map.get(key) || [];\n\t\t\t\tvalues.push(value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar values = this.map.get(key) || new Set();\n\t\t\t\tvalues.add(value);\n\t\t\t}\n\n\t\t\tthis.map.set(key, values);\n\t\t}\n\n\t\tdelete(key, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tvar values = this.map.get(key);\n\n\t\t\t\tif (values) {\n\t\t\t\t\tif (this.arrays) {\n\t\t\t\t\t\tlet index = values.indexOf(value);\n\n\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\tvalues.splice(index, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalues.delete(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.map.delete(key);\n\t\t\t}\n\t\t}\n\n\t\tforEach(...args) {\n\t\t\treturn this.map.forEach(...args);\n\t\t}\n\t}\n});\n\n/**\n * Collection of fake \"observers\" implemented over one large MutationObserver\n */\n_.Observers = class Observers extends Map {\n\tconstructor({observer, callback} = {}) {\n\t\tsuper();\n\n\t\tlet self = _.Observers;\n\t\tthis.callback = callback || self.callback;\n\t\tthis.observer = observer || (self.observer = self.observer || new MutationObserver(this.callback));\n\t}\n\n\tapplyRecord (r) {\n\t\tfor (let [o, callback] of this.entries()) {\n\t\t\tif (_.Observers.matchesRecord(o, r)) {\n\n\t\t\t\t// If we are here, the observer matches\n\t\t\t\tlet node = Mavo.Node.get(r.target, true);\n\n\t\t\t\tcallback.call(this, {\n\t\t\t\t\tnode,\n\t\t\t\t\telement: r.target,\n\t\t\t\t\ttype: r.type,\n\t\t\t\t\tattribute: r.attributeName,\n\t\t\t\t\trecord: r\n\t\t\t\t});\n\n\t\t\t\tif (o.once) {\n\t\t\t\t\tthis.unobserve(o, callback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic matchesRecord (o, r) {\n\t\tif (o.active === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet element = r.target;\n\n\t\tif (o.selector && !element.matches?.(o.selector)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (o.attribute) {\n\t\t\t// We are monitoring attribute changes only\n\t\t\tif (r.type !== \"attributes\") {\n\t\t\t\t// Not an attribute change\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (o.attribute !== true && o.attribute !== r.attributeName && !o.attribute.includes?.(r.attributeName)) {\n\t\t\t\t// We are monitoring specific attribute(s), and a different one changed\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (r.type === \"attributes\" && o.attribute === false) {\n\t\t\t// We explicitly opted out monitoring attributes, and an attribute has changed\n\t\t\treturn false;\n\t\t}\n\n\t\tif (o.element) {\n\t\t\tif (o.deep === false) {\n\t\t\t\treturn element === o.element;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn o.element.contains(element);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tflush () {\n\t\tlet records = this.observer.takeRecords();\n\n\t\tif (records) {\n\t\t\tthis.callback(records);\n\t\t}\n\t}\n\n\tobserve (o = {}, callback) {\n\t\tthis.set(o, callback);\n\t\treturn callback;\n\t}\n\n\tunobserve (options, callback) {\n\t\tlet matches = this.find(options, callback);\n\n\t\tfor (let [o, c] of matches.entries()) {\n\t\t\tthis.delete(o);\n\t\t}\n\t}\n\n\tpause (options) {\n\t\tlet matches = this.find(options);\n\n\t\tfor (let [o, c] of matches.entries()) {\n\t\t\t// Decativate and store active state\n\t\t\to._active = o.active !== false && o._active !== false;\n\t\t\to.active = false;\n\t\t}\n\n\t\tthis.flush();\n\n\t\treturn matches;\n\t}\n\n\tresume (matches) {\n\t\tif (!(matches instanceof _.Observers)) {\n\t\t\tmatches = this.find(matches);\n\t\t}\n\n\t\tthis.flush();\n\n\t\tfor (let [o, c] of matches.entries()) {\n\t\t\t// Restore active state\n\t\t\to.active = o.active || o._active;\n\t\t\tdelete o._active;\n\t\t}\n\t}\n\n\tfind (options = {}, callback) {\n\t\tlet keys = Object.keys(options);\n\t\tlet ret = new Mavo.Observers();\n\n\t\tfor (let [o, c] of this.entries()) {\n\t\t\tif (callback && callback !== c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (keys.every(k => o[k] === options[k])) {\n\t\t\t\tret.set(o, c);\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\n// Default callback\n_.Observers.callback = records => {\n\tif (this.size === 0) {\n\t\treturn;\n\t}\n\n\tfor (let r of records) {\n\t\t_.observers.applyRecord(r);\n\t}\n};\n\n// Bliss plugins\n\n// Provide shortcuts to long property chains\n$.proxy = $.classProps.proxy = $.overload(function(obj, property, proxy) {\n\tObject.defineProperty(obj, property, {\n\t\tget: function() {\n\t\t\treturn this[proxy][property];\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis[proxy][property] = value;\n\t\t},\n\t\tconfigurable: true,\n\t\tenumerable: true\n\t});\n\n\treturn obj;\n});\n\n// :target-within shim\nfunction updateTargetWithin() {\n\tvar element = _.getTarget();\n\tconst cl = \"mv-target-within\";\n\n\t$$(\".\" + cl).forEach(el => el.classList.remove(cl));\n\n\twhile (element?.classList) {\n\t\telement.classList.add(cl);\n\t\telement = element.parentNode;\n\t}\n};\n\ndocument.addEventListener(\"mv-load\", updateTargetWithin);\naddEventListener(\"hashchange\", updateTargetWithin);\nMavo.observe({attribute: \"id\"}, updateTargetWithin);\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.Locale = $.Class({\n\tconstructor: function(lang, phrases) {\n\t\tthis.lang = lang;\n\t\tthis.phrases = {};\n\t\tthis.extend(phrases);\n\t},\n\n\tget fallback() {\n\t\t// TODO should we fallback to other dialects? I.e. should en-US fallback to en-GB if en didn't exist?\n\t\tif (_.all[this.baseLang]) {\n\t\t\treturn _.all[this.baseLang];\n\t\t}\n\n\t\tif (this !== _.default) {\n\t\t\treturn _.default;\n\t\t}\n\t},\n\n\textend: function(phrases) {\n\t\t$.extend(this.phrases, phrases);\n\t},\n\n\tphrase: function(id, vars) {\n\t\tvar key = id.toLowerCase();\n\t\tvar phrase = this.phrases[key];\n\n\t\tif (phrase === undefined && this.fallback) {\n\t\t\tphrase = this.fallback.phrase(key);\n\t\t}\n\n\t\tif (phrase === undefined) {\n\t\t\t// Everything failed, use id\n\t\t\tphrase = key.replace(/\\b-\\b/g, \" \");\n\t\t}\n\t\telse if (vars) {\n\t\t\tvar keys = phrase.match(/\\{\\w+(?=\\})/g)?.map(v => v.slice(1)) ?? [];\n\t\t\tMavo.Functions.unique(keys).forEach(name => {\n\t\t\t\tif (name in vars) {\n\t\t\t\t\tphrase = phrase.replace(RegExp(`{${name}}`, \"gi\"), vars[name]);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn phrase;\n\t},\n\n\tlive: {\n\t\tlang: function(lang) {\n\t\t\tthis.baseLang = _.getBaseLang(lang);\n\n\t\t\tif (lang == this.baseLang) {\n\t\t\t\tthis.baseLang = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tstatic: {\n\t\tall: {},\n\n\t\t/**\n\t\t * Register new locale or extend existing locale\n\t\t */\n\t\tregister: function(lang, phrases) {\n\t\t\tif (_.all[lang]) {\n\t\t\t\t_.all[lang].extend(phrases);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_.all[lang] = new _(lang, phrases);\n\t\t\t}\n\t\t},\n\n\t\t// Get locale for a given language, use its base as fallback\n\t\tmatch: function(lang = \"\") {\n\t\t\treturn _.all[lang] || _.all[_.getBaseLang(lang)];\n\t\t},\n\n\t\t// Get locale for a given language, use its base as fallback, and the default locale if nothing exists\n\t\tget: function(lang) {\n\t\t\treturn _.match(lang) || _.default;\n\t\t},\n\n\t\tgetBaseLang: function(lang) {\n\t\t\treturn lang.split(\"-\")[0];\n\t\t},\n\n\t\tlazy: {\n\t\t\tdefault: () => {\n\t\t\t\treturn _.match(Mavo.locale) || _.all.en;\n\t\t\t}\n\t\t}\n\t}\n});\n\n/**\n * Use phrase\n */\nMavo.prototype._ = function(id, vars) {\n\treturn this.locale && id? this.locale.phrase(id, vars) : id;\n};\n\nMavo.ready.then(() => {\n\t$$(\"datalist.mv-phrases[lang]\").forEach(datalist => {\n\t\tvar phrases = $$(\"option\", datalist).reduce((o, option) => {\n\t\t\to[option.value] = option.textContent.trim();\n\t\t\treturn o;\n\t\t}, {});\n\n\t\tMavo.Locale.register(datalist.lang, phrases);\n\t});\n});\n\n})(Bliss, Bliss.$);\n","Mavo.Locale.register(\"en\", {\n\t\"second\": \"second\",\n\t\"seconds\": \"seconds\",\n\t\"minute\": \"minute\",\n\t\"minutes\": \"minutes\",\n\t\"hour\": \"hour\",\n\t\"hours\": \"hours\",\n\t\"day\": \"day\",\n\t\"days\": \"days\",\n\t\"week\": \"week\",\n\t\"weeks\": \"weeks\",\n\t\"month\": \"month\",\n\t\"months\": \"months\",\n\t\"year\": \"year\",\n\t\"years\": \"years\",\n\t\"edit\": \"Edit\",\n\t\"editing\": \"Editing\",\n\t\"save\": \"Save\",\n\t\"import\": \"Import\",\n\t\"export\": \"Export\",\n\t\"logout\": \"Logout\",\n\t\"login\": \"Login\",\n\t\"loading\": \"Loading\",\n\t\"uploading\": \"Uploading\",\n\t\"saving\": \"Saving\",\n\t\"dismiss\": \"Dismiss\",\n\t\"logged-in-as\": \"Logged in to {id} as \",\n\t\"login-to\": \"Login to {id}\",\n\t\"error-uploading\": \"Error uploading file\",\n\t\"cannot-load-uploaded-file\": \"Cannot load uploaded file\",\n\t\"filename\": \"Filename?\",\n\t\"problem-saving\": \"Problem saving data\",\n\t\"problem-loading\": \"Problem loading data\",\n\t\"cannot-parse\": \"Cant understand this file\",\n\t\"http-error\": \"HTTP error {status}: {statusText}\",\n\t\"cant-connect\": \"Cant connect to the Internet\",\n\t\"add-item\": \"Add {name}\",\n\t\"add-item-before\": \"Add new {name} before\",\n\t\"add-item-after\": \"Add new {name} after\",\n\t\"drag-to-reorder\": \"Drag to reorder {name}\",\n\t\"delete-item\": \"Delete this {name}\",\n\t\"item-deleted\": \"{name} deleted\",\n\t\"n-items\": \"{n} {name} items\",\n\t\"undo\": \"Undo\",\n\t\"gh-updated-file\": \"Updated {name}\",\n\t\"gh-login-fork-options\": \"You have your own copy of this page, would you like to use it?\",\n\t\"gh-use-my-fork\": \"Yes, show me my data.\",\n\t\"remote-data-conflict\": \"There is new data but you have unsaved changes. Loading it will overwrite your changes. Load new data?\"\n});\n","(function ($, $$) {\n\nMavo.attributes.push(\"mv-plugins\");\n\nlet _ = Mavo.Plugins = {\n\tloaded: {},\n\n\tasync load () {\n\t\t_.plugins = new Set();\n\n\t\tlet versions = {};\n\t\t$$(\"[mv-plugins]\").forEach(element => {\n\t\t\telement\n\t\t\t\t.getAttribute(\"mv-plugins\").trim().split(/\\s+/)\n\t\t\t\t.forEach(plugin => {\n\t\t\t\t\tlet [id, version] = plugin.split(\"@\");\n\n\t\t\t\t\t_.plugins.add(id);\n\n\t\t\t\t\t// If an author requested several versions of the same plugin (with the same id),\n\t\t\t\t\t// the last specified version wins\n\t\t\t\t\tversions[id] = version;\n\t\t\t\t});\n\t\t});\n\n\t\tif (!_.plugins.size) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fetch plugin index\n\t\tlet response = await fetch(_.url + \"/plugins.json\");\n\t\tlet json = await response.json();\n\t\tlet plugin = json.plugin;\n\n\t\t// Fetch plugins\n\t\treturn Mavo.thenAll(plugin\n\t\t\t.filter(plugin => _.plugins.has(plugin.id))\n\t\t\t.map(async (plugin) => {\n\t\t\t\tif (_.loaded[plugin.id]) {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\n\t\t\t\t// Load plugin\n\t\t\t\tlet filename = `mavo-${plugin.id}.js`;\n\t\t\t\tlet url;\n\n\t\t\t\tif (plugin.repo) {\n\t\t\t\t\t// Plugin hosted in a separate repo\n\t\t\t\t\tlet version = versions[plugin.id] || \"latest\";\n\t\t\t\t\turl = `https://cdn.jsdelivr.net/gh/${plugin.repo}@${version}/${filename}`;\n\n\t\t\t\t\t// Try to load the requested version of a plugin\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn await $.include(_.loaded[plugin.id], url);\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// If there is no such version, fallback to the latest one (or the latest commit)\n\t\t\t\t\t\turl = `https://cdn.jsdelivr.net/gh/${plugin.repo}/${filename}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Plugin hosted in the mavo-plugins repo\n\t\t\t\t\turl = `${_.url}/${plugin.id}/${filename}`;\n\t\t\t\t}\n\n\t\t\t\treturn $.include(_.loaded[plugin.id], url);\n\t\t\t}));\n\t},\n\n\tregister: function(name, o = {}) {\n\t\tif (_.loaded[name]) {\n\t\t\t// Do not register same plugin twice\n\t\t\treturn;\n\t\t}\n\n\t\tMavo.hooks.add(o.hooks);\n\n\t\tfor (let Class in o.extend) {\n\t\t\tlet existing = Class == \"Mavo\"? Mavo : Mavo[Class];\n\n\t\t\tif ($.type(existing) === \"function\") {\n\t\t\t\t$.Class(existing, o.extend[Class]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$.extend(existing, o.extend[Class]);\n\t\t\t}\n\t\t}\n\n\t\tlet ready = [];\n\n\t\tif (o.ready) {\n\t\t\tready.push(o.ready);\n\t\t}\n\n\t\tif (o.dependencies) {\n\t\t\tlet base = document.currentScript? document.currentScript.src : location;\n\t\t\tlet dependencies = o.dependencies.map(url => Mavo.load(url, base));\n\t\t\tready.push(...dependencies);\n\t\t}\n\n\t\tif (ready.length) {\n\t\t\tMavo.dependencies.push(...ready);\n\t\t}\n\n\t\t_.loaded[name] = o;\n\n\t\tif (o.init) {\n\t\t\tPromise.all(ready).then(() => o.init());\n\t\t}\n\t},\n\n\turl: \"https://plugins.mavo.io\"\n};\n\n})(Bliss, Bliss.$);\n","(function ($, $$) {\n\nMavo.attributes.push(\"mv-bar\");\n\nlet _ = Mavo.UI.Bar = class Bar {\n\tconstructor (mavo) {\n\t\tthis.mavo = mavo;\n\n\t\tthis.element = $(\".mv-bar\", this.mavo.element);\n\t\tthis.template = this.mavo.element.getAttribute(\"mv-bar\") || \"\";\n\n\t\tMavo.observers.pause();\n\n\t\tif (this.element) {\n\t\t\tthis.custom = true;\n\t\t\tthis.template += \" \" + (this.element.getAttribute(\"mv-bar\") || \"\");\n\t\t\tthis.template = this.template.trim();\n\n\t\t\tfor (let id in _.controls) {\n\t\t\t\tthis[id] = $(`.mv-${id}`, this.element);\n\n\t\t\t\tif (this[id]) {\n\t\t\t\t\tthis.template = this.template || \"with\";\n\t\t\t\t\tthis.template += ` ${id}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.element = $.create({\n\t\t\t\tclassName: \"mv-bar mv-ui\",\n\t\t\t\tstart: this.mavo.element.tagName === \"HTML\"? document.body : this.mavo.element,\n\t\t\t\tinnerHTML: \"<button>&nbsp;</button>\"\n\t\t\t});\n\t\t}\n\n\t\tif (this.element.classList.contains(\"mv-compact\")) {\n\t\t\tthis.noResize = true;\n\t\t}\n\n\t\tthis.controls = _.getControls(this.template);\n\n\t\tif (this.controls.length) {\n\t\t\t// Measure height of 1 row\n\t\t\tthis.targetHeight = this.element.offsetHeight;\n\t\t}\n\n\t\tif (!this.custom) {\n\t\t\tthis.element.innerHTML = \"\";\n\t\t}\n\n\t\tfor (let id of this.controls) {\n\t\t\tlet o = _.controls[id];\n\n\t\t\tif (this[id]) {\n\t\t\t\t// Custom control, remove to not mess up order\n\t\t\t\tthis[id].remove();\n\t\t\t}\n\n\t\t\tif (o.create) {\n\t\t\t\tthis[id] = o.create.call(this.mavo, this[id]);\n\t\t\t}\n\t\t\telse if (!this[id]) {\n\t\t\t\tthis[id] = $.create(\"button\", {\n\t\t\t\t\ttype: \"button\",\n\t\t\t\t\tclassName: `mv-${id}`,\n\t\t\t\t\ttextContent: this.mavo._(id)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// We initially add all of them to retain order,\n\t\t\t// then we remove revocably when/if needed\n\t\t\tthis.add(id);\n\n\t\t\tif (o.permission) {\n\t\t\t\tthis.permissions.can(o.permission, () => {\n\t\t\t\t\tthis.toggle(id, !o.condition || o.condition.call(this.mavo));\n\t\t\t\t}, () => {\n\t\t\t\t\tthis.remove(id);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (o.condition && !o.condition.call(this.mavo)) {\n\t\t\t\tthis.remove(id);\n\t\t\t}\n\n\t\t\tfor (let events in o.events) {\n\t\t\t\t$.bind(this[id], events, o.events[events].bind(this.mavo));\n\t\t\t}\n\t\t}\n\n\t\tfor (let id in _.controls) {\n\t\t\tlet o = _.controls[id];\n\n\t\t\tif (o.action) {\n\t\t\t\t$.delegate(this.mavo.element, \"click\", \".mv-\" + id, evt => {\n\t\t\t\t\tif (!o.permission || this.permissions.is(o.permission)) {\n\t\t\t\t\t\to.action.call(this.mavo);\n\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (this.controls.length && !this.noResize) {\n\t\t\tthis.resize();\n\n\t\t\tif (self.ResizeObserver) {\n\t\t\t\tthis.resizeObserver = Mavo.observeResize(this.element, entries => {\n\t\t\t\t\tthis.resize();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tMavo.observers.resume();\n\t}\n\n\tresize () {\n\t\tif (!this.targetHeight) {\n\t\t\t// We don't have a correct measurement for target height, abort\n\t\t\tthis.targetHeight = this.element.offsetHeight;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resizeObserver?.disconnect();\n\n\t\tthis.element.classList.remove(\"mv-compact\", \"mv-tiny\");\n\n\t\t// Remove pointless tooltips\n\t\t$$(\"button, .mv-button\", this.element).forEach(button => {\n\t\t\tif (button.title === button.textContent) {\n\t\t\t\tbutton.title = \"\";\n\t\t\t}\n\t\t});\n\n\t\t// Exceeded single row?\n\t\tif (this.element.offsetHeight > this.targetHeight * 1.6) {\n\t\t\tthis.element.classList.add(\"mv-compact\");\n\n\t\t\tif (this.element.offsetHeight > this.targetHeight * 1.2) {\n\t\t\t\t// Still too tall\n\t\t\t\tthis.element.classList.add(\"mv-tiny\");\n\n\t\t\t\t// Add tooltips, since only icons will be visible\n\t\t\t\t$$(\"button, .mv-button\", this.element).forEach(button => {\n\t\t\t\t\tif (!button.title) {\n\t\t\t\t\t\tbutton.title = button.textContent;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.resizeObserver?.observe(this.element);\n\t}\n\n\tadd (id) {\n\t\tlet o = _.controls[id];\n\n\t\tif (o.prepare) {\n\t\t\to.prepare.call(this.mavo);\n\t\t}\n\n\t\tMavo.revocably.add(this[id], this.element);\n\n\t\tif (!this.resizeObserver && !this.noResize) {\n\t\t\trequestAnimationFrame(() => this.resize());\n\t\t}\n\t}\n\n\tremove (id) {\n\t\tlet o =_.controls[id];\n\n\t\tMavo.revocably.remove(this[id], \"mv-\" + id);\n\n\t\tif (o.cleanup) {\n\t\t\to.cleanup.call(this.mavo);\n\t\t}\n\n\t\tif (!this.resizeObserver && !this.noResize) {\n\t\t\trequestAnimationFrame(() => this.resize());\n\t\t}\n\t}\n\n\ttoggle (id, add) {\n\t\treturn this[add? \"add\" : \"remove\"](id);\n\t}\n\n\tget permissions () {\n\t\treturn this.mavo.permissions;\n\t}\n\n\tdestroy () {\n\t\tthis.resizeObserver.disconnect();\n\t\tthis.resizeObserver = null;\n\t}\n\n\tstatic getControls (template, controls = _.controls) {\n\t\ttemplate = template?.trim();\n\n\t\tif (template === \"none\") {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet all = Object.keys(controls);\n\n\t\tif (!template) {\n\t\t\t// No template, return default set\n\t\t\treturn all.filter(id => !controls[id].optional);\n\t\t}\n\n\t\tlet relative = /^with\\s|\\bno-\\w+\\b/.test(template);\n\t\ttemplate = template.replace(/\\b^with\\s+/g, \"\");\n\t\tlet ids = template.split(/\\s+/);\n\n\t\t// Convert both into sets\n\t\tall = new Set(all);\n\t\tids = new Set(ids);\n\n\t\tfor (let id of ids) {\n\t\t\tif (id.startsWith(\"no-\")) {\n\t\t\t\t// Drop negative references\n\t\t\t\tids.delete(id);\n\n\t\t\t\tid = id.slice(3); // Drop \"no-\"\n\n\t\t\t\tif (!ids.has(id)) {\n\t\t\t\t\t// If there's no positive reference *as well*, drop it\n\t\t\t\t\t// Note that this means that in `foo no-foo`, `no-foo` is ignored\n\t\t\t\t\tall.delete(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!all.has(id)) {\n\t\t\t\t// Drop nonexistent ids\n\t\t\t\tids.delete(id);\n\t\t\t}\n\t\t}\n\n\t\tif (!relative) {\n\t\t\treturn [...ids];\n\t\t}\n\n\t\t// Drop optional controls not specified from `all`\n\t\tfor (let id of all) {\n\t\t\tlet o = controls[id];\n\n\t\t\tif (o.optional && !ids.has(id)) {\n\t\t\t\tall.delete(id);\n\t\t\t}\n\t\t}\n\n\t\tall = [...all];\n\n\t\t// At this point all has all the buttons we want in the default order and ids has a subset, in the specified order\n\t\t// How do we combine them and preserve as much of the default order as we can while still following the specified order?\n\n\t\tif (ids.size === 0) {\n\t\t\treturn all;\n\t\t}\n\n\t\t// First, we find which part of `all` needs to be reordered\n\t\tlet indices = [...ids].map(id => all.indexOf(id));\n\t\tlet start = Math.min(...indices);\n\t\tlet end = Math.max(...indices);\n\t\tlet before = all.slice(0, start);\n\t\tlet after = all.slice(end + 1);\n\t\tlet slice = all.slice(start, end + 1).filter(id => !ids.has(id));\n\n\t\treturn [...before, ...slice, ...ids, ...after];\n\t}\n}\n\n_.controls = {\n\tstatus: {\n\t\tcreate: function(custom) {\n\t\t\treturn custom || $.create({\n\t\t\t\tclassName: \"mv-status\"\n\t\t\t});\n\t\t},\n\t\tprepare: function() {\n\t\t\tlet backend = this.primaryBackend;\n\n\t\t\tif (backend?.user) {\n\t\t\t\tlet user = backend.user;\n\t\t\t\tlet html = [user.name || \"\"];\n\n\t\t\t\tif (user.avatar) {\n\t\t\t\t\thtml.unshift($.create(\"img\", {\n\t\t\t\t\t\tclassName: \"mv-avatar\",\n\t\t\t\t\t\tsrc: user.avatar\n\t\t\t\t\t}), \" \");\n\t\t\t\t}\n\n\t\t\t\tif (user.url) {\n\t\t\t\t\thtml = [$.create(\"a\", {\n\t\t\t\t\t\thref: user.url,\n\t\t\t\t\t\ttarget: \"_blank\",\n\t\t\t\t\t\tcontents: html\n\t\t\t\t\t})];\n\t\t\t\t}\n\n\t\t\t\tthis.bar.status.textContent = \"\";\n\t\t\t\t$.contents(this.bar.status, [\n\t\t\t\t\t{tag: \"span\", innerHTML: this._(\"logged-in-as\", backend)},\n\t\t\t\t\t\" \",\n\t\t\t\t\t...html\n\t\t\t\t]);\n\t\t\t}\n\t\t},\n\t\tpermission: \"logout\"\n\t},\n\n\tedit: {\n\t\taction: function() {\n\t\t\tif (this.editing) {\n\t\t\t\tthis.done();\n\t\t\t\tthis.bar.edit.textContent = this._(\"edit\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.edit();\n\t\t\t\tthis.bar.edit.textContent = this._(\"editing\");\n\t\t\t}\n\t\t},\n\t\tpermission: [\"edit\", \"add\", \"delete\"],\n\t\tcleanup: function() {\n\t\t\tif (this.editing) {\n\t\t\t\tthis.done();\n\n\t\t\t\tif (this.bar?.edit) {\n\t\t\t\t\tthis.bar.edit.textContent = this._(\"edit\");\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcondition: function() {\n\t\t\treturn this.needsEdit;\n\t\t}\n\t},\n\n\tsave: {\n\t\taction: function() {\n\t\t\tthis.save();\n\t\t},\n\t\tevents: {\n\t\t\t\"mouseenter focus\": function() {\n\t\t\t\tthis.element.classList.add(\"mv-highlight-unsaved\");\n\t\t\t},\n\t\t\t\"mouseleave blur\": function() {\n\t\t\t\tthis.element.classList.remove(\"mv-highlight-unsaved\");\n\t\t\t}\n\t\t},\n\t\tpermission: \"save\",\n\t\tcondition: function() {\n\t\t\treturn !this.autoSave || this.autoSaveDelay > 0;\n\t\t}\n\t},\n\n\texport: {\n\t\tcreate: function(custom) {\n\t\t\tlet a;\n\n\t\t\tif (custom) {\n\t\t\t\ta = custom.matches(\"a\")? custom : $.create(\"a\", {\n\t\t\t\t\tclassName: \"mv-button\",\n\t\t\t\t\taround: custom\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta = $.create(\"a\", {\n\t\t\t\t\tclassName: \"mv-export mv-button\",\n\t\t\t\t\ttextContent: this._(\"export\")\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ta.setAttribute(\"download\", this.id + \".json\");\n\n\t\t\treturn a;\n\t\t},\n\t\tevents: {\n\t\t\tmousedown: function() {\n\t\t\t\tthis.bar.export.href = \"data:application/json;charset=UTF-8,\" + encodeURIComponent(this.toJSON());\n\t\t\t}\n\t\t},\n\t\tpermission: \"edit\",\n\t\toptional: true\n\t},\n\n\timport: {\n\t\tcreate: function(custom) {\n\t\t\tlet button = custom || $.create(\"span\", {\n\t\t\t\trole: \"button\",\n\t\t\t\ttabIndex: \"0\",\n\t\t\t\tclassName: \"mv-import mv-button\",\n\t\t\t\ttextContent: this._(\"import\"),\n\t\t\t\tevents: {\n\t\t\t\t\tfocus: evt => {\n\t\t\t\t\t\tinput.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlet input = $.create(\"input\", {\n\t\t\t\ttype: \"file\",\n\t\t\t\tinside: button,\n\t\t\t\tevents: {\n\t\t\t\t\tchange: evt => {\n\t\t\t\t\t\tlet file = evt.target.files[0];\n\n\t\t\t\t\t\tif (file) {\n\t\t\t\t\t\t\tlet reader = $.extend(new FileReader(), {\n\t\t\t\t\t\t\t\tonload: evt => {\n\t\t\t\t\t\t\t\t\tthis.inProgress = false;\n\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet json = JSON.parse(reader.result);\n\t\t\t\t\t\t\t\t\t\tthis.render(json);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\t\t\t\tthis.error(this._(\"cannot-parse\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tonerror: evt => {\n\t\t\t\t\t\t\t\t\tthis.error(this._(\"problem-loading\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tthis.inProgress = this._(\"uploading\");\n\t\t\t\t\t\t\treader.readAsText(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn button;\n\t\t},\n\t\toptional: true\n\t},\n\n\tlogin: {\n\t\taction: function() {\n\t\t\tthis.primaryBackend.login();\n\t\t},\n\t\tpermission: \"login\"\n\t},\n\n\tlogout: {\n\t\taction: function() {\n\t\t\tthis.primaryBackend.logout();\n\t\t},\n\t\tpermission: \"logout\"\n\t}\n};\n\n})(Bliss, Bliss.$);\n","(function ($, $$) {\n\nvar _ = Mavo.UI.Message = $.Class({\n\tconstructor: function(mavo, message, o = {}) {\n\t\tthis.mavo = mavo;\n\t\tthis.message = message;\n\t\tthis.closed = Mavo.promise();\n\t\tthis.options = o;\n\n\t\tthis.element = $.create({\n\t\t\tclassName: \"mv-ui mv-message\" + (o.type? \" mv-\" + o.type : \"\"),\n\t\t\t[$.type(this.message) == \"string\"? \"innerHTML\" : \"contents\"]: this.message,\n\t\t\tevents: {\n\t\t\t\tclick: e => Mavo.scrollIntoViewIfNeeded(this.mavo.element)\n\t\t\t},\n\t\t\t[this.mavo.bar? \"after\" : \"start\"]: (this.mavo.bar || this.mavo).element\n\t\t});\n\n\t\tif (o.style) {\n\t\t\t$.style(this.element, o.style);\n\t\t}\n\n\t\tif (o.classes) {\n\t\t\tthis.element.classList.add(...o.classes.split(/\\s+/));\n\t\t}\n\n\t\tif (o.type == \"error\") {\n\t\t\tthis.element.setAttribute(\"role\", \"alert\");\n\t\t}\n\t\telse {\n\t\t\tthis.element.setAttribute(\"aria-live\", \"polite\");\n\t\t}\n\n\t\to.dismiss = o.dismiss || {};\n\n\t\tif (typeof o.dismiss == \"string\" || Array.isArray(o.dismiss)) {\n\t\t\tvar dismiss = {};\n\n\t\t\tMavo.toArray(o.dismiss).forEach(prop => {\n\t\t\t\tdismiss[prop] = true;\n\t\t\t});\n\n\t\t\to.dismiss = dismiss;\n\t\t}\n\n\t\tif (o.dismiss.button) {\n\t\t\t$.create(\"button\", {\n\t\t\t\ttype: \"button\",\n\t\t\t\tclassName: \"mv-close mv-ui\",\n\t\t\t\ttextContent: \"\",\n\t\t\t\tevents: {\n\t\t\t\t\t\"click\": evt => this.close()\n\t\t\t\t},\n\t\t\t\tstart: this.element,\n\t\t\t\ttitle: this.mavo._(\"dismiss\")\n\t\t\t});\n\t\t}\n\n\t\tif (o.dismiss.timeout) {\n\t\t\tvar timeout = typeof o.dismiss.timeout === \"number\"? o.dismiss.timeout : 5000;\n\n\t\t\t$.bind(this.element, {\n\t\t\t\tmouseenter: e => clearTimeout(this.closeTimeout),\n\t\t\t\tmouseleave: Mavo.rr(e => this.closeTimeout = setTimeout(() => this.close(), timeout)),\n\t\t\t});\n\t\t}\n\n\t\tif (o.dismiss.submit) {\n\t\t\tthis.element.addEventListener(\"submit\", evt => {\n\t\t\t\tevt.preventDefault();\n\t\t\t\tthis.close(evt.target);\n\t\t\t});\n\t\t}\n\t},\n\n\tasync close (resolve) {\n\t\t// clearTimeout, make the callback available for garbage collection, and make it easier to debug memory issues\n\t\t// it does nothing if there is no timeout callback.\n\t\tclearTimeout(this.closeTimeout);\n\t\tvar duration = this.element.style.transition ? 1000 * parseFloat(window.getComputedStyle(this.element, null).transitionDuration) : 400;\n\t\tawait $.transition(this.element, {opacity: 0}, duration);\n\n\t\t$.remove(this.element);\n\t\tthis.closed.resolve(resolve);\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.Permissions = $.Class({\n\tconstructor: function(o) {\n\t\tthis.triggers = [];\n\t\tthis.hooks = new $.Hooks();\n\n\t\t// If we dont do this, there is no way to retrieve this from inside parentChanged\n\t\tthis.parentChanged = _.prototype.parentChanged.bind(this);\n\n\t\tthis.set(o);\n\t},\n\n\t// Set multiple permissions at once\n\tset: function(o) {\n\t\tfor (var action in o) {\n\t\t\tthis[action] = o[action];\n\t\t}\n\t},\n\n\t// Set a bunch of permissions to true. Chainable.\n\ton: function(actions) {\n\t\tMavo.toArray(actions).forEach(action => this[action] = true);\n\n\t\treturn this;\n\t},\n\n\t// Set a bunch of permissions to false. Chainable.\n\toff: function(actions) {\n\t\tactions = Array.isArray(actions)? actions : [actions];\n\n\t\tactions.forEach(action => this[action] = false);\n\n\t\treturn this;\n\t},\n\n\t// Fired once at least one of the actions passed can be performed\n\t// Kind of like a Promise that can be resolved multiple times.\n\tcan: function(actions, callback, cannot) {\n\t\tthis.observe(actions, true, callback);\n\n\t\tif (cannot) {\n\t\t\t// Fired once the action cannot be done anymore, even though it could be done before\n\t\t\tthis.cannot(actions, cannot);\n\t\t}\n\t},\n\n\t// Fired once NONE of the actions can be performed\n\tcannot: function(actions, callback) {\n\t\tthis.observe(actions, false, callback);\n\t},\n\n\t// Schedule a callback for when a set of permissions changes value\n\tobserve: function(actions, value, callback) {\n\t\tactions = Mavo.toArray(actions);\n\n\t\tif (this.is(actions, value)) {\n\t\t\t// Should be fired immediately\n\t\t\tcallback();\n\t\t}\n\n\t\t// For future transitions\n\t\tthis.triggers.push({ actions, value, callback, active: true });\n\t},\n\n\t// Compare a set of permissions with true or false\n\t// If comparing with true, we want at least one to be true, i.e. OR\n\t// If comparing with false, we want ALL to be false, i.e. NOR\n\tis: function(actions, able = true) {\n\t\tvar or = Mavo.toArray(actions).map(action => !!this[action])\n\t\t                .reduce((prev, current) => prev || current);\n\n\t\treturn able? or : !or;\n\t},\n\n\t// Monitor all changes\n\tonchange: function(callback) {\n\t\t// Future changes\n\t\tthis.hooks.add(\"change\", callback);\n\n\t\t// Fire for current values\n\t\t_.actions.forEach(action => {\n\t\t\tcallback.call(this, {action, value: this[action]});\n\t\t});\n\t},\n\n\tparentChanged: function(o = {}) {\n\t\tvar localValue = this[\"_\" + o.action];\n\n\t\tif (localValue !== undefined || o.from == o.value) {\n\t\t\t// We have a local value so we dont care about parent changes OR nothing changed\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fireTriggers(o.action);\n\n\t\tthis.hooks.run(\"change\", $.extend({context: this}, o));\n\t},\n\n\t// A single permission changed value\n\tchanged: function(action, value, from) {\n\t\tfrom = !!from;\n\t\tvalue = !!value;\n\n\t\tif (value == from) {\n\t\t\t// Nothing changed\n\t\t\treturn;\n\t\t}\n\n\t\t// $.live() calls the setter before the actual property is set so we\n\t\t// need to set it manually, otherwise it still has its previous value\n\t\tthis[\"_\" + action] = value;\n\n\t\tthis.fireTriggers(action);\n\n\t\tthis.hooks.run(\"change\", {action, value, from, context: this});\n\t},\n\n\tfireTriggers: function(action) {\n\t\tthis.triggers.forEach(trigger => {\n\t\t\tvar match = this.is(trigger.actions, trigger.value);\n\n\t\t\tif (trigger.active && trigger.actions.indexOf(action) > -1 && match) {\n\n\t\t\t\ttrigger.active = false;\n\t\t\t\ttrigger.callback();\n\t\t\t}\n\t\t\telse if (!match) {\n\t\t\t\t// This is so that triggers can only be executed in an actual transition\n\t\t\t\t// And that if there is a trigger for [a,b] it won't be executed twice\n\t\t\t\t// if a and b are set to true one after the other\n\t\t\t\ttrigger.active = true;\n\t\t\t}\n\t\t});\n\t},\n\n\tor: function(permissions) {\n\t\t_.actions.forEach(action => {\n\t\t\tthis[action] = this[action] || permissions[action];\n\t\t});\n\n\t\treturn this;\n\t},\n\n\tlive: {\n\t\tparent: function(parent) {\n\t\t\tvar oldParent = this._parent;\n\n\t\t\tif (oldParent == parent) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._parent = parent;\n\n\t\t\t// Remove previous trigger, if any\n\t\t\tif (oldParent) {\n\t\t\t\tlet index = oldParent.hooks.change.indexOf(this.parentChanged);\n\n\t\t\t\tif (index > -1) {\n\t\t\t\t\toldParent.hooks.change.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// What changes does this cause? Fire triggers for them\n\t\t\t_.actions.forEach(action => {\n\t\t\t\tthis.parentChanged({\n\t\t\t\t\taction,\n\t\t\t\t\tvalue: parent? parent[action] : undefined,\n\t\t\t\t\tfrom: oldParent? oldParent[action] : undefined\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (parent) {\n\t\t\t\t// Add new trigger\n\t\t\t\tparent.onchange(this.parentChanged);\n\t\t\t}\n\t\t}\n\t},\n\n\tstatic: {\n\t\tactions: [],\n\n\t\t// Register a new permission type\n\t\tregister: function(action, setter) {\n\t\t\tif (Array.isArray(action)) {\n\t\t\t\taction.forEach(action => _.register(action, setter));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$.live(_.prototype, action, {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar ret = this[\"_\" + action];\n\n\t\t\t\t\tif (ret === undefined && this.parent) {\n\t\t\t\t\t\treturn this.parent[action];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t},\n\t\t\t\tset: function(able, previous) {\n\t\t\t\t\tif (setter) {\n\t\t\t\t\t\tsetter.call(this, able, previous);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.changed(action, able, previous);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t_.actions.push(action);\n\t\t}\n\t}\n});\n\n_.register([\"read\", \"save\"]);\n\n_.register(\"login\", function(can) {\n\tif (can && this.logout) {\n\t\tthis.logout = false;\n\t}\n});\n\n_.register(\"logout\", function(can) {\n\tif (can && this.login) {\n\t\tthis.login = false;\n\t}\n});\n\n_.register(\"edit\", function(can) {\n\tif (can) {\n\t\tthis.add = this.delete = true;\n\t}\n});\n\n_.register([\"add\", \"delete\"], function(can) {\n\tif (!can) {\n\t\tthis.edit = false;\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\n/**\n * Base class for all backends\n */\nvar _ = Mavo.Backend = class Backend extends EventTarget {\n\tconstructor (url, o = {}) {\n\t\tsuper();\n\n\t\t// Permissions of this particular backend.\n\t\tthis.permissions = new Mavo.Permissions();\n\n\t\tthis.update(url, o);\n\t}\n\n\tupdate (url, o = {}) {\n\t\tthis.source = url;\n\n\t\t// Backends that are not URL-based should just ignore this\n\t\tthis.url = new URL(this.source, Mavo.base);\n\n\t\tthis.options = o;\n\t\tthis.mavo = o.mavo;\n\t\tthis.format = Mavo.Formats.create(o.format, this);\n\n\t\tif (this.constructor.key ?? o.key) {\n\t\t\tthis.key = o.key ?? this.constructor.key;\n\t\t}\n\t}\n\n\tasync get (url = new URL(this.url)) {\n\t\tif (url.protocol != \"data:\" && this.constructor.useCache !== false) {\n\t\t\turl.searchParams.set(\"timestamp\", Date.now()); // ensure fresh copy\n\t\t}\n\n\t\ttry {\n\t\t\tlet response = await fetch(url.href);\n\t\t\treturn response.ok? response.text() : Promise.reject(response);\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tasync load () {\n\t\tawait this.ready;\n\t\tlet response = await this.get();\n\n\t\tif (typeof response != \"string\") {\n\t\t\t// Backend did the parsing, we're done here\n\t\t\treturn response;\n\t\t}\n\n\t\tresponse = response.replace(/^\\ufeff/, \"\"); // Remove Unicode BOM\n\n\t\treturn this.format.parse(response);\n\t}\n\n\tasync store (data, {path, format = this.format} = {}) {\n\t\tawait this.ready;\n\n\t\tvar serialized = typeof data === \"string\"? data : await format.stringify(data);\n\t\tawait this.put(serialized, path);\n\n\t\treturn {data, serialized};\n\t}\n\n\t// To be be overriden by subclasses\n\tready = Promise.resolve()\n\tasync login () {}\n\tasync logout () {}\n\tput () {\n\t\treturn Promise.reject();\n\t}\n\n\tisAuthenticated () {\n\t\treturn !!this.accessToken;\n\t}\n\n\t// Any extra params to be passed to the oAuth URL.\n\toAuthParams = () => \"\"\n\n\ttoString () {\n\t\treturn `${this.id} (${this.url})`;\n\t}\n\n\tequals (backend) {\n\t\treturn backend === this || (backend && this.id == backend.id && this.source == backend.source);\n\t}\n\n\t/**\n\t * Helper for making OAuth requests with JSON-based APIs.\n\t */\n\tasync request (call, data, method = \"GET\", req = {}) {\n\t\treq = Object.assign({}, req); // clone\n\t\treq.method = req.method || method;\n\t\treq.responseType = req.responseType || \"json\";\n\n\t\treq.headers = Object.assign({\n\t\t\t\"Content-Type\": \"application/json; charset=utf-8\"\n\t\t}, req.headers || {});\n\n\t\tif (this.isAuthenticated()) {\n\t\t\treq.headers[\"Authorization\"] = req.headers[\"Authorization\"] || `Bearer ${this.accessToken}`;\n\t\t}\n\n\t\treq.body = data;\n\n\t\tcall = new URL(call, this.constructor.apiDomain);\n\n\t\t// Prevent getting a cached response. Cache-control is often not allowed via CORS\n\t\tif (req.method == \"GET\" && this.constructor.useCache !== false) {\n\t\t\tcall.searchParams.set(\"timestamp\", Date.now());\n\t\t}\n\n\t\tif ($.type(req.body) === \"object\") {\n\t\t\tif (req.method === \"GET\" || req.method === \"HEAD\") {\n\t\t\t\tfor (let p in req.body) {\n\t\t\t\t\tlet action = req.body[p] === undefined? \"delete\" : \"set\";\n\t\t\t\t\tcall.searchParams[action](p, req.body[p]);\n\t\t\t\t}\n\n\t\t\t\tdelete req.body;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treq.body = JSON.stringify(req.body);\n\t\t\t}\n\t\t}\n\n\t\tlet response;\n\n\t\ttry {\n\t\t\tresponse = await fetch(call, req);\n\t\t}\n\t\tcatch (err) {\n\t\t\tthis.mavo.error(\"Something went wrong while connecting to \" + this.id, err);\n\t\t}\n\n\t\tif (response?.ok) {\n\t\t\tif (req.method === \"HEAD\" || req.responseType === \"response\") {\n\t\t\t\treturn response;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn response[req.responseType]();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow response;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method for authenticating in OAuth APIs\n\t */\n\toAuthenticate (passive) {\n\t\treturn this.ready.then(() => {\n\t\t\tif (this.isAuthenticated()) {\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tvar id = this.id.toLowerCase();\n\n\t\t\t\tif (passive) {\n\t\t\t\t\tthis.accessToken = localStorage[`mavo:${id}token`];\n\n\t\t\t\t\tif (this.accessToken) {\n\t\t\t\t\t\tresolve(this.accessToken);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Show window\n\t\t\t\t\tvar popup = {\n\t\t\t\t\t\twidth: Math.min(1000, innerWidth - 100),\n\t\t\t\t\t\theight: Math.min(800, innerHeight - 100)\n\t\t\t\t\t};\n\n\t\t\t\t\tpopup.top = (screen.height - popup.height)/2;\n\t\t\t\t\tpopup.left = (screen.width - popup.width)/2;\n\n\t\t\t\t\tvar state = {\n\t\t\t\t\t\turl: location.href,\n\t\t\t\t\t\tbackend: this.id\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.authPopup = open(`${this.constructor.oAuth}?client_id=${this.key}&state=${encodeURIComponent(JSON.stringify(state))}` + this.oAuthParams(),\n\t\t\t\t\t\t\"popup\", `width=${popup.width},height=${popup.height},left=${popup.left},top=${popup.top}`);\n\n\t\t\t\t\tif (!this.authPopup) {\n\t\t\t\t\t\tvar message = \"Login popup was blocked! Please check your popup blocker settings.\";\n\t\t\t\t\t\tthis.mavo.error(message);\n\t\t\t\t\t\treject(Error(message));\n\t\t\t\t\t}\n\n\t\t\t\t\taddEventListener(\"message\", evt => {\n\t\t\t\t\t\tif (evt.source === this.authPopup) {\n\t\t\t\t\t\t\tif (evt.data.backend == this.id) {\n\t\t\t\t\t\t\t\tthis.accessToken = localStorage[`mavo:${id}token`] = evt.data.token;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!this.accessToken) {\n\t\t\t\t\t\t\t\treject(Error(\"Authentication error\"));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tresolve(this.accessToken);\n\n\t\t\t\t\t\t\t// Log in to other similar backends that are logged out\n\t\t\t\t\t\t\tfor (var appid in Mavo.all) {\n\t\t\t\t\t\t\t\tvar storage = Mavo.all[appid].primaryBackend;\n\n\t\t\t\t\t\t\t\tif (storage\n\t\t\t\t\t\t\t\t\t&& storage.id === this.id\n\t\t\t\t\t\t\t\t\t&& storage !== this\n\t\t\t\t\t\t\t\t\t&& !storage.isAuthenticated()) {\n\t\t\t\t\t\t\t\t\t\tstorage.login(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * oAuth logout helper\n\t */\n\toAuthLogout () {\n\t\tif (this.isAuthenticated()) {\n\t\t\tvar id = this.id.toLowerCase();\n\n\t\t\tlocalStorage.removeItem(`mavo:${id}token`);\n\t\t\tdelete this.accessToken;\n\n\t\t\tthis.permissions.off([\"edit\", \"add\", \"delete\", \"save\"]).on(\"login\");\n\n\t\t\t$.fire(this, \"mv-logout\");\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\n\t// Return the appropriate backend(s) for this url\n\tstatic create (url, o = {}, existing) {\n\t\tlet Backend;\n\n\t\tif (o.type) {\n\t\t\t// Using get() for case-insensitive property lookup\n\t\t\tBackend = Mavo.Functions.get(_, o.type);\n\t\t}\n\n\t\tif (url && !Backend) {\n\t\t\tBackend = _.types.find(Backend => Backend.test(url, o)) || _.Remote;\n\t\t}\n\n\t\t// Can we re-use the existing object perhaps?\n\t\tif (Backend && existing?.constructor === Backend && existing.constructor.prototype.hasOwnProperty(\"update\")) {\n\t\t\texisting.update(url, o);\n\t\t\treturn existing;\n\t\t}\n\n\t\treturn Backend? new Backend(url, o) : null;\n\t}\n\n\tstatic types = []\n\n\tstatic register (Class) {\n\t\t_[Class.name] = Class;\n\t\t_.types.push(Class);\n\t\treturn Class;\n\t}\n};\n\n/**\n * Save in an HTML element\n */\n_.register(class Element extends _ {\n\tid = \"Element\"\n\n\tconstructor (url, o) {\n\t\tsuper(url, o);\n\n\t\tthis.permissions.on([\"read\", \"edit\", \"save\"]);\n\t}\n\n\tupdate (url, o) {\n\t\tsuper.update(url, o);\n\n\t\tthis.observer?.disconnect();\n\n\t\tthis.element = $(this.source) ?? $.create(\"script\", {\n\t\t\ttype: \"application/json\",\n\t\t\tid: this.source.slice(1),\n\t\t\tinside: document.body\n\t\t});\n\n\t\tthis.observer = this.observer ?? new MutationObserver(records => {\n\t\t\t$.fire(this, \"mv-remotedatachange\");\n\t\t});\n\n\t\tthis.observer.observe(this.element, {\n\t\t\tchildList: true,\n\t\t\tcharacterData: true,\n\t\t\tsubtree: true\n\t\t});\n\t}\n\n\tasync get () {\n\t\treturn this.element.textContent;\n\t}\n\n\tasync put (serialized) {\n\t\tthis.observer.disconnect();\n\n\t\tlet ret = this.element.textContent = serialized;\n\n\t\tthis.observer.observe(this.element, {\n\t\t\tchildList: true,\n\t\t\tcharacterData: true,\n\t\t\tsubtree: true\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tstatic test (url) {\n\t\treturn url.indexOf(\"#\") === 0;\n\t}\n});\n\n// Load from a remote URL, no save\n_.register(class Remote extends _ {\n\tid = \"Remote\"\n\n\tconstructor (url, o) {\n\t\tsuper(url, o);\n\t\tthis.permissions.on(\"read\");\n\t}\n\n\tstatic test (url) {\n\t\treturn false;\n\t}\n});\n\n// Save in localStorage\n_.register(class Local extends _ {\n\tid = \"Local\"\n\n\tconstructor (url, o) {\n\t\tsuper(url, o);\n\t\tthis.permissions.on([\"read\", \"edit\", \"save\"]);\n\t}\n\n\tupdate (url, o) {\n\t\tsuper.update(url, o);\n\t\tthis.key = o.key || this.mavo.id;\n\t}\n\n\tget () {\n\t\treturn Promise[this.key in localStorage? \"resolve\" : \"reject\"](localStorage[this.key]);\n\t}\n\n\tput (serialized) {\n\t\tif (!serialized) {\n\t\t\tdelete localStorage[this.key];\n\t\t}\n\t\telse {\n\t\t\tlocalStorage[this.key] = serialized;\n\t\t}\n\n\t\treturn Promise.resolve(serialized);\n\t}\n\n\tstatic test (value) {\n\t\treturn value == \"local\";\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.Formats = {};\n\nvar base = _.Base = $.Class({\n\tabstract: true,\n\tconstructor: function(backend) {\n\t\tthis.backend = backend;\n\t},\n\tproxy: {\n\t\t\"mavo\": \"backend\"\n\t},\n\n\t// So that child classes can only override the static methods if they don't\n\t// need access to any instance variables.\n\tparse: function(content) {\n\t\treturn this.constructor.parse(content, this);\n\t},\n\tstringify: function(data) {\n\t\treturn this.constructor.stringify(data, this);\n\t},\n\n\tstatic: {\n\t\tparse: serialized => Promise.resolve(serialized),\n\t\tstringify: data => Promise.resolve(data),\n\t\textensions: [],\n\t\tdependencies: [],\n\t\tready: function() {\n\t\t\treturn Promise.all(this.dependencies.map(d => $.include(d.test(), d.url)));\n\t\t}\n\t}\n});\n\nvar json = _.JSON = $.Class({\n\textends: _.Base,\n\tstatic: {\n\t\tparse: serialized => Promise.resolve(serialized? JSON.parse(serialized) : null),\n\t\tstringify: data => Promise.resolve(Mavo.toJSON(data)),\n\t\textensions: [\".json\", \".jsonld\"]\n\t}\n});\n\nvar text = _.Text = $.Class({\n\textends: _.Base,\n\tconstructor: function(backend) {\n\t\tthis.property = this.mavo.root.getNames(\"Primitive\")[0];\n\t},\n\n\tstatic: {\n\t\textensions: [\".txt\"],\n\t\tparse: (serialized, me) => Promise.resolve({[me? me.property : \"content\"]: serialized}),\n\t\tstringify: (data, me) => Promise.resolve(data[me? me.property : \"content\"])\n\t}\n});\n\nvar csv = _.CSV = $.Class({\n\textends: _.Base,\n\tconstructor: function(backend) {\n\t\tthis.property = this.mavo.root.getNames(\"Collection\")[0];\n\t\tthis.options = $.extend({}, _.CSV.defaultOptions);\n\t},\n\n\tstatic: {\n\t\textensions: [\".csv\", \".tsv\"],\n\t\tdefaultOptions: {\n\t\t\theader: true,\n\t\t\tdynamicTyping: true,\n\t\t\tskipEmptyLines: true\n\t\t},\n\t\tdependencies: [{\n\t\t\ttest: () => self.Papa,\n\t\t\turl: \"https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.4/papaparse.min.js\"\n\t\t}],\n\t\tready: base.ready,\n\t\tparse: async (serialized, me) => {\n\t\t\tawait csv.ready();\n\t\t\tvar data = Papa.parse(serialized, csv.defaultOptions);\n\t\t\tvar property = me? me.property : \"content\";\n\n\t\t\tif (me) {\n\t\t\t\t// Get delimiter & linebreak for serialization\n\t\t\t\tme.options.delimiter = data.meta.delimiter;\n\t\t\t\tme.options.linebreak = data.meta.linebreak;\n\t\t\t}\n\n\t\t\tif (data.meta.aborted) {\n\t\t\t\tthrow data.meta.errors.pop();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t[property]: data.data\n\t\t\t};\n\t\t},\n\n\t\tstringify: async (data, me) => {\n\t\t\tawait csv.ready();\n\t\t\tvar property = me? me.property : \"content\";\n\t\t\tvar options = me? me.options : csv.defaultOptions;\n\t\t\treturn Papa.unparse(data[property], options);\n\t\t}\n\t}\n});\n\nObject.defineProperty(_, \"create\", {\n\tvalue: function(format, backend) {\n\t\tif (format && typeof format === \"object\") {\n\t\t\treturn format;\n\t\t}\n\n\t\tif (typeof format === \"string\") {\n\t\t\t// Search by id\n\t\t\tformat = format.toLowerCase();\n\n\t\t\tfor (var id in _) {\n\t\t\t\tvar Format = _[id];\n\n\t\t\t\tif (id.toLowerCase() == format) {\n\t\t\t\t\treturn new Format(backend);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!format) {\n\t\t\tvar url = backend.url? backend.url.pathname : backend.source;\n\t\t\tvar extension = url.match(/\\.\\w+$/)?.[0] ?? \".json\";\n\t\t\tvar Format = _.JSON;\n\n\t\t\tfor (var id in _) {\n\t\t\t\tif (_[id].extensions.indexOf(extension) > -1) {\n\t\t\t\t\t// Do not return match, as we may find another match later\n\t\t\t\t\t// and last match wins\n\t\t\t\t\tFormat = _[id];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Format(backend);\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.Node = class Node {\n\tconstructor (element, mavo, options = {}) {\n\t\tif (!element || !mavo) {\n\t\t\tthrow new Error(\"Mavo.Node constructor requires an element argument and a mavo object\");\n\t\t}\n\n\t\tvar env = {context: this, options};\n\n\t\t// Set these first, for debug reasons\n\t\tthis.uid = _.all.push(this) - 1;\n\t\tthis.property = null;\n\t\tthis.element = element;\n\t\tthis.isHelperVariable = this.element.matches(\"meta\");\n\n\t\t$.extend(this, env.options);\n\n\t\t_.elements.set(element, [...(_.elements.get(this.element) || []), this]);\n\n\t\tthis.mavo = mavo;\n\t\tthis.group = this.parent = this.parentGroup = env.options.group;\n\n\t\tthis.template = env.options.template;\n\n\t\tthis.alias = this.element.getAttribute(\"mv-alias\");\n\n\t\tif (this.template) {\n\t\t\tthis.template.copies.add(this);\n\t\t}\n\t\telse {\n\t\t\t// First (or only) of its kind\n\t\t\tthis.copies = new Set();\n\t\t}\n\n\t\tif (!this.fromTemplate(\"property\", \"type\", \"storage\", \"path\")) {\n\t\t\tthis.property = _.getProperty(element);\n\t\t\tthis.type = Mavo.Group.normalize(element);\n\t\t\tthis.storage = this.element.getAttribute(\"mv-storage\");\n\t\t\tthis.path = this.getPath();\n\t\t}\n\n\t\tthis.modes = this.element.getAttribute(\"mv-mode\");\n\n\t\tMavo.hooks.run(\"node-init-start\", env);\n\n\t\tthis.mode = Mavo.getStyle(this.element, \"--mv-mode\") || \"read\";\n\n\t\tthis.collection = env.options.collection;\n\n\t\tif (this.collection) {\n\t\t\t// This is a collection item\n\t\t\tthis.group = this.parentGroup = this.collection.parentGroup;\n\t\t}\n\n\t\t// Must run before collections have a marker which messes up paths\n\t\tvar template = this.template;\n\n\t\tif (template?.expressions) {\n\t\t\t// We know which expressions we have, don't traverse again\n\t\t\tthis.expressions = new Set();\n\n\t\t\tfor (let et of template.expressions) {\n\t\t\t\tthis.expressions.add(\n\t\t\t\t\tnew Mavo.DOMExpression({\n\t\t\t\t\t\ttemplate: et,\n\t\t\t\t\t\titem: this,\n\t\t\t\t\t\tmavo: this.mavo\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (!(this instanceof Mavo.Primitive)) {\n\t\t\t// Handle mv-value\n\t\t\t// TODO integrate with the code in Primitive that decides whether this is a computed property\n\t\t\tvar et = Mavo.DOMExpression.search(this.element).filter(et => et.originalAttribute == \"mv-value\")[0];\n\n\t\t\tif (et) {\n\t\t\t\tet.mavoNode = this;\n\t\t\t\tthis.expressionText = et;\n\t\t\t\tthis.storage = this.storage || \"none\";\n\t\t\t\tthis.modes = this.modes || \"read\";\n\t\t\t}\n\t\t}\n\n\t\tMavo.hooks.run(\"node-init-end\", env);\n\t}\n\n\tget editing() {\n\t\treturn this.mode == \"edit\";\n\t}\n\n\tget isRoot() {\n\t\treturn !this.property;\n\t}\n\n\tget name() {\n\t\treturn Mavo.Functions.readable(this.property || this.type).toLowerCase();\n\t}\n\n\tget saved() {\n\t\treturn this.storage !== \"none\";\n\t}\n\n\tget properties() {\n\t\tlet route = this.liveData.data[Mavo.route];\n\t\treturn route? Object.keys(route) : [];\n\t}\n\n\t/**\n\t * Runs after the constructor is done (including the constructor of the inheriting class), synchronously\n\t */\n\tpostInit () {\n\t\tif (this.modes == \"edit\") {\n\t\t\tthis.edit();\n\t\t}\n\t}\n\n\tdestroy () {\n\t\tif (this.template) {\n\t\t\tthis.template.copies.delete(this);\n\t\t}\n\n\t\tif (this.expressions) {\n\t\t\tthis.expressions.forEach(expression => expression.destroy());\n\t\t}\n\n\t\tif (this.itembar) {\n\t\t\tthis.itembar.destroy();\n\t\t}\n\n\t\tdelete _.all[this.uid];\n\n\t\tthis.propagate(\"destroy\");\n\t}\n\n\tgetLiveData () {\n\t\treturn this.liveData.proxy;\n\t}\n\n\tisDataNull (o = {}) {\n\t\tvar env = {\n\t\t\tcontext: this,\n\t\t\toptions: o,\n\t\t\tresult: !this.saved && !o.live\n\t\t};\n\n\t\tMavo.hooks.run(\"node-isdatanull\", env);\n\n\t\treturn env.result;\n\t}\n\n\t/**\n\t * Execute a callback on every node of the Mavo tree\n\t * If callback returns (strict) false, walk stops.\n\t * @param callback {Function}\n\t * @param path {Array} Initial path. Mostly used internally.\n\t * @param o {Object} Options:\n\t * \t\t\t- descentReturn {Boolean} If callback returns false, just don't descend\n\t * \t\t\t                Otherwise, if callback returns false, it stops.\n\t * @return false if was stopped via a false return value, true otherwise\n\t */\n\twalk (callback, path = [], o = {}) {\n\t\tvar walker = (obj, path) => {\n\t\t\tvar ret = callback(obj, path);\n\n\t\t\tif (ret !== false) {\n\t\t\t\tfor (let i in obj.children) {\n\t\t\t\t\tlet node = obj.children[i];\n\n\t\t\t\t\tif (node instanceof Mavo.Node) {\n\t\t\t\t\t\tvar ret = walker.call(node, node, [...path, i]);\n\n\t\t\t\t\t\tif (ret === false && !o.descentReturn) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret !== false;\n\t\t};\n\n\t\treturn walker(this, path);\n\t}\n\n\twalkUp (callback) {\n\t\tvar group = this;\n\n\t\twhile (group = group.parentGroup) {\n\t\t\tvar ret = callback(group);\n\n\t\t\tif (ret !== undefined) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tedit ({force} = {}) {\n\t\tthis.mode = \"edit\";\n\n\t\tif (!force && this.mode != \"edit\") {\n\t\t\treturn false;\n\t\t}\n\n\t\t$.fire(this.element, \"mv-edit\", {\n\t\t\tmavo: this.mavo,\n\t\t\tnode: this\n\t\t});\n\n\t\tMavo.hooks.run(\"node-edit-end\", this);\n\t}\n\n\tdone ({force} = {}) {\n\t\tthis.mode = Mavo.getStyle(this.element.parentNode, \"--mv-mode\") || \"read\";\n\n\t\tif (!force && this.mode != \"read\") {\n\t\t\treturn false;\n\t\t}\n\n\t\t$.unbind(this.element, \".mavo:edit\");\n\n\t\t$.fire(this.element, \"mv-done\", {\n\t\t\tmavo: this.mavo,\n\t\t\tnode: this\n\t\t});\n\n\t\tthis.propagate(\"done\");\n\n\t\tMavo.hooks.run(\"node-done-end\", this);\n\t}\n\n\tsave () {\n\t\tthis.unsavedChanges = false;\n\n\t\tthis.propagate(\"save\");\n\t}\n\n\tpropagate (callback) {\n\t\tfor (let i in this.children) {\n\t\t\tlet node = this.children[i];\n\n\t\t\tif (node instanceof Mavo.Node) {\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tcallback.call(node, node);\n\t\t\t\t}\n\t\t\t\telse if (callback in node) {\n\t\t\t\t\tnode[callback]();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfromTemplate (...properties) {\n\t\tif (this.template) {\n\t\t\tproperties.forEach(property => this[property] = this.template[property]);\n\t\t}\n\n\t\treturn !!this.template;\n\t}\n\n\tasync render (data, o = {}) {\n\t\to.live = o.live || Mavo.in(Mavo.isProxy, data);\n\t\to.root = o.root || this;\n\n\t\t// Any promises pending to be rendered?\n\t\tdelete this.pending;\n\n\t\tif ($.type(data) === \"promise\") {\n\t\t\tlet pending = this.pending = data;\n\n\t\t\ttry {\n\t\t\t\tdata = await pending;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tdata = e;\n\t\t\t}\n\n\t\t\tif (this.pending !== pending) {\n\t\t\t\t// Value has been superseded\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete this.pending;\n\t\t}\n\n\t\tif (o.live) {\n\t\t\t// Drop proxy\n\t\t\tdata = Mavo.clone(data);\n\t\t}\n\n\t\tthis.oldData = this.data;\n\t\tthis.data = data;\n\n\t\tif (!o.live) {\n\t\t\tdata = Mavo.subset(data, this.inPath);\n\t\t}\n\n\t\tvar env = {context: this, data, options: o};\n\n\t\tMavo.hooks.run(\"node-render-start\", env);\n\n\t\tif (!this.isHelperVariable && !o.live) {\n\t\t\tif (!Array.isArray(this.children) && Array.isArray(env.data)) {\n\t\t\t\t// We are rendering an array on a singleton, what to do?\n\t\t\t\tif (this.isRoot) {\n\t\t\t\t\t// Get the name of the first property that is a collection without mv-value\n\t\t\t\t\t// OR if there is a collection with property=\"main\", prioritize that\n\t\t\t\t\tvar mainProperty = this.children.main instanceof Mavo.Collection? \"main\" : this.getNames((p, n) => {\n\t\t\t\t\t\treturn n instanceof Mavo.Collection && !n.expressions?.[0]?.isDynamicObject;\n\t\t\t\t\t})[0];\n\n\t\t\t\t\tif (mainProperty) {\n\t\t\t\t\t\tenv.data = {\n\t\t\t\t\t\t\t[mainProperty]: env.data\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!this.isRoot || !mainProperty) {\n\t\t\t\t\t// Otherwise, render first item\n\t\t\t\t\tthis.inPath.push(\"0\");\n\t\t\t\t\tenv.data = env.data[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.childrenNames?.length == 1 && this.childrenNames[0] === this.property\n\t\t\t         && env.data !== null && Mavo.isPlainObject(env.data)) {\n\t\t\t\t// {foo: {foo: 5}} should become {foo: 5}\n\t\t\t\tenv.data = env.data[this.property];\n\t\t\t}\n\t\t}\n\n\t\tif (this === o.root) {\n\t\t\tthis.expressionsEnabled = false;\n\t\t}\n\n\t\tvar editing = this.editing;\n\n\t\tif (editing) {\n\t\t\tthis.done();\n\t\t}\n\n\t\tvar changed = this.dataRender(env.data, o);\n\n\t\tif (editing) {\n\t\t\tthis.edit();\n\t\t}\n\n\t\tif (this === o.root) {\n\t\t\tthis.save();\n\n\t\t\tthis.expressionsEnabled = true;\n\n\t\t\tif (changed) {\n\t\t\t\trequestAnimationFrame(() => this.mavo.expressions.update(this));\n\t\t\t}\n\t\t}\n\n\t\tMavo.hooks.run(\"node-render-end\", env);\n\n\t\treturn changed;\n\t}\n\n\tdataChanged (action, o = {}) {\n\t\tvar change = $.extend({\n\t\t\taction,\n\t\t\tproperty: this.property,\n\t\t\tmavo: this.mavo,\n\t\t\tnode: this\n\t\t}, o);\n\n\t\t$.fire(o.element || this.element, \"mv-change\", change);\n\t\tthis.mavo.changed(change);\n\t}\n\n\ttoString () {\n\t\treturn `#${this.uid}: ${this.constructor.name} (${this.property})`;\n\t}\n\n\tgetClosestCollection () {\n\t\tvar closestItem = this.closestItem;\n\n\t\treturn closestItem? closestItem.collection : null;\n\t}\n\n\tgetClosestItem () {\n\t\tif (Array.isArray(this.collection?.children)) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.parentGroup?.closestItem || null;\n\t}\n\n\tgetPath () {\n\t\tvar path = this.parent?.path || [];\n\t\treturn this.property? [...path, this.property] : path;\n\t}\n\n\tpathFrom (node) {\n\t\tvar path = this.path;\n\t\tvar nodePath = node.path;\n\n\t\tfor (var i = 0; i<path.length && nodePath[i] == path[i]; i++) {}\n\n\t\treturn path.slice(i);\n\t}\n\n\tgetDescendant (path) {\n\t\treturn path.reduce((acc, cur) => acc.children[cur], this);\n\t}\n\n\t/**\n\t * Get same node in other item in same collection\n\t * E.g. for same node in the next item, use an offset of -1\n\t */\n\tgetCousin (offset, o = {}) {\n\t\tif (!this.closestCollection) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar collection = this.closestCollection;\n\t\tvar distance = Math.abs(offset);\n\t\tvar direction =  offset < 0? -1 : 1;\n\n\t\tif (collection.length < distance + 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar index = this.closestItem.index + offset;\n\n\t\tif (o.wrap) {\n\t\t\tindex = Mavo.wrap(index, collection.length);\n\t\t}\n\n\t\tfor (var i = 0; i<collection.length; i++) {\n\t\t\tvar ind = index + i * direction;\n\n\t\t\tif (o.wrap) {\n\t\t\t\tind = Mavo.wrap(ind, collection.length);\n\t\t\t}\n\n\t\t\tvar item = collection.children[ind];\n\n\t\t\tif (item) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!item || item == this.closestItem) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.collection) {\n\t\t\treturn item;\n\t\t}\n\n\t\tvar relativePath = this.pathFrom(this.closestItem);\n\t\treturn item.getDescendant(relativePath);\n\t}\n\n\tcontains (node) {\n\t\tdo {\n\t\t\tif (node === this) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\t\twhile (node);\n\n\t\treturn false;\n\t}\n\n\t// Evaluate expression on the fly with this node as context\n\teval(expr, o) {\n\t\treturn new Mavo.Expression(expr).eval(this.getLiveData(), o);\n\t}\n\n\tstatic create (element, mavo, o = {}) {\n\t\tif (element.hasAttribute(\"mv-list\")) {\n\t\t\treturn new Mavo.Collection(element, mavo, o);\n\t\t}\n\n\t\tlet isGroup = element.matches(Mavo.selectors.group);\n\t\treturn new Mavo[isGroup? \"Group\" : \"Primitive\"](element, mavo, o);\n\t}\n\n\tstatic getImplicitPropertyName (element) {\n\t\treturn element.getAttribute(\"itemprop\")\n\t\t       || element.getAttribute(\"mv-list\")\n\t\t       || element.getAttribute(\"mv-list-item\")\n\t\t       || element.name\n\t\t       || element.id\n\t\t       || [...element.classList].filter(n => !n.startsWith(\"mv-\"))[0];\n\t}\n\n\t/**\n\t * Get & normalize property name, if exists\n\t */\n\tstatic getProperty (element) {\n\t\tif (!element.hasAttribute(\"property\")) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet property = element.getAttribute(\"property\");\n\n\t\tif (!property) {\n\t\t\tif (property = _.getImplicitPropertyName(element)) {\n\t\t\t\telement.setAttribute(\"property\", property);\n\t\t\t}\n\t\t}\n\n\t\treturn property;\n\t}\n\n\tstatic generatePropertyName(prefix, element = document.documentElement) {\n\t\tlet root = element.closest(Mavo.selectors.init);\n\t\tlet names = new Set(...$$(\"[property]\", root).map(e => e.getAttribute(\"property\")));\n\n\t\tfor (let i=\"\"; i<1000; i++) { // 1000 is just a failsafe\n\t\t\tlet name = prefix + i;\n\n\t\t\tif (!names.has(name)) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic get (element, prioritizePrimitive) {\n\t\tlet nodes = _.elements.get(element) || [];\n\n\t\t// Do not return implicit collections\n\t\tnodes = nodes.filter(n => !(n instanceof Mavo.ImplicitCollection));\n\n\t\tif (nodes.length < 2 || !prioritizePrimitive) {\n\t\t\treturn nodes[0];\n\t\t}\n\n\t\tif (nodes[0] instanceof Mavo.Group) {\n\t\t\treturn nodes[1];\n\t\t}\n\t}\n\n\tstatic getClosest (element, prioritizePrimitive) {\n\t\tlet node;\n\n\t\tdo {\n\t\t\tnode = _.get(element, prioritizePrimitive);\n\t\t} while (!node && (element = element?.parentNode));\n\n\t\treturn node;\n\t}\n\n\tstatic getClosestItem (element) {\n\t\tvar item = _.getClosest(element);\n\n\t\tif (item instanceof Mavo.Primitive && !item.collection) {\n\t\t\treturn item.parent;\n\t\t}\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Get all properties that are inside an element but not nested into other properties\n\t */\n\tstatic children (element) {\n\t\tvar ret = Mavo.Node.get(element);\n\n\t\tif (ret) {\n\t\t\t// element is a Mavo node\n\t\t\treturn [ret];\n\t\t}\n\n\t\tret = $$(Mavo.selectors.property, element)\n\t\t\t.map(e => Mavo.Node.get(e))\n\t\t\t.filter(e => !element.contains(e.parentGroup.element)) // drop nested properties\n\t\t\t.map(e => e.collection || e);\n\n\t\treturn Mavo.Functions.unique(ret);\n\t}\n};\n\n$.Class(_, {\n\ttoJSON: Mavo.prototype.toJSON,\n\n\tlazy: {\n\t\tclosestCollection: function() {\n\t\t\treturn this.getClosestCollection();\n\t\t},\n\n\t\tclosestItem: function() {\n\t\t\treturn this.getClosestItem();\n\t\t},\n\n\t\t// Are we only rendering and editing a subset of the data?\n\t\tinPath: function() {\n\t\t\treturn (this.element.getAttribute(\"mv-path\") || \"\").split(\"/\").filter(p => p.length);\n\t\t}\n\t},\n\n\tlive: {\n\t\tstore: function(value) {\n\t\t\t$.toggleAttribute(this.element, \"mv-storage\", value);\n\t\t},\n\n\t\tunsavedChanges: function(value) {\n\t\t\tif (value && (!this.saved || !this.editing)) {\n\t\t\t\tvalue = false;\n\t\t\t}\n\n\t\t\tif (!Array.isArray(this.children)) {\n\t\t\t\tthis.element.classList.toggle(\"mv-unsaved-changes\", value);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\n\t\tmode: function (value) {\n\t\t\tif (this._mode != value) {\n\t\t\t\t// Is it allowed?\n\t\t\t\tif (this.modes && value != this.modes) {\n\t\t\t\t\tvalue = this.modes;\n\t\t\t\t}\n\n\t\t\t\t// If we don't do this, setting the attribute below will\n\t\t\t\t// result in infinite recursion\n\t\t\t\tthis._mode = value;\n\n\t\t\t\tif (!Array.isArray(this.children) && [null, \"\", \"read\", \"edit\"].indexOf(this.element.getAttribute(\"mv-mode\")) > -1) {\n\t\t\t\t\t// If attribute is not one of the recognized values, leave it alone\n\t\t\t\t\tvar set = this.modes || value == \"edit\";\n\t\t\t\t\tlet matches = Mavo.observers.pause({attribute: \"mv-mode\"});\n\t\t\t\t\t$.toggleAttribute(this.element, \"mv-mode\", value, set);\n\t\t\t\t\tMavo.observers.resume(matches);\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\t\t},\n\n\t\tmodes: function(value) {\n\t\t\tif (value && value != \"read\" && value != \"edit\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tthis._modes = value;\n\n\t\t\tif (value && this.mode != value) {\n\t\t\t\tthis.mode = value;\n\t\t\t}\n\t\t},\n\n\t\tcollection: function(value) {\n\t\t\t// These only change when collection changes\n\t\t\tthis.parent = value || this.parentGroup;\n\t\t},\n\n\t\tindex: function(value) {\n\t\t\tif (this._index !== value) {\n\t\t\t\tthis._index = value;\n\t\t\t\tthis.liveData.updateKey();\n\t\t\t}\n\t\t},\n\n\t\texpressionsEnabled: {\n\t\t\tget: function() {\n\t\t\t\tif (this._expressionsEnabled === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn this.parent? this.parent.expressionsEnabled : true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatic: {\n\t\tall: [],\n\t\telements: new WeakMap()\n\t}\n});\n\nMavo.observe({attribute: \"mv-storage\"}, function({node}) {\n\t// Handle dynamic mv-storage on Mavo nodes (Fix for #576)\n\tif (node) {\n\t\tnode.storage = node.element.getAttribute(\"mv-storage\");\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.Group = class Group extends Mavo.Node {\n\tconstructor (element, mavo, o) {\n\t\tsuper(element, mavo, o);\n\n\t\tthis.children = {};\n\n\t\tthis.group = this;\n\n\t\tMavo.hooks.run(\"group-init-start\", this);\n\n\t\t// Should this element also create a primitive?\n\t\tif (Mavo.Primitive.getValueAttribute(this.element)) {\n\t\t\tthis.children[this.property] = new Mavo.Primitive(this.element, this.mavo, {group: this});\n\t\t}\n\n\t\t// Create Mavo objects for all properties in this group (primitives or groups),\n\t\t// but not properties in descendant groups (they will be handled by their group)\n\t\tlet properties = $$(`[property]:not(:scope ${Mavo.selectors.scope} [property])`, this.element);\n\t\tlet propertyNames = properties.map(element => Mavo.Node.getProperty(element));\n\n\t\tfor (let i = 0, element; element = properties[i]; i++) {\n\t\t\tlet property = Mavo.Node.getProperty(element);\n\t\t\tlet existing = this.children[property];\n\t\t\tlet template = this.template? this.template.children[property] : null;\n\t\t\tlet options = {template, group: this};\n\n\t\t\tif (existing) {\n\t\t\t\t// FIXME if this group includes a primitive (see line 14 above)\n\t\t\t\t// and also a child property of the same name, this will fail\n\t\t\t\texisting.add(element);\n\t\t\t}\n\t\t\telse if (propertyNames.lastIndexOf(property) !== i) {\n\t\t\t\t// Duplicate property name\n\t\t\t\tthis.children[property] = new Mavo.ImplicitCollection(element, this.mavo, options);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Normal case\n\t\t\t\tthis.children[property] = Mavo.Node.create(element, this.mavo, options);\n\t\t\t}\n\t\t}\n\n\t\tthis.childrenNames = Object.keys(this.children);\n\n\t\tthis.vocab = Mavo.getClosestAttribute(this.element, \"vocab\");\n\n\t\tthis.postInit();\n\n\t\tMavo.hooks.run(\"group-init-end\", this);\n\t}\n\n\tget isRoot() {\n\t\treturn !this.property;\n\t}\n\n\tgetNames (type = \"Node\") {\n\t\tvar filter = typeof type === \"function\"? type : (p, n) => n instanceof Mavo[type];\n\t\treturn Object.keys(this.children).filter(p => filter(p, this.children[p]));\n\t}\n\n\tgetData (o = {}) {\n\t\tvar env = {\n\t\t\tcontext: this,\n\t\t\toptions: o\n\t\t};\n\n\t\tif (this.isDataNull(o)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tenv.data = Mavo.shallowClone(Mavo.subset(this.data, this.inPath)) || {};\n\n\t\tfor (var property in this.children) {\n\t\t\tvar obj = this.children[property];\n\n\t\t\tif (obj.saved) {\n\t\t\t\tvar data = obj.getData(env.options);\n\t\t\t}\n\n\t\t\tif (obj.saved && Mavo.value(data) !== null) {\n\t\t\t\tenv.data[obj.property] = data;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete env.data[obj.property];\n\t\t\t}\n\t\t}\n\n\t\tif (!this.childrenNames.length && !this.isRoot && !this.collection) {\n\t\t\t// Avoid {} in the data\n\t\t\tenv.data = null;\n\t\t}\n\t\telse if (this.childrenNames.length === 1 && this.property in this.children) {\n\t\t\tenv.data = env.data[this.property];\n\t\t}\n\t\telse if (env.data && typeof env.data === \"object\") {\n\t\t\t// Add JSON-LD stuff\n\t\t\tif (this.type && this.type != _.DEFAULT_TYPE) {\n\t\t\t\tenv.data[\"@type\"] = this.type;\n\t\t\t}\n\n\t\t\tif (this.vocab) {\n\t\t\t\tenv.data[\"@context\"] = this.vocab;\n\t\t\t}\n\t\t}\n\n\t\t// If storing, use the rendered data too\n\t\tenv.data = Mavo.subset(this.data, this.inPath, env.data);\n\n\t\tMavo.hooks.run(\"node-getdata-end\", env);\n\n\t\treturn env.data;\n\t}\n\n\tedit (o = {}) {\n\t\tif (super.edit() === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn Promise.all(Object.keys(this.children).map(prop => this.children[prop].edit(o)));\n\t}\n\n\tdataRender (data, o = {}) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet changed = false;\n\n\t\t// What if data is not an object?\n\t\tlet noWriteableProperty;\n\t\tlet wasPrimitive;\n\n\t\tif (typeof data !== \"object\") {\n\t\t\twasPrimitive = true;\n\t\t\tlet property = this.property;\n\n\t\t\t// Data is a primitive, render it on this.property or failing that, any writable property\n\t\t\tif (!(this.property in this.children)) {\n\t\t\t\tlet type = $.type(data);\n\t\t\t\tlet score = prop => (this.children[prop] instanceof Mavo.Primitive) + (this.children[prop].datatype == type);\n\n\t\t\t\tproperty = Object.keys(this.children)\n\t\t\t\t\t.filter(p => !this.children[p].expressionText)\n\t\t\t\t\t.sort((prop1, prop2) => score(prop1) - score(prop2))\n\t\t\t\t\t.reverse()[0];\n\t\t\t}\n\n\t\t\tif (!property) {\n\t\t\t\t// No appropriate property found, use this.property\n\t\t\t\tproperty = this.property;\n\t\t\t\tnoWriteableProperty = true;\n\t\t\t}\n\n\t\t\tdata = {[property]: data};\n\n\t\t\tthis.data = Mavo.subset(this.data, this.inPath, data);\n\t\t}\n\n\t\tlet copy; // to handle renaming\n\n\t\tthis.propagate(obj => {\n\t\t\tlet propertyData = data[obj.property];\n\n\t\t\t// find first alias with data, load that data, and set to be copied\n\t\t\tif (obj.alias) {\n\t\t\t\tlet aliasesArr = obj.alias.split(\" \");\n\n\t\t\t\tfor (let i = 0; i < aliasesArr.length; i++) {\n\t\t\t\t\tlet currentAlias = aliasesArr[i];\n\n\t\t\t\t\tif (data[currentAlias] !== undefined) {\n\t\t\t\t\t\tobj.currentAlias = currentAlias;\n\t\t\t\t\t\tcopy = copy || $.extend({}, data);\n\t\t\t\t\t\tpropertyData = data[obj.currentAlias];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanged = obj.render(propertyData, o) || changed;\n\t\t});\n\n\t\t// Rename properties. This needs to be done separately to handle swapping.\n\t\tif (copy) {\n\t\t\tthis.propagate(obj => {\n\t\t\t\tif (obj.currentAlias) {\n\t\t\t\t\tdata[obj.property] = copy[obj.currentAlias];\n\n\t\t\t\t\tif (!(obj.currentAlias in this.children)) {\n\t\t\t\t\t\tdelete data[obj.currentAlias];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (!wasPrimitive || noWriteableProperty) {\n\t\t\t// Fire mv-change events for properties not in the template,\n\t\t\t// since nothing else will and they can still be referenced in expressions\n\t\t\tlet oldData = Mavo.subset(this.oldData, this.inPath);\n\n\t\t\tfor (let property in data) {\n\t\t\t\tif (!(property in this.children)) {\n\t\t\t\t\tlet value = data[property];\n\t\t\t\t\tchanged = changed || data[property] !== this.liveData.data[property];\n\n\t\t\t\t\tthis.liveData.set(property, value);\n\n\t\t\t\t\tif (this.expressionsEnabled !== false && typeof value != \"object\" && (!oldData || oldData[property] != value)) {\n\t\t\t\t\t\t// Property actually changed. Why != \"object\" though?\n\t\t\t\t\t\tthis.dataChanged(\"propertychange\", {property});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\tstatic normalize (element) {\n\t\t// Get & normalize typeof name, if exists\n\t\tif (element.matches(Mavo.selectors.group)) {\n\t\t\tvar type = Mavo.getAttribute(element, \"typeof\", \"mv-group\") || _.DEFAULT_TYPE;\n\n\t\t\telement.setAttribute(\"typeof\", type);\n\n\t\t\treturn type;\n\t\t}\n\n\t\treturn null;\n\t}\n};\n\n$.Class(_, {\n\tlazy: {\n\t\tliveData: function() {\n\t\t\treturn new Mavo.Data(this, {});\n\t\t}\n\t},\n\n\tstatic: {\n\t\tall: new WeakMap(),\n\n\t\tDEFAULT_TYPE: \"Item\"\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(async function($, $$) {\n\nvar _ = Mavo.Primitive = class Primitive extends Mavo.Node {\n\tconstructor(element, mavo, o) {\n\t\tsuper(element, mavo, o);\n\n\t\tthis.liveData = new Mavo.Data(this);\n\n\t\tif (!this.fromTemplate(\"config\", \"attribute\", \"templateValue\", \"originalEditor\")) {\n\t\t\tthis.config = _.getConfig(element);\n\n\t\t\t// Which attribute holds the data, if any?\n\t\t\t// \"null\" or null for none (i.e. data is in content).\n\t\t\tthis.attribute = this.config.attribute;\n\n\t\t\t// HTML attribute names are case insensitive (Fix for #515)\n\t\t\tif (this.attribute && !document.xmlVersion) {\n\t\t\t\tthis.attribute = this.attribute.toLowerCase();\n\t\t\t}\n\t\t}\n\n\t\tthis.datatype = this.config.datatype;\n\n\t\tif (\"modes\" in this.config) {\n\t\t\t// If modes are related to element type, this overrides everything\n\t\t\t// because it means the other mode makes no sense for that element\n\t\t\tthis.modes = this.config.modes;\n\t\t\tthis.element.setAttribute(\"mv-mode\", this.config.modes);\n\t\t}\n\n\t\tMavo.hooks.run(\"primitive-init-start\", this);\n\n\t\t// Link primitive with its expressionText object\n\t\t// We need to do this before any editing UI is generated\n\t\tthis.expressionText = this.expressionText || Mavo.DOMExpression.search(this.element, this.attribute);\n\n\t\tif (this.expressionText && !this.expressionText.mavoNode) {\n\t\t\t// Computed property\n\t\t\tthis.expressionText.mavoNode = this;\n\t\t\tthis.storage = this.storage || \"none\";\n\t\t\tthis.modes = \"read\";\n\t\t\tthis.element.setAttribute(\"aria-live\", \"polite\");\n\t\t}\n\n\t\t/**\n\t\t * Set up input widget\n\t\t */\n\n\t\tif (this.config.init) {\n\t\t\tthis.config.init.call(this, this.element);\n\t\t}\n\n\t\tif (this.config.initOnce && !this.config.initOnce.called) {\n\t\t\tthis.config.initOnce.call(this, this.element);\n\t\t\tthis.config.initOnce.called = true;\n\t\t}\n\n\t\tif (this.config.changeEvents) {\n\t\t\t$.bind(this.element, this.config.changeEvents, evt => {\n\t\t\t\tif (evt.target === this.element) {\n\t\t\t\t\tthis.value = this.getValue();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this.expressionText) {\n\t\t\tthis.setValue(this.expressionText.value, {silent: true});\n\t\t}\n\t\telse {\n\t\t\tif (this.element.hasAttribute(\"aria-label\")) {\n\t\t\t\t// Custom label\n\t\t\t\tthis.label = this.element.getAttribute(\"aria-label\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.label = Mavo.Functions.readable(this.property);\n\t\t\t\tthis.pauseObserver();\n\t\t\t\tthis.element.setAttribute(\"aria-label\", this.label);\n\t\t\t\tthis.resumeObserver();\n\t\t\t}\n\n\t\t\t// Linked widgets\n\t\t\tif (this.element.hasAttribute(\"mv-editor\")) {\n\t\t\t\tthis.originalEditorUpdated({force: true});\n\n\t\t\t\tlet editorValue = this.editorValue;\n\n\t\t\t\tif (!this.datatype && (typeof editorValue == \"number\" || typeof editorValue == \"boolean\")) {\n\t\t\t\t\tthis.datatype = typeof editorValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.element.hasAttribute(\"mv-options\")) {\n\t\t\t\tthis.updateOptions();\n\t\t\t}\n\n\t\t\tthis.templateValue = this.getValue();\n\n\t\t\tthis._default = this.element.getAttribute(\"mv-default\");\n\n\t\t\tif (this.default === null) { // no mv-default\n\t\t\t\tif (this.modes) {\n\t\t\t\t\tthis._default = this.templateValue;\n\t\t\t\t\tthis.defaultSource = \"template\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._default = this.editorValue;\n\n\t\t\t\t\tif (this.options) {\n\t\t\t\t\t\t// Get first option\n\t\t\t\t\t\tlet firstOption = this.options.keys().next().value;\n\t\t\t\t\t\tthis._default = this._default ?? firstOption;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.defaultSource = \"editor\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.default === \"\") { // mv-default exists, no value, default is template value\n\t\t\t\tthis._default = this.templateValue;\n\t\t\t\tthis.defaultSource = \"template\";\n\t\t\t}\n\t\t\telse { // mv-default with value\n\t\t\t\tthis.defaultExpression = Mavo.DOMExpression.search(this.element, \"mv-default\");\n\n\t\t\t\tif (this.defaultExpression) {\n\t\t\t\t\t// To preserve type, e.g. booleans should stay booleans, not become strings\n\t\t\t\t\tthis.defaultExpression.output = value => this.default = value;\n\t\t\t\t}\n\n\t\t\t\tthis.defaultSource = \"attribute\";\n\t\t\t}\n\n\n\n\t\t\tthis.setValue(this.initialValue, {silent: true});\n\t\t}\n\n\t\tthis.postInit();\n\n\t\tMavo.hooks.run(\"primitive-init-end\", this);\n\t}\n\n\tget initialValue () {\n\t\tlet ret;\n\t\tlet keepTemplateValue = !this.template // not in a collection or first item\n\t\t                        || this.template.templateValue != this.templateValue // or different template value than first item\n\t\t                        || this.modes == \"edit\"; // or is always edited\n\n\t\tif (this.default === undefined && keepTemplateValue) {\n\t\t\tret = this.templateValue;\n\t\t}\n\t\telse {\n\t\t\tret = this.default;\n\t\t}\n\n\t\tif (ret === undefined) {\n\t\t\tret = this.emptyValue;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tget editorValue() {\n\t\tlet editor = this.editor || this.originalEditor;\n\n\t\tif (editor) {\n\t\t\tif (_.isFormControl(editor)) {\n\t\t\t\treturn _.getValue(editor, {datatype: this.datatype});\n\t\t\t}\n\n\t\t\t// if we're here, this.editor is an entire HTML structure\n\t\t\tlet output = $(Mavo.selectors.output + \", \" + Mavo.selectors.formControl, editor);\n\n\t\t\tif (output) {\n\t\t\t\treturn _.getValue(output);\n\t\t\t}\n\t\t}\n\t}\n\n\tset editorValue(value) {\n\t\tif (this.config.setEditorValue && this.datatype !== \"boolean\") {\n\t\t\treturn this.config.setEditorValue.call(this, value);\n\t\t}\n\n\t\tif (this.editor) {\n\t\t\tif (_.isFormControl(this.editor)) {\n\t\t\t\tif (this.editor.matches(\"select\")) {\n\t\t\t\t\tlet text = [...this.editor.options].find(o => o.value == value)?.textContent;\n\n\t\t\t\t\t// We have a local editor, do we need to add/remove temp options?\n\t\t\t\t\tif (text === undefined) {\n\t\t\t\t\t\t// Option not found in the select menu, add a temp option\n\t\t\t\t\t\t$.create(\"option\", {\n\t\t\t\t\t\t\tclassName: \"mv-volatile\",\n\t\t\t\t\t\t\ttextContent: value,\n\t\t\t\t\t\t\tinside: this.editor,\n\t\t\t\t\t\t\tselected: true,\n\t\t\t\t\t\t\tdisabled: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_.setValue(this.editor, value, {config: this.editorDefaults});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if we're here, this.editor is an entire HTML structure\n\t\t\t\tvar output = $(Mavo.selectors.output + \", \" + Mavo.selectors.formControl, this.editor);\n\n\t\t\t\tif (output) {\n\t\t\t\t\t_.setValue(output, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy () {\n\t\tsuper.destroy();\n\t\tthis.originalEditorObserver?.destroy();\n\t}\n\n\tisDataNull(o) {\n\t\treturn super.isDataNull(o) || this._value === null || this._value === undefined;\n\t}\n\n\tgetData (o = {}) {\n\t\tvar env = {\n\t\t\tcontext: this,\n\t\t\toptions: o\n\t\t};\n\n\t\tif (this.isDataNull(o)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tenv.data = this.value;\n\n\t\tif (env.data === \"\" && (!this.templateValue || this.initialValue !== this.templateValue)) {\n\t\t\tenv.data = null;\n\t\t}\n\n\t\tif (this.inPath.length) {\n\t\t\tenv.data = Mavo.subset(this.data, this.inPath, env.data);\n\t\t}\n\n\t\tMavo.hooks.run(\"node-getdata-end\", env);\n\n\t\treturn env.data;\n\t}\n\n\t// Why this complexity? Because it needs to be a stack, so that\n\t// pause, pause, resume doesn't actually resume, you need to resume as many\n\t// times as you paused, so that nested function calls work as expected.\n\tget pausedObserver () {\n\t\treturn this.observerPauses?.length > 0;\n\t}\n\n\tpauseObserver () {\n\t\tMavo.observers.flush();\n\t\tthis.observerPauses = this.observerPauses || [];\n\t\tthis.observerPauses.push(1);\n\t}\n\n\tresumeObserver () {\n\t\tMavo.observers.flush();\n\t\tthis.observerPauses?.pop?.();\n\t}\n\n\tsave() {\n\t\tthis.savedValue = this.value;\n\t\tthis.unsavedChanges = false;\n\t}\n\n\t// Called only the first time this primitive is edited\n\tinitEdit () {\n\t\tif (!this.editor && this.originalEditor) {\n\t\t\tthis.editor = this.originalEditor.cloneNode(true);\n\t\t}\n\n\t\tthis.editorUpdated();\n\n\t\tthis.initEdit = null;\n\t}\n\n\tupdateOptions () {\n\t\tlet options = Mavo.options(this.element.getAttribute(\"mv-options\"), {map: true});\n\n\t\tfor (let [key, value] of options) {\n\t\t\tif (value === true) {\n\t\t\t\toptions.set(key, key);\n\t\t\t}\n\t\t}\n\n\t\tthis.options = options;\n\t}\n\n\tgenerateDefaultEditor () {\n\t\tif (this.element.hasAttribute(\"mv-options\")) {\n\t\t\tif (!this.options) {\n\t\t\t\tthis.updateOptions();\n\t\t\t}\n\n\t\t\tlet contents = [...this.options].map(([value, textContent]) => {\n\t\t\t\treturn { tag: \"option\", value, textContent };\n\t\t\t});\n\n\t\t\tthis.editor = $.create(\"select\", {\n\t\t\t\tclassName: \"mv-editor mv-options-select\",\n\t\t\t\tcontents\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\t// No editor provided, generate default for element type\n\t\t\t// Find default editor for datatype\n\t\t\tlet editor = this.config.editor;\n\n\t\t\tif (!editor || this.datatype == \"boolean\") {\n\t\t\t\teditor = Mavo.Elements.defaultConfig[this.datatype || \"string\"].editor;\n\t\t\t}\n\n\t\t\tthis.editor = $.create($.type(editor) === \"function\"? editor.call(this) : editor);\n\t\t}\n\n\t\tthis.editorValue = this.value;\n\t}\n\n\tupdateEditType() {\n\t\tlet ret = this.element.getAttribute(\"mv-edit-type\")?.trim() ?? \"auto\";\n\n\t\tif (ret === \"auto\") {\n\t\t\t// attribute may be \"auto\", in which case we want to get in here\n\t\t\tret = this.config.editType ?? \"auto\";\n\t\t}\n\n\t\tif (ret === \"auto\") {\n\t\t\tret = this.attribute? \"popup\" : \"inline\";\n\t\t}\n\n\t\treturn this.editType = ret;\n\t}\n\n\teditorUpdated () {\n\t\tif (!this.editor) {\n\t\t\tthis.generateDefaultEditor();\n\t\t}\n\n\t\t$.bind(this.editor, {\n\t\t\t\"input change\": evt => {\n\t\t\t\tthis.value = this.editorValue;\n\t\t\t},\n\t\t\t\"mv-change\": evt => {\n\t\t\t\tif (evt.property === \"output\") {\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t\t$.fire(this.editor, \"input\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet multiline = this.editor.matches(\"textarea\");\n\n\t\tif (!multiline) {\n\t\t\tthis.editor.addEventListener(\"focus\", evt => {\n\t\t\t\tthis.editor.select?.();\n\t\t\t});\n\t\t}\n\n\t\t// Copy any mv-editor-* attributes from the element to the editor\n\t\tfor (let name of Mavo.getAttributes(this.element, /^mv-editor-/)) {\n\t\t\tlet value = this.element.getAttribute(name);\n\t\t\tname = name.replace(/^mv-editor-/, \"\");\n\t\t\tthis.editor.setAttribute(name, value);\n\t\t}\n\n\t\tif (\"placeholder\" in this.editor && !this.editor.placeholder) {\n\t\t\tthis.editor.placeholder = this.editor.type === \"number\" ? this.editor.min || 0 : `(${this.label})`;\n\t\t}\n\n\t\tif (!this.editor.matches(\"select\")) {\n\t\t\tdelete this.options;\n\t\t}\n\t}\n\n\toriginalEditorUpdated ({force} = {}) {\n\t\tlet previousOriginalEditor = this.originalEditor;\n\t\tlet selector = this.element.getAttribute(\"mv-editor\");\n\n\t\ttry {\n\t\t\tthis.originalEditor = $(selector);\n\t\t}\n\t\tcatch (e) {\n\t\t\t// Invalid selector, potentially expression that has not yet evaluated?\n\t\t\tthis.originalEditor = null;\n\t\t}\n\n\t\tif (!force && previousOriginalEditor === this.originalEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.originalEditor) {\n\t\t\tif (this.editor) {\n\t\t\t\t// If editor already created, replace it and update value\n\t\t\t\tthis.editor = this.originalEditor.cloneNode(true);\n\t\t\t\tthis.setValue(this.value, {force: true, silent: true});\n\t\t\t}\n\n\t\t\tif (this.defaultSource == \"editor\") {\n\t\t\t\tthis.default = this.originalEditor.value;\n\t\t\t}\n\n\t\t\t// Update editor if original mutates\n\t\t\t// This means that expressions on mv-editor for individual collection items will not be picked up\n\t\t\t// We attach this observer to elements that are either the prototype of their kind, or they have a different original editor\n\t\t\tif (!this.template || this.originalEditor !== this.template.originalEditor) {\n\t\t\t\tthis.originalEditorObserver?.destroy();\n\n\t\t\t\tthis.originalEditorObserver = new Mavo.Observer(this.originalEditor, \"all\", records => {\n\t\t\t\t\tlet nodes = [this];\n\n\t\t\t\t\tif (this.copies) {\n\t\t\t\t\t\tfor (let n of this.copies) {\n\t\t\t\t\t\t\tif (n.originalEditor === this.originalEditor) {\n\t\t\t\t\t\t\t\tnodes.push(n);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let primitive of nodes) {\n\t\t\t\t\t\tprimitive.originalEditorUpdated({force: true});\n\t\t\t\t\t\tprimitive.setValue(primitive.value, {force: true, silent: true});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this.editor) {\n\t\t\t\tthis.generateDefaultEditor();\n\t\t\t\tthis.editorUpdated();\n\t\t\t}\n\t\t}\n\n\t\tlet editor = this.editor ?? this.originalEditor;\n\n\t\tif (editor?.matches(\"select:not(.mv-options-select\")) {\n\t\t\t// This is a select menu that is not automatically generated from mv-options\n\t\t\t// We need to update this.options\n\n\t\t\tlet obj = [...editor.options]\n\t\t\t\t.filter(o => !o.classList.contains(\"mv-volatile\"))\n\t\t\t\t.map(o => [o.value, o.textContent]);\n\t\t\tthis.options = new Map(obj);\n\t\t}\n\t}\n\n\tedit (o = {}) {\n\t\tlet wasEditing = this.editing;\n\n\t\tif (super.edit(o) === false) {\n\t\t\t// Invalid edit\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!o.force && wasEditing && !this.initEdit) {\n\t\t\t// Already being edited\n\t\t\treturn true;\n\t\t}\n\n\t\tif ($.type(this._value) === \"object\") {\n\t\t\t// Editing is disabled when value is an object (see #692)\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!wasEditing) {\n\t\t\t// Make element focusable, so it can actually receive focus\n\t\t\tif (this.element.tabIndex === -1) {\n\t\t\t\tMavo.revocably.setAttribute(this.element, \"tabindex\", \"0\");\n\t\t\t}\n\n\t\t\t// Prevent default actions while editing\n\t\t\t// e.g. following links, toggling <details> etc\n\t\t\t$.bind(this.element, \"click.mavo:edit\", evt => {\n\t\t\t\tif (this.mode !== \"edit\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (evt.target.closest(\"summary, a\")) {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (this.config.edit) {\n\t\t\tthis.config.edit.call(this);\n\t\t\tthis.initEdit = null;\n\t\t}\n\t\telse {\n\t\t\tthis.pauseObserver();\n\n\t\t\t// Actual edit\n\n\t\t\tif (this.initEdit) {\n\t\t\t\tthis.initEdit();\n\t\t\t}\n\n\t\t\tthis.editor.classList.toggle(\"mv-editor\", this.editType !== \"popup\");\n\n\t\t\tif (this.editType === \"popup\") {\n\t\t\t\tif (!this.popup) {\n\t\t\t\t\tthis.popup = new Mavo.UI.Popup(this);\n\t\t\t\t}\n\n\t\t\t\tthis.popup.prepare();\n\n\t\t\t\tlet events = \"mousedown focus dragover dragenter\".split(\" \").map(e => e + \".mavo:edit\").join(\" \");\n\n\t\t\t\t$.bind(this.element, events, _ => this.popup.show());\n\t\t\t}\n\t\t\telse if (this.editType === \"inline\") {\n\t\t\t\tif (!this.editor.isConnected) {\n\t\t\t\t\tthis.editorValue = this.value;\n\n\t\t\t\t\tif (this.config.hasChildren) {\n\t\t\t\t\t\tthis.element.textContent = \"\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_.setText(this.element, \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// If there's an expression on .textContent, it will kick\n\t\t\t\t\t// the editor out of the DOM next time it's updated.\n\t\t\t\t\t// To fix this, we re-assign it to the actual text node.\n\t\t\t\t\tif (!this.contentExpression) {\n\t\t\t\t\t\tthis.contentExpression = Mavo.DOMExpression.search(this.element, null);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.contentExpression) {\n\t\t\t\t\t\tthis.contentExpression.active = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.element.prepend(this.editor);\n\t\t\t\t}\n\n\t\t\t\tif (!this.collection) {\n\t\t\t\t\tMavo.revocably.restoreAttribute(this.element, \"tabindex\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.resumeObserver();\n\t\t}\n\n\t\tif (this.closestCollection && this.editType === \"inline\" && this.editor?.matches(Mavo.selectors.textInput)) {\n\t\t\t// If pasting text with line breaks and this is a single-line input\n\t\t\t// Insert them as multiple items\n\t\t\tlet multiline = this.editor.matches(\"textarea\");\n\n\t\t\tif (!multiline) {\n\t\t\t\t$.bind(this.editor, \"paste.mavo:edit\", evt => {\n\t\t\t\t\tif (!this.closestCollection.editing || !evt.clipboardData) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet text = evt.clipboardData.getData(\"text/plain\");\n\t\t\t\t\tconst CRLF = /\\r?\\n|\\r/;\n\n\t\t\t\t\tif (CRLF.test(text)) {\n\t\t\t\t\t\tevt.preventDefault();\n\n\t\t\t\t\t\tlet lines = text.split(CRLF);\n\n\t\t\t\t\t\t// \"Paste\" first line where the cursor is\n\t\t\t\t\t\tthis.editor.setRangeText(lines[0]);\n\t\t\t\t\t\t$.fire(this.editor, \"input\");\n\n\t\t\t\t\t\t// Insert the rest of the lines as new items\n\t\t\t\t\t\t// FIXME DRYfy the repetition between this code and the one below\n\t\t\t\t\t\tlet collection = this.closestCollection;\n\t\t\t\t\t\tlet index = closestItem?.index || 0;\n\n\t\t\t\t\t\tfor (let i=1; i<lines.length; i++) {\n\t\t\t\t\t\t\tlet closestItem = this.closestItem;\n\t\t\t\t\t\t\tlet next = collection.add(undefined, index + i);\n\t\t\t\t\t\t\tcollection.editItem(next); // TODO add() should take care of this\n\n\t\t\t\t\t\t\tlet copy = this.getCousin(i);\n\t\t\t\t\t\t\tcopy.render(lines[i]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t$.bind(this.editor, \"keydown.mavo:edit\", evt => {\n\t\t\t\tif (!this.closestCollection.editing) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (evt.key == \"Enter\" && (evt.shiftKey || !multiline)) {\n\t\t\t\t\tif (this.bottomUp) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet closestItem = this.closestItem;\n\t\t\t\t\tlet next = this.closestCollection.add(undefined, closestItem?.index + 1);\n\t\t\t\t\tthis.closestCollection.editItem(next);\n\n\t\t\t\t\tlet copy = this.getCousin(1);\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tcopy.edit();\n\t\t\t\t\t\tcopy.editor.focus();\n\t\t\t\t\t});\n\n\t\t\t\t\tif (multiline) {\n\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (evt.key == \"Backspace\" && this.empty) {\n\t\t\t\t\t// Focus on sibling afterwards\n\t\t\t\t\tlet sibling = this.getCousin(1) || this.getCousin(-1);\n\n\t\t\t\t\t// Backspace on empty primitive or Cmd/Ctrl + Backspace should delete item\n\t\t\t\t\tthis.closestCollection.delete(this.closestItem);\n\n\t\t\t\t\tif (sibling) {\n\t\t\t\t\t\tsibling.edit();\n\t\t\t\t\t\tsibling.editor.focus();\n\t\t\t\t\t}\n\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn true;\n\t} // edit\n\n\tdone (o) {\n\t\tif (super.done(o) === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$.unbind(this.element, \".mavo:edit\");\n\n\t\tthis.pauseObserver();\n\n\t\tif (this.config.done) {\n\t\t\tthis.config.done.call(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.editType === \"popup\") {\n\t\t\tthis.popup?.close();\n\t\t}\n\t\telse if (this.editType === \"inline\" && this.editor) {\n\t\t\tthis.editor.remove();\n\n\t\t\tif (this.contentExpression) {\n\t\t\t\t// This only works because nothing else sets active\n\t\t\t\t// Eventually, we'll need to move to a stack of some sort\n\t\t\t\t// to cater to cases where active was false before, so should be false after\n\t\t\t\tthis.contentExpression.active = true;\n\t\t\t\tthis.contentExpression.update({force: true});\n\t\t\t}\n\n\t\t\t// force: true is needed because otherwise setValue() aborts when it sees\n\t\t\t// that the value we are trying to set is the same as the existing one\n\t\t\tthis.setValue(this.editorValue, {silent: true, force: true});\n\t\t}\n\n\t\tif (this.editor?.matches(\"select\")) {\n\t\t\t// Remove any temp options that we dont need anymore\n\t\t\t$$(\".mv-volatile\", this.editor).forEach(o => {\n\t\t\t\tif (!o.selected) {\n\t\t\t\t\to.remove();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.resumeObserver();\n\n\t\tif (!this.collection) {\n\t\t\tMavo.revocably.restoreAttribute(this.element, \"tabindex\");\n\t\t}\n\t}\n\n\tdataRender (data, {live, root} = {}) {\n\t\tvar previousValue = this._value;\n\n\t\tif ($.type(data) === \"object\") {\n\t\t\tif (Symbol.toPrimitive in data) {\n\t\t\t\tdata = data[Symbol.toPrimitive](\"default\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Disable editing when the value is an object\n\t\t\t\t// We do that by calling .done() and then rejecting in .edit()\n\t\t\t\tif (this.editing) {\n\t\t\t\t\tthis.done();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data === undefined) {\n\t\t\t// New property has been added to the schema and nobody has saved since\n\t\t\tif (!this.modes && this.value === this.templateValue) {\n\t\t\t\tthis.value = this.closestCollection? this.default : this.templateValue;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.value = data;\n\t\t}\n\n\t\treturn this._value !== previousValue;\n\t}\n\n\tfind (property, o = {}) {\n\t\tif (this.property == property && o.exclude !== this) {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t/**\n\t * Get value from the DOM\n\t */\n\tgetValue (o) {\n\t\tif (this.editing && this.editor && this.editor !== this.element) {\n\t\t\treturn this.editorValue;\n\t\t}\n\n\t\treturn _.getValue(this.element, {\n\t\t\tconfig: this.config,\n\t\t\tattribute: this.attribute,\n\t\t\tdatatype: this.datatype\n\t\t});\n\t}\n\n\tsetValue (value, o = {}) {\n\t\tif (value === undefined) {\n\t\t\tvalue = null;\n\t\t}\n\n\t\tlet oldDatatype = this.datatype;\n\n\t\t// If there's no datatype, adopt that of the value\n\t\tif (!this.datatype && (typeof value == \"number\" || typeof value == \"boolean\")) {\n\t\t\tthis.datatype = typeof value;\n\t\t}\n\n\t\tvalue = _.safeCast(value, this.datatype);\n\n\t\tif (!o.force && value === this._value && oldDatatype == this.datatype) {\n\t\t\t// Do nothing if value didn't actually change, unless forced to\n\t\t\treturn value;\n\t\t}\n\n\t\tthis.pauseObserver();\n\n\t\tif (this.editor && this.editorValue != value) {\n\t\t\t// If an editor is present, set its value to match\n\t\t\tthis.editorValue = value;\n\t\t}\n\n\t\t// Also set DOM value if either using a popup, or there's no editor\n\t\t// or the editor is not inside the element (e.g. it could be a nested editor that is now detached)\n\t\tif (this.editType == \"popup\" || !this.editor || (this.editor !== document.activeElement && !this.element.contains(this.editor))) {\n\t\t\tif (this.config.setValue) {\n\t\t\t\tthis.config.setValue.call(this, this.element, value);\n\t\t\t}\n\t\t\telse if (!o.dataOnly) {\n\t\t\t\tlet presentational;\n\n\t\t\t\tif (this.options) {\n\t\t\t\t\tpresentational = this.options.get(value);\n\t\t\t\t}\n\n\t\t\t\t_.setValue(this.element, value, {\n\t\t\t\t\tconfig: this.config,\n\t\t\t\t\tattribute: this.attribute,\n\t\t\t\t\tdatatype: this.datatype,\n\t\t\t\t\tpresentational,\n\t\t\t\t\tnode: this\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.empty = !value && value !== 0;\n\n\t\tthis._value = value;\n\n\t\tthis.liveData.update();\n\n\t\tif (!o.silent) {\n\t\t\tif (this.saved) {\n\t\t\t\tthis.unsavedChanges = this.mavo.unsavedChanges = true;\n\t\t\t}\n\n\t\t\tthis.dataChanged(\"propertychange\", {value});\n\t\t}\n\n\t\tthis.resumeObserver();\n\n\t\treturn value;\n\t}\n\n\tdataChanged (action = \"propertychange\", o) {\n\t\treturn super.dataChanged(action, o);\n\t}\n\n\tasync upload (file, name = file.name) {\n\t\tif (!this.mavo.uploadBackend || !self.FileReader) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tempURL = URL.createObjectURL(file);\n\n\t\t// FIXME what if there's no attribute?\n\t\tthis.pauseObserver();\n\t\tthis.element.setAttribute(this.attribute, tempURL);\n\t\tthis.resumeObserver();\n\n\t\tvar path = this.element.getAttribute(\"mv-upload-path\") || \"\";\n\t\tvar relative = path + \"/\" + name;\n\n\t\tlet url = await this.mavo.upload(file, relative);\n\t\t// Do we have a URL override?\n\t\tvar base = Mavo.getClosestAttribute(this.element, \"mv-upload-url\");\n\n\t\tif (base) {\n\t\t\t// Throw away backend-provided URL and use the override instead\n\t\t\turl = new URL(relative, new URL(base, location)) + \"\";\n\t\t}\n\n\t\tthis.value = url;\n\n\t\tif (!this.element.matches(\"a\")) {\n\t\t\t// <a> should get the proper URL immediately, because hovering would reveal what it is\n\t\t\t// for other types, we should keep the temporary URL because the real one may not have deployed yet\n\t\t\t// If the editor is manually edited, this will change anyway\n\t\t\tthis.pauseObserver();\n\t\t\tthis.element.setAttribute(this.attribute, tempURL);\n\t\t\tthis.resumeObserver();\n\t\t}\n\t}\n\n\tcreateUploadPopup (type, kind = \"file\", ext) {\n\t\tvar env = { context: this, type, kind, ext };\n\n\t\tenv.mainInput = $.create(\"input\", {\n\t\t\t\"type\": \"url\",\n\t\t\t\"placeholder\": `http://example.com/${kind}.${ext}`,\n\t\t\t\"className\": \"mv-output\",\n\t\t\t\"aria-label\": `URL to ${kind}`\n\t\t});\n\n\t\tif (this.mavo.uploadBackend && self.FileReader) {\n\t\t\tvar checkType = file => file && (!type || file.type.indexOf(type.replace(\"*\", \"\")) === 0);\n\n\t\t\tenv.events = {\n\t\t\t\t\"paste\": evt => {\n\t\t\t\t\t// Look for the first file in the clipboard\n\t\t\t\t\tvar item = Array.from(evt.clipboardData.items).find(item => item.kind === \"file\");\n\t\t\t\t\tvar ext = item?.type.split(\"/\")[1];\n\n\t\t\t\t\tif (item && checkType(item)) {\n\t\t\t\t\t\t// Is a file of the correct type, upload!\n\t\t\t\t\t\t// First, try to find its name in the clipboard\n\t\t\t\t\t\tvar defaultName = evt.clipboardData.getData(\"text\") || `pasted-${kind}-${Date.now()}.${ext}`;\n\t\t\t\t\t\tvar name = prompt(this.mavo._(\"filename\"), defaultName);\n\n\t\t\t\t\t\tif (name === \"\") {\n\t\t\t\t\t\t\tname = defaultName;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (name !== null) {\n\t\t\t\t\t\t\tthis.upload(item.getAsFile(), name, type);\n\t\t\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"drag dragstart dragend dragover dragenter dragleave drop\": evt => {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t},\n\t\t\t\t\"dragover dragenter\": evt => {\n\t\t\t\t\tenv.popup.classList.add(\"mv-dragover\");\n\t\t\t\t\tthis.element.classList.add(\"mv-dragover\");\n\t\t\t\t},\n\t\t\t\t\"dragleave dragend drop\": evt => {\n\t\t\t\t\tenv.popup.classList.remove(\"mv-dragover\");\n\t\t\t\t\tthis.element.classList.remove(\"mv-dragover\");\n\t\t\t\t},\n\t\t\t\t\"drop\": evt => {\n\t\t\t\t\tvar file = evt.dataTransfer.files[0];\n\n\t\t\t\t\tif (file && checkType(file)) {\n\t\t\t\t\t\tthis.upload(file);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tMavo.hooks.run(\"primitive-createuploadpopup-beforecreate\", env);\n\n\t\t\tenv.popup = $.create({\n\t\t\t\tclassName: \"mv-upload-popup\",\n\t\t\t\tcontents: [\n\t\t\t\t\tenv.mainInput, {\n\t\t\t\t\t\ttag: \"input\",\n\t\t\t\t\t\ttype: \"file\",\n\t\t\t\t\t\t\"aria-label\": `Upload ${kind}`,\n\t\t\t\t\t\taccept: type,\n\t\t\t\t\t\tevents: {\n\t\t\t\t\t\t\tchange: evt => {\n\t\t\t\t\t\t\t\tvar file = evt.target.files[0];\n\n\t\t\t\t\t\t\t\tif (file && checkType(file)) {\n\t\t\t\t\t\t\t\t\tthis.upload(file);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\tclassName: \"mv-tip\",\n\t\t\t\t\t\tinnerHTML: \"<strong>Tip:</strong> You can also drag & drop or paste!\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tevents: env.events\n\t\t\t});\n\n\t\t\t// Drag & Drop should also work on the <img> element itself\n\t\t\t$.bind(this.element, env.events);\n\n\t\t\tMavo.hooks.run(\"primitive-createuploadpopup-beforereturn\", env);\n\n\t\t\treturn env.popup;\n\t\t}\n\t\telse {\n\t\t\treturn env.mainInput;\n\t\t}\n\t}\n\n\tstatic getText (element) {\n\t\tvar node = element.nodeType === Node.TEXT_NODE? element : element.firstChild;\n\n\t\tif (node?.nodeType === Node.TEXT_NODE) {\n\t\t\treturn node.nodeValue;\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\tstatic setText (element, text) {\n\t\tvar node = element.nodeType === Node.TEXT_NODE? element : element.firstChild;\n\n\t\tif (node?.nodeType === Node.TEXT_NODE) {\n\t\t\tnode.nodeValue = text;\n\t\t}\n\t\telse {\n\t\t\telement.prepend(text);\n\t\t}\n\t}\n\n\tstatic getValueAttribute (element, config = Mavo.Elements.search(element)) {\n\t\tvar ret = element.getAttribute(\"mv-attribute\") || config.attribute;\n\n\t\tif (!ret || ret === \"null\" || ret === \"none\") {\n\t\t\tret = null;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Only cast if conversion is lossless\n\t */\n\tstatic safeCast (value, datatype) {\n\t\tvar existingType = typeof value;\n\t\tvar cast = _.cast(value, datatype);\n\n\t\tif (datatype == \"boolean\") {\n\t\t\tif (!value) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (value === \"true\" || value > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (datatype == \"number\") {\n\t\t\tif (/^[-+]?[0-9.e]+$/i.test(value + \"\")) {\n\t\t\t\treturn cast;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (value === null || value === undefined) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn cast;\n\t}\n\n\t/**\n\t * Cast to a different primitive datatype\n\t */\n\tstatic cast (value, datatype) {\n\t\tswitch (datatype) {\n\t\t\tcase \"number\": return +value;\n\t\t\tcase \"boolean\": return !!value;\n\t\t\tcase \"string\": return value + \"\";\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic getValue (element, {config, attribute, datatype} = {}) {\n\t\tif (!config) {\n\t\t\tconfig = _.getConfig(element, attribute);\n\t\t}\n\n\t\tattribute = config.attribute;\n\t\tdatatype = config.datatype;\n\n\t\tif (config.getValue && attribute == config.attribute) {\n\t\t\treturn config.getValue(element);\n\t\t}\n\n\t\tvar ret;\n\n\t\tif (attribute in element && Mavo.usePropertyInsteadOfAttribute(element, attribute)) {\n\t\t\t// Returning properties (if they exist) instead of attributes\n\t\t\t// is needed for dynamic elements such as checkboxes, sliders etc\n\t\t\tret = element[attribute];\n\t\t}\n\t\telse if (attribute) {\n\t\t\tret = element.getAttribute(attribute);\n\t\t}\n\t\telse {\n\t\t\tret = element.getAttribute(\"content\") || _.getText(element) || null;\n\t\t}\n\n\t\treturn _.safeCast(ret, datatype);\n\t}\n\n\tstatic getConfig (element, attribute, datatype) {\n\t\tlet editAs = element.getAttribute(\"mv-edit-as\");\n\n\t\tif (editAs && editAs in Mavo.Elements) {\n\t\t\treturn Mavo.Elements[editAs];\n\t\t}\n\n\t\tif (attribute === undefined) {\n\t\t\tattribute = element.getAttribute(\"mv-attribute\") || undefined;\n\t\t}\n\n\t\tif (attribute == \"null\" || attribute == \"none\") {\n\t\t\tattribute = null;\n\t\t}\n\n\t\tvar isAttributeDefault = attribute === undefined || attribute == _.getValueAttribute(element);\n\n\t\tif (!datatype && isAttributeDefault) {\n\t\t\tdatatype = element.getAttribute(\"datatype\") || undefined;\n\t\t}\n\n\t\tvar config = Mavo.Elements.search(element, attribute, datatype);\n\t\tconfig = Object.assign({}, config);\n\n\t\tif (config.attribute === undefined) {\n\t\t\tconfig.attribute = attribute || null;\n\t\t}\n\n\t\tif (config.datatype === undefined) {\n\t\t\tconfig.datatype = datatype;\n\t\t}\n\n\t\treturn config;\n\t}\n\n\t// This is called both on primitive nodes to set their value,\n\t// as well as (primitive) expressions\n\tstatic async setValue (element, value, o = {}) {\n\t\tdelete _.pending.get(element)?.[o.attribute];\n\n\t\tif ($.type(value) === \"promise\") {\n\t\t\tif (!_.pending.has(element)) {\n\t\t\t\t_.pending.set(element, {});\n\t\t\t}\n\n\t\t\tlet pending = value;\n\t\t\t_.pending.get(element)[o.attribute] = pending;\n\n\t\t\ttry {\n\t\t\t\tvalue = await pending;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tvalue = e;\n\t\t\t}\n\n\t\t\tif (_.pending.get(element)[o.attribute] !== pending) {\n\t\t\t\t// Value has been superseded\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdelete _.pending.get(element)?.[o.attribute];\n\t\t}\n\n\t\tif (element.nodeType === 1) {\n\t\t\tif (!o.config) {\n\t\t\t\to.config = _.getConfig(element, o.attribute);\n\t\t\t}\n\n\t\t\to.attribute = o.attribute !== undefined? o.attribute : o.config.attribute;\n\t\t\to.datatype = o.datatype !== undefined? o.datatype : o.config.datatype;\n\n\t\t\tif (o.config.setValue && o.attribute == o.config.attribute) {\n\t\t\t\treturn o.config.setValue(element, value, o.attribute);\n\t\t\t}\n\t\t}\n\n\t\tif (value === null && !o.datatype) {\n\t\t\tvalue = \"\";\n\t\t}\n\n\t\tif (o.attribute) {\n\t\t\tif (o.attribute in element && Mavo.usePropertyInsteadOfAttribute(element, o.attribute) && element[o.attribute] !== value) {\n\t\t\t\t// Setting properties (if they exist) instead of attributes\n\t\t\t\t// is needed for dynamic elements such as checkboxes, sliders etc\n\t\t\t\ttry {\n\t\t\t\t\tvar previousValue = element[o.attribute];\n\t\t\t\t\tvar newValue = element[o.attribute] = value;\n\t\t\t\t}\n\t\t\t\tcatch (e) {}\n\t\t\t}\n\n\t\t\t// Set attribute anyway, even if we set a property because when\n\t\t\t// they're not in sync it gets really fucking confusing.\n\t\t\tif (o.datatype == \"boolean\") {\n\t\t\t\tif (value != element.hasAttribute(o.attribute)) {\n\t\t\t\t\t$.toggleAttribute(element, o.attribute, value, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (element.getAttribute(o.attribute) != value) {  // intentionally non-strict, e.g. \"3.\" !== 3\n\t\t\t\telement.setAttribute(o.attribute, value);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tvar presentational = o.presentational ?? _.format(value, o);\n\n\t\t\tif (o.node && !o.config.hasChildren) {\n\t\t\t\t_.setText(element, presentational);\n\t\t\t}\n\t\t\telse {\n\t\t\t\telement.textContent = presentational;\n\t\t\t}\n\n\t\t\tif (presentational !== value && element.setAttribute) {\n\t\t\t\telement.setAttribute(\"content\", value);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic format (value, o = {}) {\n\t\tif (($.type(value) === \"number\" || o.datatype == \"number\")) {\n\t\t\tif (value === null) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tvar skipNumberFormatting = o.attribute || o.element?.matches(\"style, pre\");\n\n\t\t\tif (!skipNumberFormatting) {\n\t\t\t\treturn _.formatNumber(value);\n\t\t\t}\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value.map(_.format).join(\", \");\n\t\t}\n\n\t\tif ($.type(value) === \"object\") {\n\t\t\t// Oops, we have an object. Print something more useful than [object Object]\n\t\t\treturn Mavo.toJSON(value);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic isFormControl(element) {\n\t\treturn element.matches(Mavo.selectors.formControl) || element.matches(`[mv-edit-as=\"formControl\"]`);\n\t}\n};\n\n$.Class(_, {\n\tlazy: {\n\t\temptyValue: function() {\n\t\t\tswitch (this.datatype) {\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn false;\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn \"\";\n\t\t},\n\n\t\teditorDefaults: function() {\n\t\t\treturn this.editor && _.getConfig(this.editor);\n\t\t},\n\n\t\teditType: function() {\n\t\t\treturn this.updateEditType();\n\t\t}\n\t},\n\n\tlive: {\n\t\teditor: function (value) {\n\t\t\tif (this._editor === value) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If we are editing the node, just setting this.editor won't help\n\t\t\t// we also need to update it in the DOM\n\t\t\tthis._editor?.replaceWith(value);\n\n\t\t\tthis._editor = value;\n\n\t\t\tif (this.defaultSource === \"editor\") {\n\t\t\t\tthis.default = this.editorValue;\n\t\t\t}\n\n\t\t\tthis.editorUpdated();\n\t\t},\n\n\t\tdefault: function (value) {\n\t\t\tif (this.value == this._default) {\n\t\t\t\tthis.value = value;\n\t\t\t}\n\t\t},\n\n\t\tvalue: function (value) {\n\t\t\treturn this.setValue(value);\n\t\t},\n\n\t\tdatatype: function (value) {\n\t\t\tif (value !== this._datatype) {\n\t\t\t\tif (value == \"boolean\" && !this.attribute) {\n\t\t\t\t\tthis.attribute = Mavo.Elements.defaultConfig.boolean.attribute;\n\t\t\t\t}\n\n\t\t\t\t$.toggleAttribute(this.element, \"datatype\", value, value && value !== \"string\");\n\t\t\t}\n\t\t},\n\n\t\tempty: function (value) {\n\t\t\tlet hide = value && // is empty\n\t\t\t           !this.modes && // and supports both modes\n\t\t\t           (!this.attribute || !$(Mavo.selectors.property, this.element)) && // and has no property inside\n\t\t\t\t\t   // and is not boolean OR if it is, its attribute is the default boolean attribute (see #464)\n\t\t\t           (this.datatype !== \"boolean\" || this.attribute === Mavo.Elements.defaultConfig.boolean.attribute);\n\n\t\t\tthis.element.classList.toggle(\"mv-empty\", !!hide);\n\t\t}\n\t},\n\n\tstatic: {\n\t\tall: new WeakMap(),\n\t\tpending: new Map(),\n\n\t\tlazy: {\n\t\t\tformatNumber: () => {\n\t\t\t\tvar numberFormat = new Intl.NumberFormat(Mavo.locale, {maximumFractionDigits:2});\n\n\t\t\t\treturn function(value) {\n\t\t\t\t\tif (value === Infinity || value === -Infinity) {\n\t\t\t\t\t\t// Pretty print infinity\n\t\t\t\t\t\treturn value < 0? \"-\" : \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn numberFormat.format(value);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n});\n\nMavo.observe({id: \"primitive\"}, function({node, type, attribute, record, element}) {\n\tif (node instanceof Mavo.Primitive && node.config && !node.pausedObserver) {\n\t\tif (attribute === \"mv-default\" && !node.defaultExpression) {\n\t\t\tnode.default = element.getAttribute(\"mv-default\");\n\t\t}\n\t\telse if (attribute === \"aria-label\") {\n\t\t\tnode.label = element.getAttribute(\"aria-label\");\n\n\t\t\tif (Mavo.in(\"placeholder\", node.editor)) {\n\t\t\t\tnode.editor.placeholder = node.editor.type === \"number\"? node.editor.min || 0 : `(${node.label})`;\n\t\t\t}\n\t\t}\n\t\telse if (attribute === \"mv-editor\") {\n\t\t\tnode.originalEditorUpdated();\n\t\t}\n\t\telse if (attribute === \"mv-edit-type\") {\n\t\t\tlet editing = node.editing;\n\n\t\t\tif (editing) {\n\t\t\t\t// Undo whatever editing UI we currently have\n\t\t\t\tnode.done({force: true});\n\t\t\t}\n\n\t\t\tnode.updateEditType();\n\n\t\t\tif (editing) {\n\t\t\t\tnode.edit({force: true});\n\t\t\t}\n\t\t}\n\t\telse if (attribute === \"mv-options\") {\n\t\t\tnode.updateOptions();\n\n\t\t\tif (node.editor) {\n\t\t\t\tnode.generateDefaultEditor();\n\t\t\t}\n\t\t}\n\t\telse if (attribute && attribute.indexOf(\"mv-editor-\") === 0) {\n\t\t\tnode.editor?.setAttribute(attribute.slice(10), element.getAttribute(attribute));\n\t\t}\n\t\telse if (node.config.observer !== false) {\n\t\t\t// Main value observer\n\t\t\tlet update = node.config.subtree; // always update when this flag is on regardless of what changed\n\n\t\t\tif (!update && (!node.editing || node.modes === \"edit\")) {\n\t\t\t\tupdate = attribute === node.attribute // note: these may be null\n\t\t\t\t         || node.config.observedAttributes?.includes(attribute)\n\t\t\t\t         || type === \"characterData\" && !node.attribute;\n\t\t\t}\n\n\t\t\tif (update) {\n\t\t\t\tnode.value = node.getValue();\n\t\t\t}\n\t\t}\n\t}\n\telse  {\n\t\tlet parentNode = Mavo.Node.getClosest(element.parentNode, true);\n\n\t\t// subtree changed on node for which we are monitoring this\n\t\t// primarily used for monitoring changes to <select> options\n\t\tif (parentNode?.config?.subtree) {\n\t\t\tparentNode.value = parentNode.getValue();\n\t\t}\n\n\t}\n});\n\nawait $.ready();\n\n// Migration from mv-edit-* to mv-editor-*\nlet inputTypes = [\n\t\"checkbox\", \"color\", \"date\", \"datetime-local\", \"email\", \"file\", \"month\", \"number\",\n\t\"password\", \"radio\", \"range\", \"search\", \"submit\", \"tel\", \"text\", \"time\", \"url\", \"week\", \"datetime\"];\nlet oldMvEdit = Mavo.attributeStartsWith(\"mv-edit-\")\n\t.filter(a => (a.name !== \"mv-edit-type\" || inputTypes.includes(a.value)) && ![\"mv-edit-as\"].includes(a.name))\n\t.map(a => a.name);\nlet newMvEdit = Mavo.attributeStartsWith(\"mv-editor-\");\n\nif ($(\"[mv-edit]\")) {\n\toldMvEdit.unshift(\"mv-edit\");\n}\n\nif (oldMvEdit.length > 0) {\n\tlet oldMvEditUnique = [...new Set(oldMvEdit)];\n\n\tfor (let name of oldMvEditUnique) {\n\t\tlet newName = name.replace(/^mv-edit(-|$)/, \"mv-editor$1\");\n\t\tlet elements = $$(`[${name}]`);\n\n\t\tconsole.log(`You are using attribute ${name} on ${elements.length} element(s). This syntax is deprecated and will be removed in the next version of Mavo. Please use ${newName} instead.`);\n\n\t\tfor (let element of elements) {\n\t\t\tMavo.setAttributeShy(element, newName, element.getAttribute(name));\n\t\t}\n\t}\n}\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.UI.Popup = $.Class({\n\tconstructor: function(primitive) {\n\t\tthis.primitive = primitive;\n\n\t\t// Need to be defined here so that this is what expected\n\t\tthis.position = evt => {\n\t\t\tvar bounds = this.primitive.element.getBoundingClientRect();\n\t\t\tvar x = bounds.left;\n\t\t\tvar y = bounds.bottom;\n\t\t\tvar pointDown = false;\n\n\t\t\tif (this.element.offsetHeight) {\n\t\t\t\t// Is in the DOM, check if it fits\n\t\t\t\tthis.height = this.element.getBoundingClientRect().height || this.height;\n\t\t\t}\n\n\t\t\tif (this.height + y + 20 > innerHeight) {\n\t\t\t\t// Normal positioning means the popup would be cut off or too close to the edge, adjust\n\n\t\t\t\t// Perhaps placing it above is better\n\t\t\t\tif (bounds.top - this.height > 20) {\n\t\t\t\t\tvar pointDown = true;\n\t\t\t\t\ty = bounds.top - this.height - 20;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Nah, just raise it a bit\n\t\t\t\t\ty = innerHeight - this.height - 20;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.element.classList.toggle(\"mv-point-down\", pointDown);\n\n\t\t\t$.style(this.element, { top:  `${y}px`, left: `${x}px` });\n\t\t};\n\n\t\tthis.element = $.create(\"div\", {\n\t\t\tclassName: \"mv-popup\",\n\t\t\thidden: true,\n\t\t\tcontents: {\n\t\t\t\ttag: \"fieldset\",\n\t\t\t\tcontents: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttag: \"legend\",\n\t\t\t\t\t\ttextContent: this.primitive.label + \":\"\n\t\t\t\t\t},\n\t\t\t\t\tthis.editor\n\t\t\t\t]\n\t\t\t},\n\t\t\tevents: {\n\t\t\t\tkeyup: evt => {\n\t\t\t\t\tif (evt.keyCode == 13 || evt.keyCode == 27) {\n\t\t\t\t\t\tif (this.element.contains(document.activeElement)) {\n\t\t\t\t\t\t\tthis.primitive.element.focus();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t\t\tthis.hide();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttransitionend: this.position\n\t\t\t}\n\t\t});\n\n\t\t// No point in having a dropdown in a popup\n\t\tif (this.editor.matches(\"select\")) {\n\t\t\tthis.editor.size = Math.min(10, this.editor.children.length);\n\t\t}\n\t\tthis.hideCallback = evt => {\n\t\t\tif (!this.element.contains(evt.target) && !this.primitive.element.contains(evt.target)) {\n\t\t\t\tthis.hide();\n\t\t\t}\n\t\t};\n\t},\n\n\tshow: function() {\n\t\t$.unbind([this.primitive.element, this.element], \".mavo:showpopup\");\n\n\t\tthis.shown = true;\n\n\t\tthis.element.style.transition = \"none\";\n\t\tthis.element.removeAttribute(\"hidden\");\n\n\t\tthis.position();\n\n\t\tthis.element.setAttribute(\"hidden\", \"\");\n\t\tthis.element.style.transition = \"\";\n\n\t\tdocument.body.appendChild(this.element);\n\n\t\tsetTimeout(() => {\n\t\t\tthis.element.removeAttribute(\"hidden\");\n\t\t}, 100); // trigger transition. rAF or timeouts < 100 don't seem to, oddly.\n\n\t\t$.bind(document, \"focus click\", this.hideCallback, true);\n\t\twindow.addEventListener(\"scroll\", this.position, {passive: true});\n\t},\n\n\thide: function() {\n\t\t$.unbind(document, \"focus click\", this.hideCallback, true);\n\t\twindow.removeEventListener(\"scroll\", this.position, {passive: true});\n\t\tthis.element.setAttribute(\"hidden\", \"\"); // trigger transition\n\t\tthis.shown = false;\n\n\t\tsetTimeout(() => {\n\t\t\t$.remove(this.element);\n\t\t}, parseFloat(getComputedStyle(this.element).transitionDuration) * 1000 || 400); // TODO transition-duration could override this\n\t},\n\n\tprepare: function() {\n\t\t$.bind(this.primitive.element, {\n\t\t\t\"click.mavo:edit\": evt => {\n\t\t\t\tthis.show();\n\t\t\t},\n\t\t\t\"keyup.mavo:edit\": evt => {\n\t\t\t\tif ([13, 113].indexOf(evt.keyCode) > -1) { // Enter or F2\n\t\t\t\t\tthis.show();\n\t\t\t\t\tthis.editor.focus();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (!this.element.contains(this.editor)) {\n\t\t\t// This can happen if edit type changes from popup to inline\n\t\t\tthis.element.append(this.editor);\n\t\t}\n\t},\n\n\tclose: function() {\n\t\tthis.hide();\n\t\t$.unbind(this.primitive.element, \".mavo:edit .mavo:preedit .mavo:showpopup\");\n\t},\n\n\tproxy: {\n\t\t\"editor\": \"primitive\"\n\t}\n});\n\n})(Bliss, Bliss.$);\n","/**\n * Configuration for different types of elements. Options:\n * - attribute {String}\n * - useProperty {Boolean}\n * - datatype {\"number\"|\"boolean\"|\"string\"} Default is \"string\"\n * - modes\n * - editor {Object|Function}\n * - setEditorValue temporary\n * - edit\n * - done\n * - observe\n * - default: If there is no attribute, can we use that rule to pick one?\n * @\n */\n(function($, $$) {\n\nvar _ = Mavo.Elements = {};\n\nObject.defineProperties(_, {\n\t\"register\": {\n\t\tvalue: function(id, config) {\n\t\t\tif (typeof arguments[0] === \"object\") {\n\t\t\t\t// Multiple definitions\n\t\t\t\tfor (let s in arguments[0]) {\n\t\t\t\t\t_.register(s, arguments[0][s]);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (config.extend) {\n\t\t\t\tvar base = _[config.extend];\n\n\t\t\t\tconfig = $.extend($.extend({}, base), config);\n\t\t\t}\n\n\t\t\tif (id.indexOf(\"@\") > -1) {\n\t\t\t\tvar parts = id.split(\"@\");\n\n\t\t\t\tconfig.selector = config.selector || parts[0] || \"*\";\n\n\t\t\t\tif (config.attribute === undefined) {\n\t\t\t\t\tconfig.attribute = parts[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconfig.selector = config.selector || id;\n\t\t\tconfig.id = id;\n\n\t\t\tif (Array.isArray(config.attribute)) {\n\t\t\t\tconfig.attribute.forEach(attribute => {\n\t\t\t\t\tvar o = $.extend({}, config);\n\t\t\t\t\to.attribute = attribute;\n\n\t\t\t\t\t_[`${id}@${attribute}`] = o;\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_[id] = config;\n\t\t\t}\n\n\t\t\treturn _;\n\t\t}\n\t},\n\t\"search\": {\n\t\tvalue: function(element, attribute, datatype) {\n\t\t\tvar matches = _.matches(element, attribute, datatype);\n\n\t\t\tif (matches.length === 0 && datatype) {\n\t\t\t\t// 0 matches, try again without datatype\n\t\t\t\tmatches = _.matches(element, attribute);\n\t\t\t}\n\n\t\t\tvar lastMatch = matches[matches.length - 1];\n\n\t\t\tif (lastMatch) {\n\t\t\t\treturn lastMatch;\n\t\t\t}\n\n\t\t\tvar config = $.extend({}, _.defaultConfig[datatype || \"string\"]);\n\t\t\tconfig.attribute = attribute === undefined? config.attribute : attribute;\n\n\t\t\treturn config;\n\t\t}\n\t},\n\t\"matches\": {\n\t\tvalue: function(element, attribute, datatype) {\n\t\t\tvar matches = [];\n\n\t\t\tselectorloop: for (var id in _) {\n\t\t\t\tvar o = _[id];\n\n\t\t\t\t// Passes attribute test?\n\t\t\t\tvar attributeMatches = attribute === undefined && o.default || attribute === o.attribute;\n\n\t\t\t\tif (!attributeMatches) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Passes datatype test?\n\t\t\t\tif (datatype !== undefined && datatype !== \"string\" && datatype !== o.datatype) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Passes selector test?\n\t\t\t\tvar selector = o.selector || id;\n\n\t\t\t\tif (!element.matches(selector)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Passes arbitrary test?\n\t\t\t\tif (o.test && !o.test(element, attribute, datatype)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// All tests have passed\n\t\t\t\tmatches.push(o);\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t}\n\t},\n\n\tisSVG: {\n\t\tvalue: e => e.namespaceURI == \"http://www.w3.org/2000/svg\"\n\t},\n\n\tdefaultConfig: {\n\t\tvalue: {\n\t\t\t\"string\":  {\n\t\t\t\teditor: { tag: \"input\" }\n\t\t\t},\n\t\t\t\"number\":  {\n\t\t\t\teditor: { tag: \"input\", type: \"number\" }\n\t\t\t},\n\t\t\t\"boolean\": {\n\t\t\t\tattribute: \"content\",\n\t\t\t\teditor: { tag: \"input\", type: \"checkbox\" }\n\t\t\t}\n\t\t}\n\t}\n});\n\n_.register({\n\t\"@hidden\": {\n\t\tdatatype: \"boolean\"\n\t},\n\n\t\"@y\": {\n\t\ttest: _.isSVG,\n\t\tdatatype: \"number\"\n\t},\n\n\t\"@x\": {\n\t\tdefault: true,\n\t\ttest: _.isSVG,\n\t\tdatatype: \"number\"\n\t},\n\n\t\"media\": {\n\t\tdefault: true,\n\t\tselector: \"img, video, audio\",\n\t\tattribute: \"src\",\n\t\teditor: function() {\n\t\t\tvar kind = this.element.nodeName.toLowerCase();\n\t\t\tkind = kind == \"img\"? \"image\" : kind;\n\t\t\tMavo.setAttributeShy(this.element, \"mv-upload-path\", kind + \"s\");\n\n\t\t\treturn this.createUploadPopup(kind + \"/*\", kind, \"png\");\n\t\t}\n\t},\n\n\t\"a, link\": {\n\t\tdefault: true,\n\t\tattribute: \"href\"\n\t},\n\n\t\"a[mv-upload-path], link[mv-upload-path]\": {\n\t\tdefault: true,\n\t\tattribute: \"href\",\n\t\teditor: function() {\n\t\t\tvar type = this.element.getAttribute(\"type\");\n\t\t\tvar ext = type && !/\\/\\*$/.test(type)? type.split(\"/\")[1] : \"pdf\";\n\t\t\treturn this.createUploadPopup(type, undefined, ext);\n\t\t}\n\t},\n\n\t\"video, audio\": {\n\t\tattribute: [\"autoplay\", \"buffered\", \"loop\"],\n\t\tdatatype: \"boolean\"\n\t},\n\n\t\"details\": {\n\t\tattribute: \"open\",\n\t\tdatatype: \"boolean\"\n\t},\n\n\t\"input, select, button, textarea\": {\n\t\tattribute: \"disabled\",\n\t\tdatatype: \"boolean\"\n\t},\n\n\t\"formControl\": {\n\t\tselector: \"input\",\n\t\tdefault: true,\n\t\tattribute: \"value\",\n\t\tmodes: \"edit\",\n\t\teditType: \"self\",\n\t\tchangeEvents: \"input change\",\n\t\tedit: () => {},\n\t\tdone: () => {},\n\t\tinit: function() {\n\t\t\tthis._editor = this.element;\n\t\t}\n\t},\n\n\t\"select\": {\n\t\textend: \"formControl\",\n\t\tselector: \"select\",\n\t\tsubtree: true\n\t},\n\n\t\"select[multiple]\": {\n\t\textend: \"select\",\n\t\tselector: \"select[multiple]\",\n\t\tgetValue: element => {\n\t\t\treturn Array.from(element.selectedOptions).map(option => option.value).join();\n\t\t},\n\t\tsetValue: (element, value) => {\n\t\t\t// Why +\"\"? If the value is being set via mv-value and is a number,\n\t\t\t// we must convert it to a string to avoid extra checks.\n\t\t\tvalue = Array.isArray(value)? value : (value + \"\").split(/\\s*,/);\n\n\t\t\tArray.from(element.options).forEach(option => {\n\t\t\t\t// Why? If the value is being set via mv-value,\n\t\t\t\t// we want the element to reflect the changes properly.\n\t\t\t\toption.selected = false;\n\n\t\t\t\t// Why +\"\"? Options' values are strings, so we want \"1\" instead of 1.\n\t\t\t\tvalue = value.map(v => v + \"\");\n\n\t\t\t\tif (value.includes(option.value)) {\n\t\t\t\t\toption.selected = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t\"option\": {\n\t\tattribute: null,\n\t\tmodes: \"read\",\n\t\tdefault: true\n\t},\n\n\t\"textarea\": {\n\t\textend: \"formControl\",\n\t\tselector: \"textarea\",\n\t\tattribute: null,\n\t\tgetValue: element => element.value,\n\t\tsetValue: (element, value) => element.value = value\n\t},\n\n\t\"formNumber\": {\n\t\textend: \"formControl\",\n\t\tselector: \"input[type=range], input[type=number]\",\n\t\tdatatype: \"number\",\n\t\tsetValue: function(element, value) {\n\t\t\telement.value = value;\n\t\t\telement.setAttribute(\"value\", value);\n\n\t\t\tvar attribute = value > element.value? \"max\" : \"min\";\n\n\t\t\tif (!isNaN(value) && element.value != value && !Mavo.data(element, \"boundObserver\")) {\n\t\t\t\t// Value out of bounds, maybe race condition? See #295\n\t\t\t\t// Observe min/max attrs until user interaction or data change\n\t\t\t\tif (Mavo.observers.find({element, id: \"oob\"}).size === 0) {\n\t\t\t\t\tMavo.observe({\n\t\t\t\t\t\tid: \"oob\",\n\t\t\t\t\t\telement, attribute,\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}, () => element.value = value);\n\t\t\t\t}\n\n\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t$.bind(element, \"input mv-change\", function handler() {\n\t\t\t\t\t\tMavo.unobserve({element, id: \"oob\"});\n\n\t\t\t\t\t\t// Why not just use {once: true}? because we have two events\n\t\t\t\t\t\t$.unbind(element, \"input mv-change\", handler);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tobservedAttributes: [\"min\", \"max\"]\n\t},\n\n\t\"checkbox\": {\n\t\textend: \"formControl\",\n\t\tselector: \"input[type=checkbox]\",\n\t\tattribute: \"checked\",\n\t\tdatatype: \"boolean\",\n\t\tchangeEvents: \"click\"\n\t},\n\n\t\"input[type=checkbox]\": {\n\t\tattribute: \"indeterminate\",\n\t\tdatatype: \"boolean\"\n\t},\n\n\t\"radio\": {\n\t\textend: \"formControl\",\n\t\tselector: \"input[type=radio]\",\n\t\tattribute: \"checked\",\n\t\tmodes: \"edit\",\n\t\tgetValue: element => {\n\t\t\tif (element.form) {\n\t\t\t\treturn element.form[element.name].value;\n\t\t\t}\n\n\t\t\tlet checked = $(`input[type=radio][name=\"${element.name}\"]:checked`);\n\t\t\treturn checked && checked.value;\n\t\t},\n\t\tsetValue: (element, value) => {\n\t\t\tif (element.form) {\n\t\t\t\telement.form[element.name].value = value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet toCheck = $(`input[type=radio][name=\"${element.name}\"][value=\"${value}\"]`);\n\t\t\tif (toCheck) {\n\t\t\t\ttoCheck.checked = true;\n\t\t\t}\n\t\t},\n\t\tinitOnce: function(element) {\n\t\t\tfunction radioChanged(radio) {\n\t\t\t\tlet name = radio.name;\n\t\t\t\tfor (let otherRadio of $$(`input[type=radio][name=\"${radio.name}\"]`)) {\n\t\t\t\t\tlet node = Mavo.Node.get(otherRadio, true);\n\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnode.value = node.getValue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdocument.addEventListener(\"change\", evt => {\n\t\t\t\tif (evt.target.matches(\"input[type=radio]\")) {\n\t\t\t\t\tradioChanged(evt.target);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMavo.observe({\n\t\t\t\tattribute: \"value\",\n\t\t\t\tselector: \"input[type=radio]\"\n\t\t\t}, r => radioChanged(r.element));\n\t\t},\n\t\tobservedAttributes: [\"value\"]\n\t},\n\n\t\"counter\": {\n\t\textend: \"formControl\",\n\t\tselector: \"button, .counter\",\n\t\tattribute: \"mv-clicked\",\n\t\tdatatype: \"number\",\n\t\tinit: function(element) {\n\t\t\tif (this.attribute === \"mv-clicked\") {\n\t\t\t\telement.setAttribute(\"mv-clicked\", \"0\");\n\n\t\t\t\telement.addEventListener(\"click\", evt => {\n\t\t\t\t\tlet clicked = +element.getAttribute(\"mv-clicked\") || 0;\n\t\t\t\t\tthis.value = ++clicked;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\n\t\"meter\": {\n\t\tdefault: true,\n\t\tselector: \"meter, progress\",\n\t\tattribute: \"value\",\n\t\tdatatype: \"number\",\n\t\tedit: function() {\n\t\t\tlet min = this.element.min ?? this.element.getAttribute(\"min\") ?? 0;\n\t\t\tlet max = this.element.max ?? this.element.getAttribute(\"max\") ?? 1;\n\n\t\t\tmin = +min;\n\t\t\tmax = +max;\n\t\t\tlet range = max - min;\n\n\t\t\tlet step = this.element.step ?? this.element.getAttribute(\"step\")\n\t\t\t         ?? this.element.getAttribute(\"mv-editor-step\") ?? (range > 1? 1 : range/100);\n\t\t\tstep = +step;\n\n\t\t\t$.bind(this.element, \"mousemove.mavo:edit\", evt => {\n\t\t\t\t// Change property as mouse moves\n\t\t\t\tvar left = this.element.getBoundingClientRect().left;\n\t\t\t\tvar offset = Math.max(0, (evt.clientX - left) / this.element.offsetWidth);\n\t\t\t\tvar newValue = min + range * offset;\n\t\t\t\tvar mod = newValue % step;\n\n\t\t\t\tnewValue += mod > step/2? step - mod : -mod;\n\t\t\t\tnewValue = Math.max(min, Math.min(newValue, max));\n\n\t\t\t\tthis.pauseObserver();\n\t\t\t\tthis.element.setAttribute(\"value\", newValue);\n\t\t\t\tthis.resumeObserver();\n\t\t\t});\n\n\t\t\t$.bind(this.element, \"mouseleave.mavo:edit\", evt => {\n\t\t\t\t// Return to actual value\n\t\t\t\tthis.pauseObserver();\n\t\t\t\tthis.element.setAttribute(\"value\", this.value);\n\t\t\t\tthis.resumeObserver();\n\t\t\t});\n\n\t\t\t$.bind(this.element, \"click.mavo:edit\", evt => {\n\t\t\t\t// Register change\n\t\t\t\tthis.value = this.getValue();\n\t\t\t});\n\n\t\t\t$.bind(this.element, \"keydown.mavo:edit\", evt => {\n\t\t\t\t// Edit with arrow keys\n\t\t\t\tif (evt.target == this.element && (evt.keyCode == 37 || evt.keyCode == 39)) {\n\t\t\t\t\tvar increment = step * (evt.keyCode == 39? 1 : -1) * (evt.shiftKey? 10 : 1);\n\t\t\t\t\tvar newValue = this.value + increment;\n\t\t\t\t\tnewValue = Math.max(min, Math.min(newValue, max));\n\n\t\t\t\t\tthis.element.setAttribute(\"value\", newValue);\n\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tobservedAttributes: [\"min\", \"max\"]\n\t},\n\n\t\"meta\": {\n\t\tdefault: true,\n\t\tattribute: \"content\"\n\t},\n\n\t\"block\": {\n\t\tdefault: true,\n\t\tselector: \"p, div, dt, dd, h1, h2, h3, h4, h5, h6, article, section, address, pre\",\n\t\teditor: function() {\n\t\t\tvar cs = getComputedStyle(this.element);\n\t\t\tvar display = cs.display;\n\t\t\tvar tag = display.indexOf(\"inline\") === 0? \"input\" : \"textarea\";\n\t\t\tvar editor = $.create(tag);\n\n\t\t\tif (tag == \"textarea\") {\n\t\t\t\t// Actually multiline\n\t\t\t\tvar width = this.element.offsetWidth;\n\n\t\t\t\tif (width) {\n\t\t\t\t\teditor.width = width;\n\t\t\t\t}\n\n\t\t\t\t// We cannot collapse whitespace because then users\n\t\t\t\t// are adding characters they dont see (#300).\n\t\t\t\teditor.style.whiteSpace = ({\n\t\t\t\t\t\"normal\": \"pre-wrap\",\n\t\t\t\t\t\"nowrap\": \"pre\"\n\t\t\t\t})[cs.whiteSpace] || \"inherit\";\n\t\t\t}\n\n\t\t\treturn editor;\n\t\t},\n\n\t\tsetEditorValue: function(value) {\n\t\t\tif (this.datatype && this.datatype != \"string\") {\n\t\t\t\tvalue = value + \"\";\n\t\t\t}\n\n\t\t\tvar cs = getComputedStyle(this.element);\n\t\t\tvalue = value || \"\";\n\n\t\t\tif ([\"normal\", \"nowrap\"].indexOf(cs.whiteSpace) > -1) {\n\t\t\t\t// Collapse lines\n\t\t\t\tvalue = value.replace(/\\r?\\n/g, \" \");\n\t\t\t}\n\n\t\t\tif ([\"normal\", \"nowrap\", \"pre-line\"].indexOf(cs.whiteSpace) > -1) {\n\t\t\t\t// Collapse whitespace\n\t\t\t\tvalue = value.replace(/^[ \\t]+|[ \\t]+$/gm, \"\").replace(/[ \\t]+/g, \" \");\n\t\t\t}\n\n\t\t\tthis.editor.value = value;\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t\"time\": {\n\t\tattribute: \"datetime\",\n\t\tdefault: true,\n\t\tinit: function() {\n\t\t\tif (!this.fromTemplate(\"dateType\")) {\n\t\t\t\t// Is there an existing formatting expression within?\n\t\t\t\tvar dateFormat = Mavo.DOMExpression.search(this.element, null);\n\t\t\t\tvar datetime = this.element.getAttribute(\"datetime\") || \"YYYY-MM-DD\";\n\n\t\t\t\tlet editorType = this.element.getAttribute(\"mv-editor-type\");\n\t\t\t\tif (editorType in this.config.dateTypes) {\n\t\t\t\t\tthis.dateType = editorType;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (let type in this.config.dateTypes) {\n\t\t\t\t\t\tif (this.config.dateTypes[type].test(datetime)) {\n\t\t\t\t\t\t\tthis.dateType = type;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!dateFormat) {\n\t\t\t\t\t// TODO what about mv-expressions?\n\t\t\t\t\tthis.element.textContent = this.config.defaultFormats[this.dateType]?.(this.property) ?? \"\";\n\t\t\t\t\tthis.mavo.expressions.extract(this.element, null);\n\n\t\t\t\t\tif (dateFormat = Mavo.DOMExpression.search(this.element, null)) {\n\t\t\t\t\t\tthis.mavo.treeBuilt.then(() => {\n\t\t\t\t\t\t\tdateFormat.update();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdateTypes: {\n\t\t\t\"month\": /^[Y\\d]{4}-[M\\d]{2}$/i,\n\t\t\t\"time\": /^[H\\d]{2}:[M\\d]{2}/i,\n\t\t\t\"datetime-local\": /^[Y\\d]{4}-[M\\d]{2}-[D\\d]{2} [H\\d]{2}:[Mi\\d]{2}/i,\n\t\t\t\"date\": /^[Y\\d]{4}-[M\\d]{2}-[D\\d]{2}$/i,\n\t\t},\n\t\tdefaultFormats: {\n\t\t\t\"date\": name => `[readable_datetime(${name}, \"days\")]`,\n\t\t\t\"month\": name => `[readable_datetime(${name}, 'months')] `,\n\t\t\t\"time\": name => `[time(${name})]`,\n\t\t\t\"time\": name => `[hour(${name}, '00')]:[minute(${name}, '00')]`,\n\t\t\t\"datetime-local\": function(name) {\n\t\t\t\treturn this.date(name) + \" \" + this.time(name);\n\t\t\t}\n\t\t},\n\t\teditor: function() {\n\t\t\treturn {tag: \"input\", type: this.dateType};\n\t\t}\n\t},\n\n\t\"circle@r\": {\n\t\tdefault: true,\n\t\tdatatype: \"number\"\n\t},\n\n\t\"circle\": {\n\t\tattribute: [\"cx\", \"cy\"],\n\t\tdatatype: \"number\"\n\t},\n\n\t\"text\": {\n\t\tdefault: true,\n\t\teditType: \"popup\"\n\t},\n\n\t\".mv-toggle\": {\n\t\tdefault: true,\n\t\tattribute: \"aria-checked\",\n\t\tdatatype: \"boolean\",\n\t\tedit: function() {\n\t\t\tMavo.revocably.setAttribute(this.element, \"role\", \"checkbox\");\n\n\t\t\t$.bind(this.element, \"click.mavo:edit keyup.mavo:edit keydown.mavo:edit\", evt => {\n\t\t\t\tif (evt.type == \"click\" || evt.key == \" \" || evt.key == \"Enter\") {\n\t\t\t\t\tif (evt.type != \"keydown\") {\n\t\t\t\t\t\tthis.value = !this.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdone: function() {\n\t\t\tMavo.revocably.restoreAttribute(this.element, \"role\");\n\n\t\t\t$.unbind(this.element, \".mavo:edit\");\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nMavo.attributes.push(\"mv-list\", \"mv-list-item\", \"mv-order\", \"mv-accepts\", \"mv-initial-items\");\n\nvar _ = Mavo.Collection = class Collection extends Mavo.Node {\n\tconstructor (element, mavo, o) {\n\t\tsuper(element, mavo, o);\n\n\t\t/*\n\t\t * Create the template, remove it from the DOM and store it\n\t\t */\n\n\t\tthis.firstItemElement = this.templateElement = $(Mavo.selectors.multiple, this.element);\n\n\t\tthis.children = [];\n\t\tthis.liveData = new Mavo.Data(this, []);\n\n\t\t// Keep position of the template in the DOM, since we might remove it\n\t\tthis.marker = document.createComment(\"mv-marker\");\n\t\tMavo.data(this.marker, \"collection\", this);\n\n\t\tthis.templateElement.after(this.marker);\n\t\tthis.addButton = this.createAddButton();\n\n\t\tif (this.templateElement.hasAttribute(\"mv-like\")) {\n\t\t\tMavo.warn(\"@mv-like is deprecated and will be removed in the next version of Mavo\");\n\t\t}\n\n\t\tif (!this.fromTemplate(\"templateElement\", \"accepts\", \"initialItems\")) {\n\t\t\tthis.accepts = this.element.getAttribute(\"mv-accepts\");\n\t\t\tthis.accepts = new Set(this.accepts?.split(/\\s+/));\n\n\t\t\tthis.initialItems = +(this.element.getAttribute(\"mv-initial-items\") || 1);\n\n\t\t\t// Must clone because otherwise once expressions are parsed on the template element\n\t\t\t// we will not be able to pick them up from subsequent items\n\n\t\t\tthis.templateElement = this.templateElement.cloneNode(true);\n\t\t}\n\n\t\tthis.initializeData();\n\n\t\tthis.postInit();\n\n\t\tMavo.hooks.run(\"collection-init-end\", this);\n\t}\n\n\tinitializeData () {\n\t\tlet item = this.add(this.firstItemElement, undefined, {silent: true});\n\n\t\tif (this.initialItems === 0) {\n\t\t\tif (item) {\n\t\t\t\tthis.delete(item, {silent: true});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No item to delete\n\t\t\t\tthis.firstItemElement.remove();\n\t\t\t}\n\t\t}\n\t\telse if (this.initialItems > 1) {\n\t\t\t// Add extra items\n\t\t\tfor (let i=1; i<this.initialItems; i++) {\n\t\t\t\tthis.add();\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateAddButton() {\n\t\t// Find add button if provided, or generate one\n\t\tvar selector = `button[class~=\"mv-add-${this.property}\"]`;\n\t\tvar group = this.parentGroup.element;\n\n\t\tvar button = $$(selector, group).filter(button => {\n\t\t\treturn !this.element.contains(button)  // is outside the list element\n\t\t\t\t&& !Mavo.data(button, \"collection\"); // and does not belong to another collection\n\t\t})[0];\n\n\t\tif (button) {\n\t\t\t// Custom add button\n\t\t\tif (button.compareDocumentPosition(this.marker) & Node.DOCUMENT_POSITION_FOLLOWING) {\n\t\t\t\t// Button precedes collection, make collection bottom-up if no mv-order is set\n\t\t\t\tMavo.setAttributeShy(this.templateElement, \"mv-order\", \"desc\");\n\t\t\t}\n\n\t\t\tMavo.revocably.remove(button);\n\t\t}\n\t\telse {\n\t\t\tbutton = $.create(\"button\", {\n\t\t\t\ttype: \"button\",\n\t\t\t\tclassName: \"mv-ui\",\n\t\t\t\ttextContent: this.mavo._(\"add-item\", this)\n\t\t\t});\n\t\t};\n\n\t\tbutton.classList.add(\"mv-add\", `mv-add-${this.property}`);\n\t\tMavo.data(button, \"collection\", this);\n\n\t\tMavo.setAttributeShy(button, \"mv-action\", `add(${this.property})`);\n\n\t\treturn button;\n\t}\n\n\tget length() {\n\t\treturn this.children.length;\n\t}\n\n\tgetData (o = {}) {\n\t\tvar env = {\n\t\t\tcontext: this,\n\t\t\toptions: o\n\t\t};\n\n\t\tenv.data = this.children.map(item => item.getData(env.options))\n\t\t                     .filter(itemData => Mavo.value(itemData) !== null);\n\t\tenv.data = Mavo.subset(this.data, this.inPath, env.data);\n\n\t\tMavo.hooks.run(\"node-getdata-end\", env);\n\n\t\treturn env.data;\n\t}\n\n\t// Create item but don't insert it anywhere\n\t// Mostly used internally\n\tcreateItem (element) {\n\t\tif (!element) {\n\t\t\telement = this.templateElement.cloneNode(true);\n\t\t}\n\n\t\tvar template = this.itemTemplate || this.template?.itemTemplate || null;\n\n\t\tvar item = Mavo.Node.create(element, this.mavo, {\n\t\t\tcollection: this,\n\t\t\ttemplate,\n\t\t\tproperty: this.property,\n\t\t\ttype: this.type\n\t\t});\n\n\t\tif (!this.itemTemplate) {\n\t\t\tthis.itemTemplate = template || item;\n\t\t}\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Add a new item to this collection\n\t * @param item {Node|Mavo.Node} Optional. Element or Mavo object for the new item\n\t * @param index {Number} Optional. Index of existing item, will be added opposite to list direction\n\t * @param silent {Boolean} Optional. Throw a datachange event? Mainly used internally.\n\t */\n\tadd (item, index, o = {}) {\n\t\tif (item instanceof Node) {\n\t\t\titem = Mavo.Node.get(item) || this.createItem(item);\n\t\t}\n\t\telse {\n\t\t\titem = item || this.createItem();\n\t\t}\n\n\t\tif (item.collection != this) {\n\t\t\t// Move item to this collection from elsewhere\n\t\t\tif (item.collection) {\n\t\t\t\t// It belongs to another collection, delete from there first\n\t\t\t\titem.collection.splice({remove: item});\n\t\t\t\titem.collection.dataChanged(\"delete\");\n\t\t\t}\n\n\t\t\t// FIXME this only includes saved data\n\t\t\t// Expressions can be recalculated, but writeable data that is simply not saved will not be here\n\t\t\tlet data = item.getData();\n\t\t\tlet editing = item.editing;\n\t\t\titem.element.remove();\n\t\t\titem.destroy();\n\n\t\t\titem = this.createItem();\n\n\t\t\tif (editing) {\n\t\t\t\tthis.editItem(item);\n\t\t\t}\n\n\t\t\titem.render(data);\n\t\t}\n\n\t\tif (index === undefined) {\n\t\t\tindex = this.bottomUp? 0 : this.length;\n\t\t}\n\n\t\t// Add it to the DOM, or fix its place\n\t\tvar rel = this.children?.[index]?.element ?? this.marker;\n\t\t$.before(item.element, rel);\n\n\t\tvar env = {context: this, item};\n\n\t\tenv.previousIndex = item.index;\n\n\t\t// Update internal data model\n\t\tenv.changed = this.splice({\n\t\t\tremove: env.item\n\t\t}, {\n\t\t\tindex: index,\n\t\t\tadd: env.item\n\t\t});\n\n\t\tif (this.mavo.expressions.active && !o.silent) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tenv.changed.forEach(i => {\n\t\t\t\t\ti.dataChanged(i == env.item && env.previousIndex === undefined? \"add\" : \"move\");\n\t\t\t\t\ti.unsavedChanges = true;\n\t\t\t\t});\n\n\t\t\t\tthis.unsavedChanges = this.mavo.unsavedChanges = true;\n\n\t\t\t\tthis.mavo.expressions.update(env.item);\n\t\t\t});\n\t\t}\n\n\t\tMavo.hooks.run(\"collection-add-end\", env);\n\n\t\treturn env.item;\n\t}\n\n\tsplice (...actions) {\n\t\tactions.forEach(action => {\n\t\t\tif (action.index === undefined && action.remove && isNaN(action.remove)) {\n\t\t\t\t// Remove is an item\n\t\t\t\taction.index = this.children.indexOf(action.remove);\n\t\t\t\taction.remove = 1;\n\t\t\t}\n\t\t});\n\n\t\t// Sort in reverse index order\n\t\tactions.sort((a, b) => b.index - a.index);\n\n\t\tvar changed = [], deleted = [];\n\n\t\t// FIXME this could still result in buggy behavior.\n\t\t// Think of e.g. adding items on i, then removing > 1 items on i-1.\n\t\t// The new items would get removed instead of the old ones.\n\t\t// Not a pressing issue though since we always remove 1 max when adding things too.\n\t\tactions.forEach(action => {\n\t\t\tif (action.index > -1 && (action.remove || action.add)) {\n\t\t\t\taction.remove = action.remove || 0;\n\t\t\t\taction.add = Mavo.toArray(action.add);\n\t\t\t\tdeleted.push(...this.children.splice(action.index, +action.remove, ...action.add));\n\t\t\t}\n\t\t});\n\n\t\tdeleted = new Set(deleted);\n\n\t\t// Update indices\n\t\tfor (let i = 0; i < this.length; i++) {\n\t\t\tlet item = this.children[i];\n\t\t\tdeleted.delete(item);\n\n\t\t\tif (item && item.index !== i) {\n\t\t\t\titem.index = i;\n\t\t\t\tchanged.push(item);\n\t\t\t}\n\t\t}\n\n\t\t// Unregister expressions for deleted items\n\t\tdeleted.forEach(item => {\n\t\t\titem.expressions?.forEach(domexpression => {\n\t\t\t\titem.mavo.expressions.unregister(domexpression);\n\t\t\t});\n\t\t});\n\n\t\tthis.liveData.update();\n\n\t\treturn changed;\n\t}\n\n\tasync delete (item, {silent, undoable = !silent, transition = !silent, destroy = !undoable} = {}) {\n\t\titem.element.classList.remove(\"mv-highlight\");\n\n\t\tthis.splice({remove: item});\n\n\t\tif (!silent && transition) {\n\t\t\tawait $.transition(item.element, {opacity: 0});\n\t\t\titem.element.style.opacity = \"\";\n\t\t}\n\n\t\t$.remove(item.element);\n\n\t\tif (!silent) {\n\t\t\tthis.unsavedChanges = item.unsavedChanges = this.mavo.unsavedChanges = true;\n\n\t\t\titem.collection.dataChanged(\"delete\", {index: item.index});\n\t\t}\n\n\t\tif (undoable) {\n\t\t\tthis.mavo.setDeleted(item);\n\t\t}\n\t\telse if (destroy) {\n\t\t\titem.destroy();\n\t\t}\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Move existing item to a new position. Wraps around if position is out of bounds.\n\t * @offset relative position\n\t */\n\tmove (item, offset) {\n\t\tvar index = item.index + offset + (offset > 0);\n\n\t\tindex = Mavo.wrap(index, this.children.length + 1);\n\n\t\tthis.add(item, index);\n\t}\n\n\teditItem (item, o = {}) {\n\t\t// Get rid of old promise and replace it with new promise\n\t\titem.preEdit?.resolve(\"abort\");\n\n\t\tlet immediately = o.immediately || Mavo.inView.is(item.element);\n\n\t\titem.preEdit = Mavo.promise(immediately? Promise.resolve() : Mavo.inView.when(item.element));\n\n\t\treturn item.preEdit.then(value => {\n\t\t\tif (value === \"abort\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!item.itembar) {\n\t\t\t\titem.itembar = new Mavo.UI.Itembar(item);\n\t\t\t}\n\n\t\t\titem.itembar.add();\n\n\t\t\treturn item.edit(o);\n\t\t});\n\t}\n\n\tdoneItem (item) {\n\t\titem.itembar?.remove();\n\t\titem.preEdit?.resolve(\"abort\");\n\t}\n\n\tedit (o = {}) {\n\t\tif (super.edit() === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Insert the add button if it's not already in the DOM\n\t\tif (!this.addButton.parentNode) {\n\t\t\t// In bottom up collections, button goes before first item\n\t\t\t// otherwise, it goes after the marker\n\t\t\tif (this.bottomUp && this.children[0]) {\n\t\t\t\tvar rel = this.children[0].element;\n\t\t\t}\n\n\t\t\trel = rel || this.marker;\n\t\t\tMavo.revocably.add(this.addButton, e => $[this.bottomUp? \"before\" : \"after\"](e, rel));\n\t\t}\n\n\t\t// Set up drag & drop\n\t\t_.dragula.then(() => {\n\t\t\tthis.getDragula();\n\t\t});\n\n\t\t// Edit items, maybe insert item bar\n\t\treturn Promise.all(this.children.map(item => this.editItem(item, o)));\n\t}\n\n\tdone () {\n\t\tif (super.done() === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\tMavo.revocably.remove(this.addButton);\n\n\t\tthis.propagate(item => this.doneItem(item));\n\t}\n\n\tdataChanged (action, o = {}) {\n\t\to.element = o.element || this.marker;\n\t\treturn super.dataChanged(action, o);\n\t}\n\n\tdataRender (data, o = {}) {\n\t\tif (data === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata = data === null? [] : Mavo.toArray(data).filter(i => i !== null);\n\t\tvar changed = false;\n\n\t\t// First render on existing items\n\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\tvar item = this.children[i];\n\n\t\t\tif (i < data.length) {\n\t\t\t\tchanged = item.render(data[i], o) || changed;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchanged = true;\n\t\t\t\tthis.delete(item, {silent: true});\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tif (data.length > i) {\n\t\t\t// There are still remaining items\n\t\t\t// Using document fragments improves performance by 60%\n\t\t\tvar fragment = document.createDocumentFragment();\n\n\t\t\tfor (var j = i; j < data.length; j++) {\n\t\t\t\tvar item = this.createItem();\n\n\t\t\t\tchanged = item.render(data[j], o) || changed;\n\n\t\t\t\tthis.children.push(item);\n\t\t\t\titem.index = j;\n\n\t\t\t\tfragment.appendChild(item.element);\n\n\t\t\t\tvar env = {context: this, item};\n\t\t\t\tMavo.hooks.run(\"collection-add-end\", env);\n\n\t\t\t}\n\n\t\t\tthis.marker.before(fragment);\n\t\t}\n\n\t\tthis.liveData.update();\n\n\t\tif (data.length > i) {\n\t\t\tfor (var j = i; j < this.children.length; j++) {\n\t\t\t\tthis.children[j].dataChanged(\"add\");\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\tisCompatible (c) {\n\t\treturn c && this.itemTemplate.constructor == c.itemTemplate.constructor && (c === this\n\t\t       || c.template == this || this.template == c || this.template && this.template == c.template\n\t\t       || this.accepts.has(c.property) > -1);\n\t}\n\n\t// Make sure to remove reference to .dragula\n\t// it seems to cause problem on OS chrome.\n\tdestroy () {\n\t\tsuper.destroy();\n\n\t\tthis.dragula?.destroy();\n\t\tthis.dragula = null;\n\n\t\tthis.propagate(\"destroy\");\n\t}\n\n\t// Make sure to only call after dragula has loaded\n\tgetDragula () {\n\t\tif (this.dragula) {\n\t\t\treturn this.dragula;\n\t\t}\n\n\t\tif (this.template) {\n\t\t\tlet containers = this.template.getDragula().containers;\n\n\t\t\tif (containers.indexOf(this.marker.parentNode) === -1) {\n\t\t\t\tcontainers.push(this.marker.parentNode);\n\t\t\t}\n\n\t\t\treturn this.dragula = this.template.dragula || this.template.getDragula();\n\t\t}\n\n\t\tthis.dragula = dragula({\n\t\t\tcontainers: [this.marker.parentNode],\n\t\t\tisContainer: el => {\n\t\t\t\tif (this.accepts.size) {\n\t\t\t\t\treturn Array.from(el.childNodes).some(child => {\n\t\t\t\t\t\tvar collection = _.get(child);  // Map children to any associated collections\n\n\t\t\t\t\t\treturn collection && this.accepts.has(collection.property);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tmoves: (el, container, handle) => {\n\t\t\t\treturn handle.classList.contains(\"mv-drag-handle\") && handle.closest(Mavo.selectors.multiple) == el;\n\t\t\t},\n\t\t\taccepts: function(el, target, source, next) {\n\t\t\t\tif (el.contains(target)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar previous = next?.previousElementSibling ?? target.lastElementChild;\n\n\t\t\t\tvar collection = _.get(previous) || _.get(next);\n\n\t\t\t\tif (!collection) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar item = Mavo.Node.get(el);\n\n\t\t\t\treturn item?.collection.isCompatible(collection);\n\t\t\t}\n\t\t});\n\n\t\tthis.dragula.on(\"drop\", (el, target, source) => {\n\t\t\tvar item = Mavo.Node.get(el);\n\t\t\t// var oldIndex = item && item.index;\n\t\t\tvar next = el.nextElementSibling;\n\t\t\tvar previous = el.previousElementSibling;\n\t\t\tvar collection = _.get(previous) || _.get(next);\n\t\t\tvar closestItem = Mavo.Node.get(previous) || Mavo.Node.get(next);\n\n\t\t\tif (closestItem && closestItem.collection != collection) {\n\t\t\t\tclosestItem = null;\n\t\t\t}\n\n\t\t\tif (item.collection.isCompatible(collection)) {\n\t\t\t\tvar index = closestItem? closestItem.index + (closestItem.element === previous) : collection.length;\n\t\t\t\tcollection.add(item, index);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.dragula.cancel(true);\n\t\t\t}\n\t\t});\n\n\t\t_.dragulas.push(this.dragula);\n\n\t\treturn this.dragula;\n\t}\n\n\tgetClosestCollection () {\n\t\treturn this;\n\t}\n\n\tstatic get (element) {\n\t\t// Is it an add button or a marker?\n\t\tvar collection = Mavo.data(element, \"collection\");\n\n\t\tif (collection) {\n\t\t\treturn collection;\n\t\t}\n\n\t\t// Maybe it's a collection item?\n\t\tvar item = Mavo.Node.get(element);\n\n\t\treturn item?.collection || null;\n\t}\n\n\t// Delete multiple items from potentially multiple collections or even multiple mavos\n\tstatic async delete (nodes, o = {}) {\n\t\t// Drop nodes that are not collection items\n\t\tnodes = nodes.filter(node => !!node.collection);\n\n\t\tif (nodes.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\telse if (nodes.length === 1) {\n\t\t\tlet ret = await nodes[0].collection.delete(nodes[0], o);\n\t\t\treturn [ret];\n\t\t}\n\n\t\tlet deleted = new Mavo.BucketMap({arrays: true}); // Mavos and deleted items\n\t\tlet collections = new Set(); // Collections items were deleted from\n\n\t\tlet promises = nodes.map(async node => {\n\t\t\t\tcollections.add(node.collection);\n\t\t\t\t// We set undoable: false to suppress the Undo UI for individual items\n\t\t\t\t// so we can show one notice about all items\n\t\t\t\tlet options = {silent: true, undoable: false, destroy: false};\n\t\t\t\tlet item = await node.collection.delete(node, options);\n\t\t\t\titem.unsavedChanges = true;\n\t\t\t\tdeleted.set(node.mavo, node);\n\t\t\t\treturn item;\n\t\t\t});\n\n\t\tlet ret = await Promise.all(promises);\n\n\t\tif (o.silent !== false) {\n\t\t\t// Here we are also batching change notifications to limit pointless expression recalc\n\t\t\t// Hopefully at some point we'll utilize a queue on the expression side\n\t\t\t// so we won't need to be careful about this in data modification code\n\t\t\tcollections.forEach(collection => {\n\t\t\t\tcollection.unsavedChanges = collection.mavo.unsavedChanges = true;\n\t\t\t\tcollection.dataChanged(\"delete\");\n\t\t\t});\n\n\t\t\tif (o.undoable !== false) {\n\t\t\t\tdeleted.forEach((nodes, mavo) => {\n\t\t\t\t\tmavo.setDeleted(...nodes);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n};\n\n$.Class(_, {\n\tlazy: {\n\t\tbottomUp: function() {\n\t\t\t/**\n\t\t\t * Add new items at the top or bottom?\n\t\t\t */\n\n\t\t\treturn /^desc\\b/i.test(this.element.getAttribute(\"mv-order\"));\n\t\t}\n\t},\n\n\tstatic: {\n\t\tdragulas: [],\n\n\t\tlazy: {\n\t\t\tdragula: () => $.include(self.dragula, \"https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.2/dragula.min.js\")\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.ImplicitCollection = class ImplicitCollection extends Mavo.Node {\n\tconstructor (element, mavo, o) {\n\t\tsuper(element, mavo, o);\n\n\t\tthis.children = [];\n\t\tthis.liveData = new Mavo.Data(this, []);\n\n\t\tthis.add(element);\n\t\tthis.postInit();\n\n\t\tMavo.hooks.run(\"implicit-collection-init-end\", this);\n\t}\n\n\tget length() {\n\t\treturn this.children.length;\n\t}\n\n\tgetData (o = {}) {\n\t\tvar env = {\n\t\t\tcontext: this,\n\t\t\toptions: o,\n\t\t\tdata: []\n\t\t};\n\n\t\tthis.children.forEach(node => {\n\t\t\tif (!node.isDataNull()) {\n\t\t\t\tenv.data.push(node.getData(o));\n\t\t\t}\n\t\t});\n\n\t\tif (this.data) {\n\t\t\t// Maybe rendered data had more items than we could show? Add it back.\n\t\t\tvar rendered = Mavo.toArray(Mavo.subset(this.data, this.inPath));\n\n\t\t\tif (rendered.length > env.data.length) {\n\t\t\t\tenv.data = env.data.concat(rendered.slice(env.data.length));\n\t\t\t}\n\t\t}\n\n\t\tif (Array.isArray(env.data) && env.data.length <= 1) {\n\t\t\tenv.data = env.data.length === 1? env.data[0] : null;\n\t\t}\n\n\t\tenv.data = Mavo.subset(this.data, this.inPath, env.data);\n\n\t\tMavo.hooks.run(\"node-getdata-end\", env);\n\n\t\treturn env.data;\n\t}\n\n\t/**\n\t * Add a new item to this collection\n\t * @param item Element or Mavo object for the new item\n\t */\n\tadd (element) {\n\t\tvar item = Mavo.Node.create(element, this.mavo, {\n\t\t\tcollection: this,\n\t\t\ttemplate: this.template?.children?.[this.length] ?? null,\n\t\t\tproperty: this.property,\n\t\t\ttype: this.type\n\t\t});\n\n\t\titem.index = this.length;\n\t\tthis.children.push(item);\n\n\t\t// item may have tried to propagate updates to us when we created it,\n\t\t// but that wouldn't have worked since item was not yet in\n\t\t// this.children, so we need to update manually.\n\t\tthis.liveData.update();\n\n\t\treturn item;\n\t}\n\n\tedit (o = {}) {\n\t\tif (super.edit() === false) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Edit items\n\t\treturn Promise.all(this.children.map(item => item.edit(o)));\n\t}\n\n\tdataRender (data, o = {}) {\n\t\tif (data !== undefined) {\n\t\t\tdata = data === null? [] : Mavo.toArray(data).filter(i => i !== null);\n\t\t\tvar changed = data.length !== this.liveData.length;\n\n\t\t\tthis.children.forEach((item, i) => changed = item.render(data?.[i], o) ?? changed);\n\t\t}\n\n\t\tthis.liveData.update();\n\t}\n};\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.UI.Itembar = class Itembar {\n\tconstructor (item) {\n\t\tthis.item = item;\n\n\t\t// Is there an existing .mv-item-bar element?\n\t\tthis.element = $$(`.mv-item-bar:is(:not([mv-rel]), [mv-rel=\"${this.item.property}\"])`, this.item.element).filter(el => {\n\t\t\t\t// Ignore item controls meant for other collections\n\t\t\t\treturn el.closest(Mavo.selectors.multiple) == this.item.element && !Mavo.data(el, \"item\");\n\t\t\t})[0];\n\n\t\tif (!this.element && this.item.template?.itembar) {\n\t\t\t// We can clone the buttons from the template\n\t\t\tthis.element = this.item.template.itembar.element.cloneNode(true);\n\t\t\tthis.dragHandle = $(\".mv-drag-handle\", this.element) || this.item.element;\n\t\t}\n\t\telse {\n\t\t\t// First item of this type\n\t\t\tthis.element = this.element || $.create({\n\t\t\t\tclassName: \"mv-item-bar mv-ui\"\n\t\t\t});\n\n\t\t\tthis.template = this.element.getAttribute(\"mv-item-bar\")\n\t\t                || this.item.element.getAttribute(\"mv-item-bar\")\n\t\t                || this.collection.element.getAttribute(\"mv-item-bar\")\n\t\t                || \"\";\n\n\t\t\tlet controls = Object.assign({}, _.controls);\n\t\t\t// If item is a primitive, move button is optional\n\t\t\tcontrols.move = {\n\t\t\t\t...controls.move,\n\t\t\t\toptional: this.item instanceof Mavo.Primitive\n\t\t\t};\n\n\t\t\tthis.controls = Mavo.UI.Bar.getControls(this.template, controls);\n\n\t\t\t$.set(this.element, {\n\t\t\t\t\"mv-rel\": this.item.property,\n\t\t\t\tcontents: this.controls.map(id => {\n\t\t\t\t\tlet meta = _.controls[id];\n\t\t\t\t\tlet existing = $(`.mv-${id}`, this.element);\n\t\t\t\t\treturn $.create(meta.create.call(this, existing));\n\t\t\t\t})\n\t\t\t});\n\n\t\t\tthis.dragHandle = $(\".mv-drag-handle\", this.element) || this.item.element;\n\t\t}\n\n\t\tthis.element.setAttribute(\"hidden\", \"\");\n\n\t\t$.bind([this.item.element, this.element], \"focusin mouseover\", this);\n\n\t\t$.bind(this.element, {\n\t\t\tmouseenter: evt => {\n\t\t\t\tthis.item.element.classList.add(\"mv-highlight\");\n\t\t\t},\n\t\t\tmouseleave: evt => {\n\t\t\t\tthis.item.element.classList.remove(\"mv-highlight\");\n\t\t\t}\n\t\t});\n\n\t\tthis.dragHandle.addEventListener(\"keydown\", evt => {\n\t\t\tif (evt.target === this.dragHandle && this.item.editing && evt.keyCode >= 37 && evt.keyCode <= 40) {\n\t\t\t\t// Arrow keys\n\t\t\t\tthis.collection.move(this.item, evt.keyCode <= 38? -1 : 1);\n\n\t\t\t\tevt.stopPropagation();\n\t\t\t\tevt.preventDefault();\n\t\t\t\tevt.target.focus();\n\t\t\t}\n\t\t});\n\n\t\tif (this.dragHandle !== this.item.element) {\n\t\t\tthis.dragHandle.addEventListener(\"click\", evt => evt.target.focus());\n\t\t}\n\n\t\tMavo.data(this.element, \"item\", this.item);\n\t}\n\n\tget collection() {\n\t\treturn this.item.collection;\n\t}\n\n\tget mavo() {\n\t\treturn this.item.mavo;\n\t}\n\n\tdestroy () {\n\t\tthis.hide();\n\t}\n\n\tshow (sticky) {\n\t\t_.visible.forEach(instance => {\n\t\t\tif (instance != this && (!this.sticky || instance.sticky)) {\n\t\t\t\tclearTimeout(instance.hideTimeout);\n\t\t\t\tinstance.hide(sticky, _.DELAY);\n\t\t\t}\n\t\t});\n\n\t\t_.visible.add(this);\n\n\t\tif (this.element.hasAttribute(\"hidden\") || sticky && !this.sticky) {\n\t\t\tthis.element.removeAttribute(\"hidden\");\n\t\t\tthis.sticky = this.sticky || sticky;\n\t\t\t$.bind([this.item.element, this.element], \"focusout mouseleave\", this);\n\t\t}\n\t}\n\n\thide (sticky, timeout = 0) {\n\t\tif (!this.sticky || sticky) {\n\t\t\tif (timeout) {\n\t\t\t\tthis.hideTimeout = setTimeout(() => this.hide(sticky), timeout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.element.setAttribute(\"hidden\", \"\");\n\t\t\t\t$.unbind([this.item.element, this.element], \"focusout mouseleave\", this);\n\t\t\t\tthis.sticky = false;\n\t\t\t\t_.visible.delete(this);\n\t\t\t}\n\n\t\t}\n\t}\n\n\thandleEvent (evt) {\n\t\tvar sticky = evt.type.indexOf(\"mouse\") === -1;\n\n\t\tif (this.isWithinItem(evt.target)) {\n\t\t\tclearTimeout(this.hideTimeout);\n\n\t\t\tif ([\"mouseleave\", \"focusout\", \"blur\"].indexOf(evt.type) > -1) {\n\t\t\t\tif (!this.isWithinItem(evt.relatedTarget)) {\n\t\t\t\t\tthis.hide(sticky, _.DELAY);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.show(sticky);\n\t\t\t\tevt.stopPropagation();\n\t\t\t}\n\t\t}\n\t}\n\n\tisWithinItem (element) {\n\t\tif (!element) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar itemBar = element.closest(\".mv-item-bar\");\n\t\treturn itemBar? itemBar === this.element : element.closest(Mavo.selectors.item) === this.item.element;\n\t}\n\n\tadd () {\n\t\tif (!this.element.parentNode && !Mavo.revocably.add(this.element)) {\n\t\t\t// Has not been added before\n\t\t\tvar tag = this.item.element.nodeName.toLowerCase();\n\n\t\t\tif (tag in _.container) {\n\t\t\t\tvar rel = $(_.container[tag], this.item.element);\n\t\t\t}\n\n\t\t\t(rel || this.item.element).appendChild(this.element);\n\t\t}\n\n\t\tif (this.dragHandle == this.item.element) {\n\t\t\tthis.item.element.classList.add(\"mv-drag-handle\");\n\t\t}\n\t}\n\n\tremove () {\n\t\tMavo.revocably.remove(this.element);\n\n\t\tif (this.dragHandle == this.item.element) {\n\t\t\tthis.item.element.classList.remove(\"mv-drag-handle\");\n\t\t}\n\t}\n}\n\n$.Class(_, {\n\tlive: {\n\t\tsticky: function(v) {\n\t\t\tthis.element.classList.toggle(\"mv-sticky\", v);\n\t\t}\n\t},\n\tstatic: {\n\t\tDELAY: 100,\n\t\tvisible: new Set(),\n\t\tcontainer: {\n\t\t\t\"details\": \"summary\"\n\t\t},\n\t\tcontrols: {\n\t\t\tdelete: {\n\t\t\t\tcreate (existing) {\n\t\t\t\t\tlet button = existing || $.create(\"button\", {\n\t\t\t\t\t\ttype: \"button\",\n\t\t\t\t\t\ttitle: this.mavo._(\"delete-item\", this.item),\n\t\t\t\t\t\tclassName: \"mv-delete\"\n\t\t\t\t\t});\n\n\t\t\t\t\t// Why $item and not this.collection.property?\n\t\t\t\t\t// If there's a nested property with the same name, the name will refer to that\n\t\t\t\t\t// However, this means that if we place the item bar inside another item, the button will not work anymore\n\t\t\t\t\t// It's a tradeoff, and perhaps if it proves to be a problem we can start detecting which one is best\n\t\t\t\t\tMavo.setAttributeShy(button, \"mv-action\", \"delete($item)\");\n\n\t\t\t\t\treturn button;\n\t\t\t\t}\n\t\t\t},\n\t\t\tadd: {\n\t\t\t\tcreate (existing) {\n\t\t\t\t\tlet bottomUp = this.collection.bottomUp;\n\t\t\t\t\tlet args = `$item${bottomUp? \", $index + 1\" : \"\"}`;\n\t\t\t\t\tlet button = existing || $.create(\"button\", {\n\t\t\t\t\t\ttype: \"button\",\n\t\t\t\t\t\ttitle: this.mavo._(`add-item-${bottomUp? \"after\" : \"before\"}`, this.item),\n\t\t\t\t\t\tclassName: \"mv-add\"\n\t\t\t\t\t});\n\n\t\t\t\t\tMavo.setAttributeShy(button, \"mv-action\", `if($cmd, add($item, ${args}), add(${args}))`);\n\n\t\t\t\t\treturn button;\n\t\t\t\t}\n\t\t\t},\n\t\t\tmove: {\n\t\t\t\tcreate (existing) {\n\t\t\t\t\tlet button = existing || $.create(\"button\", {\n\t\t\t\t\t\ttype: \"button\",\n\t\t\t\t\t\ttitle: this.mavo._(\"drag-to-reorder\", this.item),\n\t\t\t\t\t\tclassName: \"mv-move\"\n\t\t\t\t\t});\n\n\t\t\t\t\tbutton.classList.add(\"mv-drag-handle\");\n\n\t\t\t\t\treturn button;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function() {\n\nvar _ = Mavo.Expression = class Expression {\n\tconstructor (expression, options = {}) {\n\t\tthis.options = options;\n\t\tthis.expression = expression;\n\t}\n\n\teval (data = Mavo.Data.stub) {\n\t\tMavo.hooks.run(\"expression-eval-beforeeval\", this);\n\n\t\tif (this.function instanceof Error) {\n\t\t\t// Previous compilation error\n\t\t\treturn this.function;\n\t\t}\n\n\t\ttry {\n\t\t\treturn this.function(data);\n\t\t}\n\t\tcatch (error) {\n\t\t\t// Runtime error\n\t\t\tthis.error(`Something went wrong with the expression ${this.expression}`,\n\t\t\t\terror.message,\n\t\t\t\t`Data was: ${JSON.stringify(data)}`\n\t\t\t);\n\n\t\t\tMavo.hooks.run(\"expression-eval-error\", {context: this, error});\n\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror (title, ...message) {\n\t\tmessage = message.join(\"\\n\");\n\t\tconsole.info(`%cOops!  ${title}:`, \"color: #c04; font-weight: bold;\", message);\n\t}\n\n\ttoString () {\n\t\treturn this.expression;\n\t}\n\n\tchangedBy (evt) {\n\t\treturn _.changedBy(this.identifiers, evt);\n\t}\n};\n\nBliss.Class(_, {\n\tlive: {\n\t\texpression: function(value) {\n\t\t\ttry {\n\t\t\t\tthis.function = Mavo.Script.compile(value, this.options);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\t// Compilation error\n\t\t\t\tthis.error(`There is something wrong with the expression ${value}`,\n\t\t\t\t\terror.message,\n\t\t\t\t\t\"Not an expression? See https://mavo.io/docs/expressions/#disabling-expressions for information on how to disable expressions.\"\n\t\t\t\t);\n\n\t\t\t\tMavo.hooks.run(\"expression-compile-error\", {context: this, error});\n\n\t\t\t\tthis.function = error;\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tthis.ast = this.options.ast;\n\t\t\tdelete this.options.ast;\n\n\t\t\tif (this.ast) {\n\t\t\t\t// Traverse AST to find potential identifiers\n\t\t\t\tlet identifiers = new Set();\n\n\t\t\t\tMavo.Script.walk(this.ast, (n, property, parent) => {\n\t\t\t\t\tif (n.type === \"Identifier\" && property !== \"callee\") {\n\t\t\t\t\t\tidentifiers.add(n.name);\n\t\t\t\t\t}\n\t\t\t\t\telse if (n.type === \"MemberExpression\") {\n\t\t\t\t\t\tif (n.object.name) {\n\t\t\t\t\t\t\tidentifiers.add(n.object.name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tidentifiers.add(n.property.name);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tthis.identifiers = [...identifiers];\n\t\t\t}\n\t\t}\n\t}\n});\n\n_.Syntax = class Syntax {\n\tconstructor (start, end) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\t// Try to parse anything between start and end as an expression. Note\n\t\t// that this parses text that we don't want to treat as expressions,\n\t\t// including the empty expression, but we want to parse them out anyway\n\t\t// and only later decide not to evaluate them as expressions so that we\n\t\t// don't parse, say, [][1] as a single expression containing \"][1\".\n\n\t\t// Regex note: \"[\\S\\s]\" matches all characters, unlike \".\", which\n\t\t// doesn't match newlines.\n\t\tthis.regex = RegExp(`${Mavo.escapeRegExp(start)}([\\\\S\\\\s]*?)${Mavo.escapeRegExp(end)}`, \"gi\");\n\t}\n\n\ttest (str) {\n\t\tthis.regex.lastIndex = 0;\n\n\t\treturn this.regex.test(str);\n\t}\n\n\ttokenize (str) {\n\t\tvar match, ret = [], lastIndex = 0;\n\n\t\tthis.regex.lastIndex = 0;\n\n\t\twhile ((match = this.regex.exec(str)) !== null) {\n\t\t\t// Literal before the expression\n\t\t\tif (match.index > lastIndex) {\n\t\t\t\tret.push(str.substring(lastIndex, match.index));\n\t\t\t}\n\n\t\t\tlastIndex = this.regex.lastIndex;\n\n\t\t\tif (/\\S/.test(match[1])) {\n\t\t\t\tret.push(new Mavo.Expression(match[1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// If the matched expression is empty or consists only of\n\t\t\t\t// whitespace, don't treat it as an expression.\n\t\t\t\tret.push(match[0]);\n\t\t\t}\n\t\t}\n\n\t\t// Literal at the end\n\t\tif (lastIndex < str.length) {\n\t\t\tret.push(str.substring(lastIndex));\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic create (element) {\n\t\tif (element) {\n\t\t\tvar syntax = element.getAttribute(\"mv-expressions\");\n\n\t\t\tif (syntax) {\n\t\t\t\tsyntax = syntax.trim();\n\t\t\t\treturn /\\s/.test(syntax)? new _.Syntax(...syntax.split(/\\s+/)) : _.Syntax.ESCAPE;\n\t\t\t}\n\t\t}\n\t}\n};\n\n_.Syntax.ESCAPE = -1;\n_.Syntax.default = new _.Syntax(\"[\", \"]\");\n\n})();\n","(function($, $$) {\n\nvar _ = Mavo.DOMExpression = $.Class({\n\tasync constructor (o = {}) {\n\t\tthis.mavo = o.mavo;\n\t\tthis.template = o.template?.template || o.template;\n\n\t\tfor (let prop of [\"item\", \"path\", \"syntax\", \"fallback\", \"attribute\", \"originalAttribute\", \"expression\", \"parsed\", \"identifiers\"]) {\n\t\t\tthis[prop] = o[prop] === undefined && this.template? this.template[prop] : o[prop];\n\t\t}\n\n\t\tthis.node = o.node;\n\n\t\tif (!this.node) {\n\t\t\t// No node provided, figure it out from path\n\t\t\tthis.node = Mavo.elementPath(this.item.element, this.path);\n\t\t}\n\n\t\tthis.element = this.node;\n\t\tthis.attribute = this.attribute || null;\n\n\t\tMavo.hooks.run(\"domexpression-init-start\", this);\n\n\t\tif (this.attribute == \"mv-value\") {\n\t\t\tthis.originalAttribute = \"mv-value\";\n\t\t\tthis.attribute = Mavo.Primitive.getValueAttribute(this.element);\n\t\t\tthis.fallback = this.fallback || Mavo.Primitive.getValue(this.element, {attribute: this.attribute});\n\t\t\tlet expression = this.element.getAttribute(\"mv-value\");\n\t\t\tthis.element.removeAttribute(\"mv-value\");\n\t\t\tthis.parsed = [new Mavo.Expression(expression)];\n\t\t\tthis.expression = expression;\n\t\t}\n\n\t\tif (this.node.nodeType === 3 && this.element === this.node) {\n\t\t\tthis.element = this.node.parentNode;\n\n\t\t\t// If no element siblings consider making this.node the element, which is more robust\n\t\t\tif (!this.node.parentNode.children.length || this.attribute) {\n\t\t\t\tthis.element.normalize();\n\n\t\t\t\tif (!this.node.parentNode || this.attribute) {\n\t\t\t\t\t// Normalization destroyed our text node, reassign it to the parent\n\t\t\t\t\t// Same if it's in an attribute, there are no attributes on a text node!\n\t\t\t\t\tthis.node = this.element;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof this.expression !== \"string\") { // Still unhandled?\n\t\t\tif (this.attribute) {\n\t\t\t\t// Some web components (e.g. AFrame) hijack getAttribute()\n\t\t\t\tvar value = Element.prototype.getAttribute.call(this.node, this.attribute);\n\n\t\t\t\tthis.expression = (value || \"\").trim();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Move whitespace outside to prevent it from messing with types\n\t\t\t\tthis.node.normalize();\n\n\t\t\t\tif (this.node.childNodes.length === 1 && this.node?.firstChild?.nodeType === 3) {\n\t\t\t\t\tvar whitespace = this.node.firstChild.textContent.match(/^\\s*|\\s*$/g);\n\n\t\t\t\t\tif (whitespace[1]) {\n\t\t\t\t\t\tthis.node.firstChild.splitText(this.node.firstChild.textContent.length - whitespace[1].length);\n\t\t\t\t\t\tthis.node.after(this.node.lastChild);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (whitespace[0]) {\n\t\t\t\t\t\tthis.node.firstChild.splitText(whitespace[0].length);\n\t\t\t\t\t\tthis.node.parentNode.insertBefore(this.node.firstChild, this.node);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.expression = this.node.textContent;\n\t\t\t}\n\n\t\t\tthis.parsed = this.template? this.template.parsed : this.syntax.tokenize(this.expression);\n\t\t}\n\n\t\tthis.oldValue = this.value = this.parsed.map(x => x instanceof Mavo.Expression? \"\" : x);\n\n\t\t// Cache identifiers\n\t\tthis.identifiers = this.identifiers || this.parsed.flatMap(x => x.identifiers || []);\n\n\t\t// Any identifiers that need additional updating?\n\t\t_.special.add(this);\n\n\t\tMavo.hooks.run(\"domexpression-init-end\", this);\n\n\t\t_.elements.set(this.element, [...(_.elements.get(this.element) || []), this]);\n\n\t\tawait this.mavo.treeBuilt;\n\n\t\tif (!this.template && !this.item) {\n\t\t\t// Only collection items and groups can have their own expressions arrays\n\t\t\tthis.item = Mavo.Node.getClosestItem(this.element);\n\t\t}\n\n\t\tif (this.originalAttribute == \"mv-value\" && this.mavoNode && this.mavoNode == this.item.collection) {\n\t\t\tthis.item.expressions.delete(this);\n\t\t}\n\n\t\tthis.mavo.expressions.register(this);\n\n\t\tMavo.hooks.run(\"domexpression-init-treebuilt\", this);\n\t},\n\n\tdestroy: function() {\n\t\t_.special.delete(this);\n\t\tthis.mavo.expressions.unregister(this);\n\t},\n\n\tget isDynamicObject() {\n\t\treturn this.originalAttribute == \"mv-value\"\n\t\t       && this.mavoNode\n\t\t\t   && !(this.mavoNode instanceof Mavo.Primitive);\n\t},\n\n\tchangedBy: function(evt) {\n\t\tif (this.isDynamicObject) {\n\t\t\t// Just prevent the same node from triggering changes, everything else is game\n\t\t\treturn !evt || !this.mavoNode.contains(evt.node);\n\t\t}\n\n\t\treturn Mavo.Expression.changedBy(this.identifiers, evt);\n\t},\n\n\tupdate: function(o) {\n\t\tif (this.active === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar env = {context: this};\n\t\tvar parentEnv = env;\n\n\t\tif (this.item) {\n\t\t\tvar scope = this.isDynamicObject? this.item.parent : this.item;\n\t\t\tvar data = this.data = scope.getLiveData();\n\t\t}\n\t\telse {\n\t\t\tvar data = this.data === undefined? Mavo.Data.stub : this.data;\n\t\t}\n\n\t\tMavo.hooks.run(\"domexpression-update-start\", env);\n\n\t\tthis.oldValue = this.value;\n\t\tvar changed = false;\n\n\t\tenv.value = this.value = this.parsed.map((expr, i) => {\n\t\t\tif (expr instanceof Mavo.Expression) {\n\t\t\t\tlet oldValue = Mavo.value(this.oldValue[i]);\n\t\t\t\tvar env = {context: this, expr, parentEnv, oldValue};\n\n\t\t\t\tMavo.hooks.run(\"domexpression-update-beforeeval\", env);\n\n\t\t\t\tenv.value = Mavo.value(env.expr.eval(data));\n\n\t\t\t\tMavo.hooks.run(\"domexpression-update-aftereval\", env);\n\n\t\t\t\tif (env.value instanceof Error) {\n\t\t\t\t\tenv.value = this.fallback !== undefined? this.fallback : this.syntax.start + env.expr.expression + this.syntax.end;\n\t\t\t\t}\n\n\t\t\t\tif (env.value === undefined || env.value === null) {\n\t\t\t\t\t// Dont print things like \"undefined\" or \"null\"\n\t\t\t\t\tenv.value = \"\";\n\t\t\t\t}\n\n\t\t\t\tlet value = Mavo.value(env.value);\n\t\t\t\tif (!this.evaluated || typeof value === \"object\" || value !== oldValue) {\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\n\t\t\t\tthis.evaluated = true;\n\n\t\t\t\treturn env.value;\n\t\t\t}\n\n\t\t\treturn expr;\n\t\t});\n\n\t\tif (!changed && !o?.force) {\n\t\t\t// If nothing changed, no need to do anything\n\t\t\treturn;\n\t\t}\n\n\t\tif (env.value.length === 1) {\n\t\t\tenv.value = env.value[0];\n\t\t}\n\t\telse {\n\t\t\tenv.value = env.value.map(v => Mavo.Primitive.format(v, {\n\t\t\t\tattribute: this.attribute,\n\t\t\t\telement: this.element\n\t\t\t})).join(\"\");\n\t\t}\n\n\t\tthis.output(env.value);\n\n\t\tMavo.hooks.run(\"domexpression-update-end\", env);\n\t},\n\n\toutput: function(value) {\n\t\tif (this.mavoNode) {\n\t\t\tif (Mavo.in(Mavo.isProxy, value)) {\n\t\t\t\tvalue = Mavo.clone(value); // Drop proxy\n\t\t\t}\n\n\t\t\tthis.mavoNode.render(value, {live: true});\n\t\t}\n\t\telse {\n\t\t\tif (this.node.nodeType === Node.TEXT_NODE && !this.node.parentNode) {\n\t\t\t\t// If our expression was on a text node, and that somehow became orphaned, use the parent instead\n\t\t\t\tthis.node = this.element;\n\t\t\t}\n\n\t\t\tMavo.Primitive.setValue(this.node, value, {attribute: this.attribute});\n\t\t}\n\t},\n\n\tlive: {\n\t\titem: function(item) {\n\t\t\tif (item && this._item != item) {\n\t\t\t\tif (this._item) {\n\t\t\t\t\t// Previous item, delete from its expressions\n\t\t\t\t\tthis._item.expressions.delete(this);\n\t\t\t\t}\n\n\t\t\t\titem.expressions = item.expressions || new Set();\n\t\t\t\titem.expressions.add(this);\n\t\t\t}\n\t\t}\n\t},\n\n\tstatic: {\n\t\telements: new WeakMap(),\n\n\t\t/**\n\t\t * Search for Mavo.DOMExpression object(s) associated with a given element\n\t\t * and optionally an attribute.\n\t\t *\n\t\t * @return If one argument, array of matching DOMExpression objects.\n\t\t *         If two arguments, the matching DOMExpression object or null\n\t\t */\n\t\tsearch: function (element, attribute) {\n\t\t\tif (element === null) {\n\t\t\t\treturn element;\n\t\t\t}\n\n\t\t\t// HTML attributes are case-insensitive (fix for #515)\n\t\t\tif (attribute && !element.ownerDocument.xmlVersion) {\n\t\t\t\tattribute = attribute.toLowerCase();\n\t\t\t}\n\n\t\t\tvar all = _.elements.get(element) || [];\n\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tif (!all.length) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn all.filter(et => et.attribute === attribute)[0] || null;\n\t\t\t}\n\n\t\t\treturn all;\n\t\t},\n\n\t\tspecial: {\n\t\t\tadd: function(domexpression, name) {\n\t\t\t\tif (name) {\n\t\t\t\t\tvar o = this.vars[name];\n\t\t\t\t\tvar hasName = domexpression.identifiers.indexOf(name) > -1;\n\t\t\t\t\tvar hasUnprefixedName = (name.startsWith(\"$\") &&\n\t\t\t\t\t\tdomexpression.identifiers.indexOf(name.substr(1)) > -1);\n\n\t\t\t\t\tif (o && (hasName || hasUnprefixedName)) {\n\t\t\t\t\t\to.all = o.all || new Set();\n\t\t\t\t\t\to.all.add(domexpression);\n\n\t\t\t\t\t\tif (o.all.size === 1) {\n\t\t\t\t\t\t\to.observe();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!o.all.size) {\n\t\t\t\t\t\t\to.unobserve();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// All names\n\t\t\t\t\tfor (var name in this.vars) {\n\t\t\t\t\t\tthis.add(domexpression, name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tdelete: function(domexpression, name) {\n\t\t\t\tif (name) {\n\t\t\t\t\tvar o = this.vars[name];\n\n\t\t\t\t\to.all = o.all || new Set();\n\t\t\t\t\to.all.delete(domexpression);\n\n\t\t\t\t\tif (!o.all.size) {\n\t\t\t\t\t\to.unobserve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// All names\n\t\t\t\t\tfor (var name in this.vars) {\n\t\t\t\t\t\tthis.delete(domexpression, name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tupdate: function() {\n\t\t\t\tthis.update?.(...arguments);\n\n\t\t\t\tthis.all.forEach(domexpression => domexpression.update());\n\t\t\t},\n\n\t\t\tevent: function(name, {type, update, target = document} = {}) {\n\t\t\t\tthis.vars[name] = {\n\t\t\t\t\tobserve: function() {\n\t\t\t\t\t\tthis.callback = this.callback || _.special.update.bind(this);\n\t\t\t\t\t\t$.bind(target, type, this.callback);\n\t\t\t\t\t},\n\t\t\t\t\tunobserve: function() {\n\t\t\t\t\t\t$.unbind(target, type, this.callback);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (update) {\n\t\t\t\t\tthis.vars[name].update = function(evt) {\n\t\t\t\t\t\tMavo.Functions[name] = update(evt);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tvars: {\n\t\t\t\t\"$now\": {\n\t\t\t\t\tobserve: function() {\n\t\t\t\t\t\tvar callback = () => {\n\t\t\t\t\t\t\t_.special.update.call(this);\n\t\t\t\t\t\t\tthis.timer = requestAnimationFrame(callback);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.timer = requestAnimationFrame(callback);\n\t\t\t\t\t},\n\t\t\t\t\tunobserve: function() {\n\t\t\t\t\t\tcancelAnimationFrame(this.timer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n_.special.event(\"$mouse\", {\n\ttype: \"mousemove\",\n\tupdate: function(evt) {\n\t\treturn {x: evt.clientX, y: evt.clientY};\n\t}\n});\n\n_.special.event(\"$hash\", {\n\ttype: \"hashchange\",\n\ttarget: window\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nMavo.attributes.push(\"mv-expressions\");\n\nvar _ = Mavo.Expressions = $.Class({\n\tasync constructor (mavo) {\n\t\tthis.mavo = mavo;\n\t\tthis.active = true;\n\n\t\tthis.expressions = new Set();\n\t\tthis.identifiers = {};\n\n\t\tvar syntax = Mavo.Expression.Syntax.create(this.mavo.element.closest(\"[mv-expressions]\")) || Mavo.Expression.Syntax.default;\n\t\tthis.traverse(this.mavo.element, undefined, syntax);\n\n\t\tthis.scheduled = {};\n\n\t\tawait this.mavo.treeBuilt;\n\n\t\tthis.expressions = new Set();\n\t\tthis.update();\n\t},\n\n\tregister: function(domexpression) {\n\t\tvar ids = this.identifiers;\n\t\tdomexpression.registeredApp = domexpression.registeredApp || new Set();\n\t\tdomexpression.identifiers.forEach(id => {\n\t\t\tif (!(ids[id] instanceof Set)) {\n\t\t\t\tids[id] = new Set();\n\t\t\t}\n\n\t\t\tids[id].add(domexpression);\n\n\t\t\tif (Mavo.all[id] instanceof Mavo && Mavo.all[id] !== this.mavo && !domexpression.registeredApp.has(id) ) {\n\t\t\t\t// Cross-mavo expressions, make sure to track app id before calling register.\n\t\t\t\tdomexpression.registeredApp.add(id);\n\t\t\t\tMavo.all[id].expressions.register(domexpression);\n\t\t\t}\n\t\t});\n\t},\n\n\tunregister: function(domexpression) {\n\t\tvar ids = this.identifiers;\n\n\t\tdomexpression.identifiers.forEach(id => {\n\t\t\tif (ids[id]) {\n\t\t\t\tids[id].delete(domexpression);\n\t\t\t}\n\n\t\t\t// just in case domexpresssion has been destroyed by another app during the loop\n\t\t\t// when another app is destroyed.\n\t\t\tif (id in Mavo.all && typeof domexpresssion !== \"undefined\") {\n\t\t\t\t// Cross-mavo expressions\n\t\t\t\tMavo.all[id].expressions.unregister(domexpresssion);\n\t\t\t}\n\t\t});\n\t},\n\n\tupdateThrottled: function(evt) {\n\t\tif (!this.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar scheduled = this.scheduled[evt.action] = this.scheduled[evt.action] || new Set();\n\n\t\tif (evt.node.template) {\n\t\t\t// Throttle events in collections and events from other Mavos\n\t\t\tif (!scheduled.has(evt.node.template)) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tscheduled.delete(evt.node.template);\n\t\t\t\t\tthis.update(evt);\n\t\t\t\t}, _.THROTTLE);\n\n\t\t\t\tscheduled.add(evt.node.template);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trequestAnimationFrame(() => this.update(evt));\n\t\t}\n\t},\n\n\tupdate: function(evt) {\n\t\tif (!this.active) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar root, rootObject;\n\n\t\tif (evt instanceof Mavo.Node) {\n\t\t\trootObject = evt;\n\t\t}\n\t\telse if (evt instanceof Element) {\n\t\t\troot = evt.closest(Mavo.selectors.item);\n\t\t\trootObject = Mavo.Node.get(root);\n\t\t}\n\t\telse if (evt) {\n\t\t\t// Specific data change\n\t\t\tvar cache = {\n\t\t\t\tupdated: new Set()\n\t\t\t};\n\n\t\t\tthis.updateByIdThrottled(evt.property, evt, cache);\n\n\t\t\tif (evt.action == \"propertychange\") {\n\t\t\t\tif (evt.node?.path) {\n\t\t\t\t\t// Ensure that [collectionName] updates when changing children\n\t\t\t\t\tthis.updateByIdThrottled(evt.node.path, evt, cache);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Collection modifications (add, delete, move etc)\n\t\t\t\tthis.updateById(Object.keys(Mavo.Data.special), evt, cache);\n\n\t\t\t\tvar collection = evt.node.collection || evt.node;\n\n\t\t\t\tthis.updateById(collection.properties, evt, cache);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\trootObject = this.mavo.root;\n\t\t}\n\n\t\trootObject.walk((obj, path) => {\n\t\t\tif (!obj.expressionsEnabled) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tobj.expressions?.forEach(et => {\n\t\t\t\t// Prevent mv-value loops\n\t\t\t\tif (!evt || et.mavoNode !== evt) {\n\t\t\t\t\tet.update();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\tupdateByIdThrottled: function(property, evt, cache) {\n\t\tif (!property) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (property.forEach) {\n\t\t\tproperty.forEach(property => this.updateByIdThrottled(property, evt, cache));\n\t\t}\n\t\telse {\n\t\t\tvar scheduled = this.scheduledIds = this.scheduledIds || new Set();\n\n\t\t\tif (!scheduled.has(property)) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tscheduled.delete(property);\n\n\t\t\t\t\tthis.updateById(property, evt, cache);\n\t\t\t\t}, _.THROTTLE);\n\n\t\t\t\tscheduled.add(property);\n\t\t\t}\n\t\t}\n\t},\n\n\tupdateById: function(property, evt, cache) {\n\t\tif (property.forEach) {\n\t\t\t// Multiple properties\n\t\t\tproperty.forEach(p => this.updateById(p, evt, cache));\n\t\t\treturn;\n\t\t}\n\n\t\tvar exprs = this.identifiers[property];\n\n\t\tif (exprs) {\n\t\t\texprs.forEach(expr => {\n\t\t\t\t// Prevent the same node from triggering changes, everything else is game\n\t\t\t\tif (expr.originalAttribute == \"mv-value\" && expr.mavoNode && !(expr.mavoNode instanceof Mavo.Primitive) && expr.mavoNode.contains(evt.node)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!cache.updated.has(expr)) {\n\t\t\t\t\texpr.update();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\textract: function(node, attribute, path, syntax = Mavo.Expression.Syntax.default) {\n\t\tif (attribute && _.skip.indexOf(attribute.name) > -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (attribute && _.directives.indexOf(attribute.name) > -1 ||\n\t\t    syntax !== Mavo.Expression.Syntax.ESCAPE && syntax.test(attribute? attribute.value : node.textContent)\n\t\t) {\n\t\t\tif (path === undefined) {\n\t\t\t\tpath = Mavo.elementPath(node.closest(Mavo.selectors.scope), node);\n\t\t\t}\n\n\t\t\tthis.expressions.add(new Mavo.DOMExpression({\n\t\t\t\tnode, syntax, path,\n\t\t\t\tattribute: attribute?.name,\n\t\t\t\tmavo: this.mavo\n\t\t\t}));\n\t\t}\n\t},\n\n\t// Traverse an element, including attribute nodes, text nodes and all descendants\n\ttraverse: function(node, path = [], syntax) {\n\t\tif (node.nodeType === 8) {\n\t\t\t// We don't want expressions to be picked up from comments!\n\t\t\t// Commenting stuff out is a common debugging technique\n\t\t\treturn;\n\t\t}\n\n\t\tif (node.nodeType === 3) { // Text node\n\t\t\t// Leaf node, extract references from content\n\t\t\tthis.extract(node, null, path, syntax);\n\t\t}\n\t\telse {\n\t\t\tnode.normalize();\n\n\t\t\tsyntax = Mavo.Expression.Syntax.create(node) || syntax;\n\n\t\t\tif (node.matches(Mavo.selectors.scope)) {\n\t\t\t\tpath = [];\n\t\t\t}\n\n\t\t\tif (node.hasAttribute(\"mv-expressions-ignore\")) {\n\t\t\t\tvar ignore = new Set(node.getAttribute(\"mv-expressions-ignore\").trim().split(/\\s*,\\s*/));\n\t\t\t}\n\n\t\t\t$$(node.attributes).forEach(attribute => {\n\t\t\t\tif (!ignore || !ignore.has(attribute.name)) {\n\t\t\t\t\tthis.extract(node, attribute, path, syntax);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar index = -1, offset = 0;\n\n\t\t\tif (!node.matches(\"script:not([mv-expressions])\")) {\n\t\t\t\t$$(node.childNodes).forEach(child => {\n\t\t\t\t\tif (child.nodeType == 1) {\n\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (child.nodeType == 1 || child.nodeType == 3) {\n\t\t\t\t\t\tvar segment = offset > 0? `${index}.${offset}` : index;\n\t\t\t\t\t\tthis.traverse(child, [...path || [], segment], syntax);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t},\n\n\tstatic: {\n\t\tdirectives: [\n\t\t\t\"mv-value\"\n\t\t],\n\n\t\tskip: [\"mv-expressions\", \"mv-action\"],\n\n\t\tTHROTTLE: 50,\n\n\t\tdirective: function(name, o) {\n\t\t\t_.directives.push(name);\n\t\t\tMavo.attributes.push(name);\n\t\t\tMavo.Plugins.register(name, o);\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","// mv-if plugin\n(function($, $$) {\n\nMavo.Expressions.directive(\"mv-if\", {\n\textend: {\n\t\t\"Primitive\": {\n\t\t\tlive: {\n\t\t\t\t\"hidden\": function(value) {\n\t\t\t\t\tif (this._hidden !== value) {\n\t\t\t\t\t\tthis._hidden = value;\n\t\t\t\t\t\tthis.liveData.update();\n\t\t\t\t\t\tthis.dataChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"DOMExpression\": {\n\t\t\tlazy: {\n\t\t\t\t\"childProperties\": function() {\n\t\t\t\t\tvar properties = $$(Mavo.selectors.property, this.element)\n\t\t\t\t\t\t\t\t\t.filter(el => el.closest(\"[mv-if]\") == this.element)\n\t\t\t\t\t\t\t\t\t.map(el => Mavo.Node.get(el));\n\n\t\t\t\t\t// When the element is detached, mv-change events from properties\n\t\t\t\t\t// do not propagate up to the group so expressions do not recalculate.\n\t\t\t\t\t// We must do this manually.\n\t\t\t\t\tthis.element.addEventListener(\"mv-change\", evt => {\n\t\t\t\t\t\t// Cannot redispatch synchronously [why??]\n\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\tif (!this.element.parentNode) { // out of the DOM?\n\t\t\t\t\t\t\tthis.item.element.dispatchEvent(evt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\treturn properties;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\thooks: {\n\t\t\"domexpression-init-start\": function() {\n\t\t\tif (this.attribute != \"mv-if\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!Mavo.Node.prototype.fromTemplate.call(this, \"parsed\", \"expression\")) {\n\t\t\t\tthis.expression = this.element.getAttribute(\"mv-if\");\n\t\t\t\tthis.parsed = [new Mavo.Expression(this.expression)];\n\t\t\t\tthis.expression = this.syntax.start + this.expression + this.syntax.end;\n\t\t\t}\n\n\t\t\tthis.parentIf = this.element.parentNode && Mavo.DOMExpression.search(this.element.parentNode.closest(\"[mv-if]\"), \"mv-if\");\n\n\t\t\tif (this.parentIf) {\n\t\t\t\tthis.parentIf.childIfs = (this.parentIf.childIfs || new Set()).add(this);\n\t\t\t}\n\t\t},\n\t\t\"domexpression-update-end\": async function() {\n\t\t\tif (this.attribute !== \"mv-if\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar value = this.value[0];\n\t\t\tvar oldValue = this.oldValue[0];\n\n\t\t\t// Only apply this after the tree is built, otherwise any properties inside the if will go missing!\n\t\t\tawait this.item.mavo.treeBuilt;\n\n\t\t\tif (this.parentIf) {\n\t\t\t\tvar parentValue = this.parentIf.value[0];\n\t\t\t\tthis.value[0] = value = value && parentValue;\n\t\t\t}\n\n\t\t\tif (parentValue !== false) { // If parent if was false, it wouldn't matter whether this is in the DOM or not\n\t\t\t\tif (value) {\n\t\t\t\t\t// Is removed from the DOM and needs to get back\n\t\t\t\t\tMavo.revocably.add(this.element);\n\t\t\t\t}\n\t\t\t\telse if (this.element.parentNode) {\n\t\t\t\t\t// Is in the DOM and needs to be removed\n\t\t\t\t\tMavo.revocably.remove(this.element, \"mv-if\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value !== oldValue) {\n\t\t\t\t// Mark any properties inside as hidden or not\n\t\t\t\tthis.childProperties?.forEach(property => property.hidden = !value);\n\t\t\t\tthis.childIfs?.forEach(childIf => childIf.update());\n\t\t\t}\n\t\t},\n\t\t\"node-isdatanull\": function(env) {\n\t\t\tenv.result = env.result || (this.hidden && env.options.live);\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","/**\n * Functions available inside Mavo expressions\n */\n\n(function($, val) {\n\nvar _ = Mavo.Functions = {\n\toperators: {\n\t\t\"=\": \"eq\"\n\t},\n\n\t/**\n\t * Get a property of an object. Used by the . operator to prevent TypeErrors\n\t */\n\tget: function(obj, property, ...properties) {\n\t\tif (arguments.length <= 1) {\n\t\t\treturn obj;\n\t\t}\n\n\t\tlet ret;\n\t\tproperty = val(property);\n\n\t\t// Get same case property name if it exists,\n\t\t// otherwise do a case insensitive search among properties\n\t\tlet canonicalProperty = Mavo.getCanonicalProperty(obj, property);\n\n\t\tif (canonicalProperty !== undefined) {\n\t\t\tret = obj[canonicalProperty];\n\t\t}\n\t\telse if (Array.isArray(obj) && property && isNaN(property)) {\n\t\t\t// Array and non-numerical property, get from objects inside\n\t\t\tret = obj.map(e => _.get(e, property));\n\t\t}\n\t\telse {\n\t\t\t// Not found :(\n\t\t\treturn null;\n\t\t}\n\n\t\tif (properties.length > 0) {\n\t\t\treturn _.get(ret, ...properties);\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// Like get() when used with an array, but immediately goes to items\n\t// This means that map(arr, 'length') will return an array of item.length, rather than just the length of arr\n\tmap: function(array, property) {\n\t\tif (Array.isArray(array)) {\n\t\t\treturn array.map(e => _.get(e, property));\n\t\t}\n\t\telse if (array) {\n\t\t\treturn _.get(array, property);\n\t\t}\n\t},\n\n\turl: (id, url = location) => {\n\t\tif (id === undefined) {\n\t\t\treturn location.href;\n\t\t}\n\n\t\tif (id) {\n\t\t\tid = str(id).replace(/[^\\w-:]/g);\n\n\t\t\tvar ret = url.search.match(RegExp(`[?&]${id}(?:=(.+?))?(?=$|&)`))\n\t\t\t       || url.pathname.match(RegExp(`(?:^|\\\\/)${id}\\\\/([^\\\\/]*)`));\n\t\t}\n\n\t\tif (ret === null || !id) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn decodeURIComponent(ret[1] || \"\");\n\t},\n\n\tfirst: (n, arr) => {\n\t\tif (arr === undefined) {\n\t\t\tarr = n;\n\t\t\tn = undefined;\n\t\t}\n\n\t\tif (arr === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Array.isArray(arr)) {\n\t\t\treturn n !== undefined ? [arr] : arr;\n\t\t}\n\n\t\tif (n < 0) {\n\t\t\treturn _.last(Math.abs(n), arr);\n\t\t}\n\t\telse {\n\t\t\tvar ret = [];\n\t\t\tvar numReturn = n === undefined ? 1 : Math.floor(n);\n\n\t\t\tfor (var i = 0; i<arr.length && ret.length<numReturn; i++) {\n\t\t\t\tlet rawValue = Mavo.value(arr[i]);\n\t\t\t\tif (rawValue !== null && rawValue !== \"\") {\n\t\t\t\t\tret.push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (n === undefined) {\n\t\t\t\treturn ret[0] !== undefined ? ret[0] : null;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t},\n\tlast: (n, arr) => {\n\t\tif (arr === undefined) {\n\t\t\tarr = n;\n\t\t\tn = undefined;\n\t\t}\n\n\t\tif (arr === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!Array.isArray(arr)) {\n\t\t\treturn n !== undefined ? [arr] : arr;\n\t\t}\n\n\t\tif (n < 0) {\n\t\t\treturn _.first(Math.abs(n), arr);\n\t\t}\n\t\telse {\n\t\t\tvar ret = [];\n\t\t\tvar numReturn = n === undefined ? 1 : Math.floor(n);\n\n\t\t\tfor (var i = arr.length-1; i>=0 && ret.length<numReturn; i--) {\n\t\t\t\tlet rawValue = Mavo.value(arr[i]);\n\t\t\t\tif (rawValue !== null && rawValue !== \"\") {\n\t\t\t\t\tret.push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (n === undefined) {\n\t\t\t\treturn ret[0] !== undefined ? ret[0] : null;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t},\n\t// Get rid of empty values in array. Same as first(count(arr), arr)\n\tcondense: (arr) => {\n\t\treturn _.first(arr.length, arr);\n\t},\n\n\tunique: function(arr) {\n\t\tif (!Array.isArray(arr)) {\n\t\t\treturn arr;\n\t\t}\n\n\t\treturn [...new Set(arr.map(val))];\n\t},\n\n\t/**\n\t * Do two arrays or sets have a non-empty intersection?\n\t * @return {Boolean}\n\t */\n\tintersects: function(arr1, arr2) {\n\t\tif (arr1 && arr2) {\n\t\t\tvar set2 = new Set(Mavo.toArray(arr2).map(val));\n\t\t\tarr1 = Mavo.toArray(arr1).map(val);\n\n\t\t\treturn !arr1.every(el => !set2.has(el));\n\t\t}\n\t},\n\n\tintersection: function (arr1, arr2) {\n\t\tif (!arr1 || !arr2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tarr1 = Mavo.toArray(arr1);\n\t\tarr2 = Mavo.toArray(arr2);\n\n\t\tlet set2 = new Set(arr2.map(val));\n\n\t\treturn arr1.filter(x => set2.has(Mavo.value(x)));\n\t},\n\n\t/*********************\n\t * Number functions\n\t *********************/\n\n\t/**\n\t * Aggregate sum\n\t */\n\tsum: $.extend(function(array) {\n\t\treturn $u.numbers(array, arguments).reduce((prev, current) => {\n\t\t\treturn +prev + (+current || 0);\n\t\t}, 0);\n\t}, {\n\t\tisAggregate: true\n\t}),\n\n\t/**\n\t * Average of an array of numbers\n\t */\n\taverage: $.extend(function(array) {\n\t\tarray = $u.numbers(array, arguments);\n\t\treturn array.length && _.sum(array) / array.length;\n\t}, {\n\t\tisAggregate: true,\n\t\talias: \"avg\"\n\t}),\n\n\t/**\n\t * Median of an array of numbers\n\t */\n\tmedian: $.extend(function(array) {\n\t\tarray = $u.numbers(array, arguments).sort((a, b) => a - b);\n\t\tvar mi = (array.length - 1) / 2;\n\t\t[m1, m2] = [array[Math.floor(mi)], array[Math.ceil(mi)]];\n\t\treturn (m1 + m2) / 2 || 0;\n\t}, {\n\t\tisAggregate: true\n\t}),\n\n\t/**\n\t * Min of an array of numbers\n\t */\n\tmin: $.extend(function(array) {\n\t\treturn Math.min(...$u.numbers(array, arguments));\n\t}, {\n\t\tisAggregate: true\n\t}),\n\n\t/**\n\t * Max of an array of numbers\n\t */\n\tmax: $.extend(function(array) {\n\t\treturn Math.max(...$u.numbers(array, arguments));\n\t}, {\n\t\tisAggregate: true\n\t}),\n\n\tatan2: $.extend((dividend, divisor) => Math.atan2(dividend, divisor), {\n\t\tmultiValued: true,\n\t\trightUnary: b => b,\n\t\tdefault: 1\n\t}),\n\n\tpow: $.extend((base, exponent) => Math.pow(base, exponent), {\n\t\tmultiValued: true,\n\t\tdefault: 1\n\t}),\n\n\timul: $.extend((a, b) => Math.imul(a, b), {\n\t\tmultiValued: true,\n\t\tdefault: 1\n\t}),\n\n\tcount: $.extend(function(array) {\n\t\treturn Mavo.toArray(array).filter(a => !empty(a)).length;\n\t}, {\n\t\tisAggregate: true\n\t}),\n\n\treverse: function(array) {\n\t\treturn Mavo.toArray(array).slice().reverse();\n\t},\n\n\tround: $.extend((num, decimals) => {\n\t\tif (not(num) || not(decimals) || !isFinite(num)) {\n\t\t\treturn Math.round(num);\n\t\t}\n\n\t\treturn +(+num).toLocaleString(\"en-US\", {\n\t\t\tuseGrouping: false,\n\t\t\tmaximumFractionDigits: decimals\n\t\t});\n\t}, {\n\t\tmultiValued: true,\n\t\trightUnary: b => b,\n\t\tdefault: 0\n\t}),\n\n\tordinal: $.extend((num) => {\n\t\tif (empty(num)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (num < 10 || num > 20) {\n\t\t\tvar ord = [\"th\", \"st\", \"nd\", \"rd\", \"th\"][num % 10];\n\t\t}\n\n\t\treturn ord || \"th\";\n\t}, {\n\t\tmultiValued: true,\n\t\talias: \"th\"\n\t}),\n\n\tpluralize: $.extend(function(num, ...args) {\n\t\tif (empty(num)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (args.length === 0) {\n\t\t\treturn num;\n\t\t}\n\n\t\tlet o = args.reduce((o, arg) => {\n\t\t\targ = Mavo.value(arg);\n\n\t\t\tif ($.type(arg) !== \"object\") {\n\t\t\t\tif (o.one) {\n\t\t\t\t\targ = Object.fromEntries([\"zero\", \"two\", \"few\", \"many\", \"other\"].map(k => [k, arg]))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targ = {one: arg}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Object.assign(o, arg);\n\t\t}, {});\n\n\t\tlet lang = o.lang || Mavo.locale;\n\t\tlet pl = new Intl.PluralRules(lang, {type: o.type || \"cardinal\"});\n\t\tlet type = pl.select(num);\n\t\tlet label = o[type] || o.other || o.two || o.zero || o.few || o.many || o.one;\n\n\t\tif (o.text_only) {\n\t\t\treturn label;\n\t\t}\n\n\t\tif (o.type === \"ordinal\") {\n\t\t\treturn `${num}${label}`;\n\t\t}\n\n\t\treturn `${num} ${label}`;\n\t}, {\n\t\tmultiValued: true,\n\t\tneedsContext: true\n\t}),\n\n\tdigits: $.extend((digits, decimals, num) => {\n\t\tif (num === undefined) {\n\t\t\tnum = decimals;\n\t\t\tdecimals = undefined;\n\t\t}\n\n\t\tif (isNaN(num)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar parts = (num + \"\").split(\".\");\n\n\t\t// If it has more digits than n = digits, only keep the last n digits.\n\t\tparts[0] = parts[0].slice(-digits);\n\n\t\t// Chop extra decimals without rounding\n\t\tif (decimals !== undefined && parts[1]) {\n\t\t\tparts[1] = parts[1].slice(0, decimals);\n\t\t}\n\n\t\tnum = +parts.join(\".\");\n\n\t\t// This is mainly for padding with zeroes, we've done the rest already\n\t\treturn num.toLocaleString(\"en\", {\n\t\t\tuseGrouping: false, // we want something that can be converted to a number again\n\t\t\tminimumIntegerDigits: digits,\n\t\t\tminimumFractionDigits: decimals,\n\t\t\tmaximumFractionDigits: decimals || 20\n\t\t});\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\tiff: function(condition, iftrue=condition, iffalse=null) {\n\t\tif (Array.isArray(condition)) {\n\t\t\treturn condition.map((c, i) => {\n\t\t\t\tvar ret = val(c)? iftrue : iffalse;\n\n\t\t\t\treturn Array.isArray(ret)? ret[Math.min(i, ret.length - 1)] : ret;\n\t\t\t});\n\t\t}\n\n\t\treturn val(condition)? iftrue : iffalse;\n\t},\n\n\tgroup: (...objects) => {\n\t\treturn Object.assign({}, ...objects);\n\t},\n\tlist: (...items) => items.flat(),\n\n\t// FIXME if step=0 returns NaN\n\trandom: $.extend((min = 0, max = 100, step = 1) => {\n\t\tif (arguments.length == 1) {\n\t\t\tmax = min;\n\t\t\tmin = 0;\n\t\t}\n\n\t\tvar rand = Math.random();\n\t\tvar range = (max - min)  / step;\n\t\treturn Math.floor(rand * (range + 1)) * step + min;\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\trange: (a, b, step) => {\n\t\tif (step === undefined) {\n\t\t\tif (b === undefined) {\n\t\t\t\t[a, b] = [a >= 0? 1 : -1, a]\n\t\t\t}\n\n\t\t\tstep = a <= b? 1 : -1;\n\t\t}\n\n\t\tlet steps = Math.floor((b - a)/step + 1);\n\n\t\tif (steps <= 0 || !isFinite(steps)) {\n\t\t\treturn [a];\n\t\t}\n\n\t\tlet ret = [];\n\n\t\tfor (let i = 0, n = a; i++ < steps; n += step) {\n\t\t\tret.push(n);\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tshuffle: list => {\n\t\tif (Array.isArray(list)) {\n\t\t\t// Fisher-Yates shuffle\n\t\t\tvar ret = list.slice();\n\n\t\t\tfor (var i = ret.length - 1; i > 0; i--) {\n\t\t\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[ret[i], ret[j]] = [ret[j], ret[i]];\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\treturn list;\n\t\t}\n\t},\n\n\tsort (list, by = list, ...options) {\n\t\toptions = Object.assign({}, ...options);\n\t\tlet collatorOptions = Object.assign({numeric: true}, options);\n\t\tlet collator = new Intl.Collator(options.lang || Mavo.locale, collatorOptions);\n\n\t\tif (!Array.isArray(by)) {\n\t\t\tby = _.get(list, by);\n\t\t}\n\n\t\tlet desc = options.order?.startsWith(\"desc\");\n\n\t\tlet arr = list.map((a, i) => [a, by[i]]);\n\t\tarr = arr.sort((a, b) => {\n\t\t\tlet bya = a[1];\n\t\t\tlet byb = b[1];\n\n\t\t\treturn collator.compare(bya, byb) * (desc? -1 : 1);\n\t\t});\n\n\t\treturn arr.map(a => a[0]);\n\n\t},\n\n\t/*********************\n\t * String functions\n\t *********************/\n\n\t/**\n\t * Replace all occurences of a string with another string\n\t */\n\treplace: $.extend((haystack, needle, replacement = \"\", iterations = 1) => {\n\t\tif (!Mavo.value(haystack)) {\n\t\t\treturn haystack;\n\t\t}\n\n\t\tif (Array.isArray(haystack)) {\n\t\t\treturn haystack.map(item => _.replace(item, needle, replacement));\n\t\t}\n\n\t\t// Simple string replacement\n\t\tvar needleRegex = RegExp(Mavo.escapeRegExp(needle), \"g\");\n\t\tvar ret = haystack, prev;\n\t\tvar counter = 0;\n\n\t\twhile (ret != prev && (counter++ < iterations)) {\n\t\t\tprev = ret;\n\t\t\tret = ret.replace(needleRegex, replacement);\n\t\t}\n\n\t\treturn ret;\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\tlen: $.extend(text => str(text).length, {\n\t\tmultiValued: true\n\t}),\n\n\t/**\n\t * Search if a group, collection, or primitive contains a string\n\t * @returns Boolean if a haystack AND needle of object or primitive are passed\n\t * @returns Array of booleans if either a haystack OR needle of array is passed\n\t */\n\tcontains: $.extend((haystack, needle) => {\n\t\tlet ret;\n\t\tlet haystackType = $.type(haystack);\n\n\t\tif ($.type(needle) === \"object\") {\n\t\t\treturn JSON.stringify(haystack).indexOf(JSON.stringify(needle)) >= 0;\n\t\t}\n\n\t\tif (haystackType === \"object\" || haystackType === \"array\") {\n\t\t\tfor (let property in haystack) {\n\t\t\t\tret = _.contains(haystack[property], needle);\n\n\t\t\t\tif (Array.isArray(ret)) {\n\t\t\t\t\tret = Mavo.Functions.or(ret);\n\t\t\t\t}\n\t\t\t\tif (ret) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn _.search(haystack, needle) >= 0;\n\t\t}\n\n\t\treturn ret;\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\t/**\n\t * Case insensitive search\n\t */\n\tsearch: $.extend((haystack, needle) => {\n\t\thaystack = str(haystack);\n\t\tneedle = str(needle);\n\t\treturn haystack && needle? haystack.toLowerCase().indexOf(needle.toLowerCase()) : -1;\n\t}, {\n\t\tmultiValued: true,\n\t}),\n\n\tstarts: $.extend((haystack, needle) => _.search(str(haystack), str(needle)) === 0, {\n\t\tmultiValued: true,\n\t}),\n\n\tends: $.extend((haystack, needle) => {\n\t\t[haystack, needle] = [str(haystack), str(needle)];\n\n\t\tvar i = _.search(haystack, needle);\n\t\treturn  i > -1 && i === haystack.length - needle.length;\n\t}, {\n\t\tmultiValued: true,\n\t}),\n\n\tjoin: function(array, glue) {\n\t\treturn Mavo.toArray(array).filter(a => !empty(a)).join(str(glue));\n\t},\n\n\tidify: $.extend(readable => {\n\t\treturn str(readable)\n\t\t\t.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\") // Convert accented letters to ASCII\n\t\t\t.replace(/[^\\w\\s-]/g, \"\") // Remove remaining non-ASCII characters\n\t\t\t.trim().replace(/\\s+/g, \"-\") // Convert whitespace to hyphens\n\t\t\t.toLowerCase();\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\t// Convert an identifier to readable text that can be used as a label\n\treadable: $.extend(identifier => {\n\t\t// Is it camelCase?\n\t\treturn str(identifier)\n\t\t\t\t.replace(/([a-z])([A-Z])(?=[a-z])/g, ($0, $1, $2) => $1 + \" \" + $2.toLowerCase()) // camelCase?\n\t\t\t\t.replace(/([a-z0-9])[_\\/-](?=[a-z0-9])/g, \"$1 \") // Hyphen-separated / Underscore_separated?\n\t\t\t\t.replace(/^[a-z]/, $0 => $0.toUpperCase()); // Capitalize\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\tuppercase: $.extend(text => str(text).toUpperCase(), {\n\t\tmultiValued: true\n\t}),\n\tlowercase: $.extend(text => str(text).toLowerCase(), {\n\t\tmultiValued: true\n\t}),\n\n\tfrom: $.extend((haystack, needle) => _.between(haystack, needle), {\n\t\tmultiValued: true,\n\t}),\n\n\tfromlast: $.extend((haystack, needle) => _.between(haystack, needle, \"\", true), {\n\t\tmultiValued: true,\n\t}),\n\n\tto: $.extend((haystack, needle) => _.between(haystack, \"\", needle), {\n\t\tmultiValued: true,\n\t}),\n\n\ttofirst: $.extend((haystack, needle) => _.between(haystack, \"\", needle, true), {\n\t\tmultiValued: true,\n\t}),\n\n\tbetween: $.extend((haystack, from, to, tight) => {\n\t\t[haystack, from, to] = [str(haystack), str(from), str(to)];\n\n\t\tlet fromIndex = from? haystack[tight? \"lastIndexOf\" : \"indexOf\"](from) : 0;\n\t\tlet toIndex = to? haystack[tight? \"indexOf\" : \"lastIndexOf\"](to) : haystack.length;\n\n\t\tif (fromIndex === -1 || toIndex === -1) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tif (tight && toIndex <= fromIndex){\n\t\t\treturn haystack.slice(toIndex + to.length, fromIndex);\n\t\t}\n\n\t\treturn haystack.slice(fromIndex + from.length, toIndex);\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\tphrase: $.extend(function(id, vars, lang) {\n\t\tif (arguments.length === 2 && $.type(vars) === \"string\") {\n\t\t\t[lang, vars] = [vars];\n\t\t}\n\n\t\tlet locale = lang? Mavo.Locale.get(lang) : (this?.[Mavo.mavo]?.locale ?? Mavo.Locale.default);\n\n\t\treturn locale.phrase(id, vars);\n\t}, {\n\t\tneedsContext: true\n\t}),\n\n\tfilename: $.extend(url => new URL(str(url), Mavo.base).pathname.match(/[^/]+?$/)?.[0], {\n\t\tmultiValued: true\n\t}),\n\n\tjson: data => Mavo.safeToJSON(data),\n\n\tsplit: $.extend((text, separator = /\\s+/) => {\n\t\tif (!text) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttext = str(text);\n\n\t\treturn text.split(separator);\n\t}, {\n\t\tmultiValued: true\n\t}),\n\n\t// Log to the console and return\n\tlog: (...args) => {\n\t\tconsole.log(...args.map(val));\n\t\treturn args[0];\n\t},\n\n\t// Other special variables (some updated via events)\n\t$mouse: {x: 0, y: 0},\n\n\tget $hash() {\n\t\treturn location.hash.slice(1);\n\t},\n\n\tget $alt() {\n\t\treturn _.$evt? _.$evt.altKey : false;\n\t},\n\n\tget $ctrl() {\n\t\treturn _.$evt? _.$evt.ctrlKey : false;\n\t},\n\n\tget $shift() {\n\t\treturn _.$evt? _.$evt.shiftKey : false;\n\t},\n\n\tget $cmd() {\n\t\treturn _.$evt? _.$evt[Mavo.superKey] : false;\n\t},\n\n\t// \"Private\" helpers\n\tutil: {\n\t\tnumbers: function(array, args) {\n\t\t\tarray = Array.isArray(array)? array : (args? $$(args) : [array]);\n\n\t\t\treturn array.filter(number => !isNaN(number) && val(number) !== \"\" && val(number) !== null).map(n => +n);\n\t\t},\n\n\t\t// Implement function metadata\n\t\tpostProcess: function(callback) {\n\t\t\tvar multiValued = callback.multiValued;\n\t\t\tvar newCallback;\n\n\t\t\tif (multiValued === true || multiValued?.length === 2) {\n\t\t\t\tnewCallback = (...args) => {\n\t\t\t\t\t// Define index of multiValued arguments\n\t\t\t\t\t// Fallback to first 2 arguments if not explicitly defined\n\t\t\t\t\tvar idxA = multiValued[0] || 0;\n\t\t\t\t\tvar idxB = multiValued[1] || 1;\n\n\t\t\t\t\treturn Mavo.Script.binaryOperation(args[idxA], args[idxB], {\n\t\t\t\t\t\tscalar: (a, b) => {\n\t\t\t\t\t\t\t// Replace multiValued argument with its individual elements\n\t\t\t\t\t\t\tif (idxA in args) {\n\t\t\t\t\t\t\t\targs[idxA] = a;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (idxB in args) {\n\t\t\t\t\t\t\t\targs[idxB] = b;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn callback(...args);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...callback\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (callback.isAggregate) {\n\t\t\t\tnewCallback = function(array) {\n\t\t\t\t\tif (Mavo.in(Mavo.groupedBy, array)) { // grouped structures\n\t\t\t\t\t\treturn array.map(e => newCallback(e.$items));\n\t\t\t\t\t}\n\n\t\t\t\t\tvar ret = callback.call(this, ...arguments);\n\n\t\t\t\t\treturn ret === undefined? array : ret;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (newCallback) {\n\t\t\t\t// Preserve function metadata\n\t\t\t\t$.extend(newCallback, callback);\n\t\t\t\tnewCallback.original = callback;\n\t\t\t}\n\n\t\t\tif (callback.alias) {\n\t\t\t\tfor (let alias of Mavo.toArray(callback.alias)) {\n\t\t\t\t\tMavo.Functions[alias] = newCallback || callback;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newCallback;\n\t\t}\n\t}\n};\n\nvar $u = _.util;\n\n/**\n * After plugins are loaded, enable\n * multi-valued arguments of Mavo and Math functions\n */\nMavo.ready.then(() => {\n\tObject.getOwnPropertyNames(Mavo.Functions).forEach(property => {\n\t\tvar newCallback = $u.postProcess(Mavo.Functions[property]);\n\n\t\tif (newCallback) {\n\t\t\tMavo.Functions[property] = newCallback;\n\t\t}\n\t});\n\n\t// Deal with Math functions that have 1 argument\n\tObject.getOwnPropertyNames(Math).forEach(property => {\n\t\tif (Math[property].length === 1 && !Mavo.Functions.hasOwnProperty(property)) {\n\t\t\tMavo.Functions[property] = operand => Mavo.Script.unaryOperation(operand, operand => Math[property](operand));\n\t\t}\n\t});\n});\n\n/**\n * Private helper methods\n */\n\n// Convert argument to string\nfunction str(str = \"\") {\n\tstr = val(str);\n\treturn !str && str !== 0? \"\" : str + \"\";\n}\n\nfunction empty(v) {\n\tv = Mavo.value(v);\n\treturn v === null || v === false || v === \"\";\n}\n\nfunction not(v) {\n\treturn !val(v);\n}\n\n})(Bliss, Mavo.value);\n","/**\n * Date Functions available inside Mavo expressions\n */\n\n(function($, val, _, $u = _.util) {\n\nvar s = {seconds: 1, minutes: 60};\ns.hours  = s.minutes * 60;\ns.days   = s.hours   * 24;\ns.weeks  = s.days    * 7;\ns.months = s.days    * 30.4368;\ns.years  = s.weeks   * 52;\n\nvar numeric = {\n\tyear: d => d.getFullYear(),\n\tmonth: d => d.getMonth() + 1,\n\tday: d => d.getDate(),\n\tweekday: d => d.getDay() || 7,\n\thour: d => d.getHours(),\n\tminute: d => d.getMinutes(),\n\tsecond: d => d.getSeconds(),\n\tms: d => d.getMilliseconds()\n};\n\nfunction isPrecision (precision) {\n\tif (!precision) {\n\t\treturn false;\n\t}\n\n\tif (precision == \"ms\") {\n\t\treturn true;\n\t}\n\n\tlet singular = precision.replace(/s$/, \"\");\n\tlet plural = precision.replace(/s?$/, \"s\");\n\n\treturn singular in s || plural in s;\n}\n\nfunction parsePrecision(precision) {\n\tprecision = precision?.trim() || \"\";\n\tlet keys = Object.keys(s).reverse();\n\tlet ret = {};\n\n\tdo {\n\t\tp = keys.shift();\n\t\tret[p] = true;\n\t} while(!RegExp(p + \"?\").test(precision) && keys.length > 0);\n\n\tif (precision == \"ms\") {\n\t\tret.ms = true;\n\t}\n\n\treturn ret;\n}\n\n$.extend(_, {\n\tget $now() {\n\t\treturn new Date();\n\t},\n\n\t$startup: new Date(), // Like $now, but doesn't update\n\n\tget $today() {\n\t\treturn _.date(new Date());\n\t},\n\n\tyear: $.extend(function() {\n\t\treturn $u.dateComponent(\"year\", ...arguments);\n\t}, {multiValued: true}),\n\n\tmonth: $.extend(function() {\n\t\treturn $u.dateComponent(\"month\", ...arguments);\n\t}, {multiValued: true}),\n\n\tweek: () => s.weeks * 1000,\n\n\tday: $.extend(function() {\n\t\treturn $u.dateComponent(\"day\", ...arguments);\n\t}, {multiValued: true}),\n\n\tweekday: $.extend(function() {\n\t\treturn $u.dateComponent(\"weekday\", ...arguments);\n\t}, {multiValued: true}),\n\n\thour: $.extend(function() {\n\t\treturn $u.dateComponent(\"hour\", ...arguments);\n\t}, {multiValued: true}),\n\n\tminute: $.extend(function() {\n\t\treturn $u.dateComponent(\"minute\", ...arguments);\n\t}, {multiValued: true}),\n\n\tsecond: $.extend(function() {\n\t\treturn $u.dateComponent(\"second\", ...arguments);\n\t}, {multiValued: true}),\n\n\tms: $.extend(function() {\n\t\treturn $u.dateComponent(\"ms\", ...arguments);\n\t}, {multiValued: true}),\n\n\t// Return an ISO date & time string\n\tdatetime: $.extend((date, time, precision) => {\n\t\tdate = $u.date(date);\n\n\t\tif (!date) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet separateTime;\n\t\tif (time !== undefined) {\n\t\t\tif (isPrecision(time)) {\n\t\t\t\t[time, precision] = [, time];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tseparateTime = true;\n\t\t\t}\n\t\t}\n\n\t\tprecision ??= \"minutes\";\n\t\tlet parts = parsePrecision(precision);\n\t\tlet ret = _.date(date, precision);\n\n\t\tif (!parts.hours) {\n\t\t\treturn ret; // No time\n\t\t}\n\n\t\tif (separateTime) {\n\t\t\t// If time is provided separately, and it's empty, we just return a date\n\t\t\tret += Mavo.value(time) ? `T${ _.time(time, precision) }` : \"\";\n\t\t}\n\t\telse {\n\t\t\tret += `T${_.time(date, precision)}`;\n\t\t}\n\n\t\treturn ret;\n\t}, {multiValued: true}),\n\n\t// Return an ISO date\n\tdate: $.extend((date, precision = \"days\") => {\n\t\tdate = $u.date(date);\n\n\t\tif (!date) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet parts = parsePrecision(precision);\n\t\tlet ret = [];\n\n\t\tif (parts.years) {\n\t\t\tret.push(_.year(date));\n\t\t}\n\n\t\tif (parts.months) {\n\t\t\tret.push(_.month(date, \"00\"));\n\t\t}\n\n\t\tif (parts.days) {\n\t\t\tret.push(_.day(date, \"00\"));\n\t\t}\n\n\t\treturn ret.join(\"-\");\n\t}, {multiValued: true}),\n\n\t// Return an ISO time\n\ttime: $.extend((date, precision = \"minutes\") => {\n\t\tdate = $u.date(date);\n\n\t\tif (!date) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet parts = parsePrecision(precision);\n\t\tlet ret = \"\";\n\n\t\tif (parts.hours) {\n\t\t\tret += _.hour(date, \"00\") + \":\" + (parts.minutes? _.minute(date, \"00\") : \"00\");\n\n\t\t\tif (parts.seconds) {\n\t\t\t\tret += \":\" + _.second(date, \"00\");\n\n\t\t\t\tif (parts.ms) {\n\t\t\t\t\tret += \".\" + _.ms(date, \"000\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}, {multiValued: true}),\n\n\treadable_datetime: $.extend((date, ...options) => {\n\t\toptions = options.map(o => typeof o === \"string\" || o instanceof String? {precision: o} : o);\n\t\toptions = Object.assign({}, ...options);\n\n\t\tlet parts = parsePrecision(options.precision);\n\t\tlet monthFormat = options.month || parts.days? \"shortname\" : \"long\";\n\t\tlet ret = [];\n\n\t\tif (parts.days) {\n\t\t\tret.push(_.day(date));\n\t\t}\n\n\t\tif (parts.months) {\n\t\t\tret.push(_.month(date, monthFormat));\n\t\t}\n\n\t\tif (parts.years) {\n\t\t\tret.push(_.year(date));\n\t\t}\n\n\t\tif (parts.hours) {\n\t\t\tret.push(_.time(date, options.precision));\n\t\t}\n\n\t\treturn ret.join(\" \");\n\t}, {multiValued: true}),\n\n\tlocalTimezone: -(new Date()).getTimezoneOffset(),\n});\n\n_.msTo = (what, ms) => Math.floor(Math.abs(ms) / (s[what] * 1000)) || 0;\n\nfor (let unit in s) {\n\t_[unit] = $.extend(function(ms) {\n\t\tif (arguments.length === 0) {\n\t\t\treturn s[unit] * 1000;\n\t\t}\n\n\t\treturn _.msTo(unit, ms);\n\t}, {multiValued: true});\n}\n\n_.duration = $.extend(function (ms, terms) {\n\t// TODO unify code for specific unit with code for auto units to reduce repetition\n\t// TODO allow multiple units, e.g. [\"days\", \"hours\"]\n\t// TODO allow combining term # and units, e.g. start: days, terms: 2\n\t\n\tlet negativeMultiplier = ms < 0 ? -1 : 1; // a multiplier to convert result to negative if needed\n\tms = Math.abs(ms); // negative works same way as positive does, just adding negative sign in the front\n\n\tif (terms && isNaN(terms)) {\n\t\t// Specific term specified\n\t\tlet unitSingular = terms != \"ms\" ? terms.replace(/s?$/, \"\") : terms;\n\t\tlet unitPlural = terms.replace(/s?$/, \"s\");\n\n\t\tif (!(unitPlural in s)) {\n\t\t\tthrow new TypeError(`Unknown duration unit ${terms}. Please use one of ${ Object.keys(s).join(\", \") }`);\n\t\t}\n\n\t\tlet n = Math.floor(ms / s[unitPlural] / 1000);\n\t\tlet unitProperPlurality = n === 1 && unitPlural !== \"ms\" ? unitSingular : unitPlural;\n\t\treturn negativeMultiplier * n + \" \" + _.phrase.call(this, unitProperPlurality);\n\t}\n\telse if (ms == 0 || terms === undefined) {\n\t\tterms = 1;\n\t}\n\n\tlet timeLeft = ms;\n\tlet ret = [];\n\n\tif (ms == 0) {\n\t\tret = [\"0 ms\"];\n\t}\n\telse {\n\t\tlet units = [...Object.keys(s).reverse(), \"ms\"];\n\n\t\tfor (let i=0, unit; unit = units[i]; i++) {\n\t\t\t// get largest value of time unit for the remaining\n\t\t\t// time to account for\n\t\t\tlet unitMs = unit in s? s[unit] * 1000 : 1; // number of ms in 1 unit\n\t\t\tlet unitValue = Math.floor(timeLeft / unitMs); // quotient\n\t\t\ttimeLeft = timeLeft % unitMs; // remainder\n\n\t\t\tif (unitValue > 0 && ret.length < terms) {\n\t\t\t\tlet unitProperPlurality = unitValue === 1 && unit !== \"ms\" ? unit.slice(0, -1) : unit;\n\t\t\t\tret.push(negativeMultiplier * unitValue + \" \" + _.phrase.call(this, unitProperPlurality));\n\t\t\t}\n\t\t\telse if (ret.length > 0) {\n\t\t\t\t// Discard any further terms to avoid non-continous terms like e.g. \"1 month, 10 ms\"\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn arguments.length === 1 ? ret[0] : ret;\n}, {\n\tneedsContext: true,\n\tmultiValued: true\n});\n\n$.extend(_.util, {\n\tfixDateString: function(date) {\n\t\tdate = date.trim();\n\n\t\tvar hasDate = /^\\d{4}-\\d{2}(-\\d{2})?/.test(date);\n\t\tvar hasTime = date.indexOf(\":\") > -1;\n\n\t\tif (!hasDate && !hasTime) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Fix up time format\n\t\tif (!hasDate) {\n\t\t\t// No date, add todays\n\t\t\tdate = _.$today + \" \" + date;\n\t\t}\n\t\telse {\n\t\t\t// Only year-month, add day\n\t\t\tdate = date.replace(/^(\\d{4}-\\d{2})(?!-\\d{2})/, \"$1-01\");\n\t\t}\n\n\t\tif (!hasTime) {\n\t\t\t// Add a time if one doesn't exist\n\t\t\tdate += \"T00:00:00\";\n\t\t}\n\t\telse {\n\t\t\t// Make sure time starts with T, due to Safari bug\n\t\t\tdate = date.replace(/\\-(\\d{2})\\s+(?=\\d{2}:)/, \"-$1T\");\n\t\t}\n\n\t\t// Remove all whitespace\n\t\tdate = date.replace(/\\s+/g, \"\");\n\n\t\treturn date;\n\t},\n\n\tdateComponent: function(component, date, format, locale = Mavo.locale) {\n\t\tif (arguments.length === 1 && component + \"s\" in s) {\n\t\t\treturn _[component + \"s\"]();\n\t\t}\n\n\t\tvar dateO = $u.date(date);\n\n\t\tif (component === \"year\") {\n\t\t\t// Why +\"\"? We don't want years to be formatted like 2,017!\n\t\t\t// Why the .match()? For incomplete dates, see #226\n\t\t\tdate = date && date.match? date : date + \"\";\n\t\t\tvar ret = dateO? dateO.getFullYear() + \"\" : (date.match(/\\b[1-9]\\d\\d\\b|\\d+/) || [])[0];\n\t\t}\n\n\t\tif (!ret && !dateO) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tvar ret = ret || numeric[component](dateO);\n\n\t\tif (format) {\n\t\t\tif (/^0+$/.test(format)) {\n\t\t\t\t// Leading zeroes\n\t\t\t\treturn (ret + \"\").padStart(format.length, \"0\").slice(-format.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tformat = {name: \"long\", shortname: \"short\"}[format] || format;\n\t\t\t\tret = dateO.toLocaleString(locale, {[component]: format});\n\t\t\t\tret = ret.replace(/\\u200e/g, \"\"); // Stupid Edge bug\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\treturn component === \"year\"? ret : +ret;\n\t},\n\n\tdate: function(date) {\n\t\tdate = val(date);\n\n\t\tif (!date) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar object = new Date(date);\n\n\t\t// Either arg is not string or is exactly the same as a re-serialization of it as a date\n\t\tif ($.type(date) !== \"string\" || !isNaN(object) && (object + \"\" == date)) {\n\t\t\treturn object;\n\t\t}\n\n\t\tdate = $u.fixDateString(date);\n\n\t\tif (date === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar timezone = date.match(/[+-]\\d{2}:?\\d{2}|Z$/)?.[0];\n\n\t\tif (timezone) {\n\t\t\t// parse as ISO format\n\t\t\tdate = new Date(date);\n\t\t}\n\t\telse {\n\t\t\t// construct date in local timezone\n\t\t\tvar fields = date.match(/\\d+/g);\n\n\t\t\tdate = new Date(\n\t\t\t\t// year, month, date,\n\t\t\t\tfields[0], (fields[1] || 1) - 1, fields[2] || 1,\n\t\t\t\t// hours, minutes, seconds, milliseconds,\n\t\t\t\tfields[3] || 0, fields[4] || 0, fields[5] || 0, fields[6] || 0\n\t\t\t);\n\t\t}\n\n\t\treturn isNaN(date)? null : date;\n\t}\n});\n\n})(Bliss, Mavo.value, Mavo.Functions);\n","(function($, val, $u) {\n\nvar _ = Mavo.Script = {\n\t$fn: self.Proxy? new Proxy({[Symbol.unscopables]: {undefined: true}}, {\n\t\tget: (data, property) => {\n\t\t\tvar propertyL = property?.toLowerCase?.() ?? property, ret;\n\n\t\t\t// Is this a data action function?\n\t\t\tif (propertyL in Mavo.Actions.Functions) {\n\t\t\t\tif (Mavo.Actions.running) {\n\t\t\t\t\tret = Mavo.Actions.Functions[propertyL];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = Mavo.Actions.nope;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Is this a Mavo function?\n\t\t\tif (ret === undefined) {\n\t\t\t\tif (propertyL in Mavo.Functions) {\n\t\t\t\t\tret = Mavo.Functions[propertyL];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Maybe it's a Math function?\n\t\t\t\t\tret = Math[property] || Math[propertyL];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\thas: (data, property) => {\n\t\t\tvar propertyL = property.toLowerCase();\n\n\t\t\treturn propertyL in Mavo.Functions || propertyL in Mavo.Actions.Functions\n\t\t\t\t   || property in Math || propertyL in Math;\n\t\t}\n\t}) : Mavo.Functions,\n\n\taddUnaryOperator: function(name, o) {\n\t\tif (o.symbol) {\n\t\t\t// Build map of symbols to function names for easy rewriting\n\t\t\tMavo.toArray(o.symbol).forEach(symbol => {\n\t\t\t\t_.unarySymbols[symbol] = name;\n\t\t\t\tjsep.addUnaryOp(symbol);\n\t\t\t});\n\t\t}\n\n\t\treturn operand => _.unaryOperation(operand, operand => o.scalar(val(operand)));\n\t},\n\n\tunaryOperation: function(operand, scalar) {\n\t\tif (Array.isArray(operand)) {\n\t\t\treturn operand.map(scalar);\n\t\t}\n\t\telse {\n\t\t\treturn scalar(operand);\n\t\t}\n\t},\n\n\tbinaryOperation: function(a, b, o = {}) {\n\t\to.scalar = typeof o === \"function\" ? o : o.scalar;\n\t\tvar result;\n\n\t\tif (Array.isArray(b)) {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\tresult = [];\n\t\t\t\tvar max = Math.max(a.length, b.length);\n\t\t\t\tvar leftUnary = o.leftUnary || o.unary;\n\t\t\t\tvar rightUnary = o.rightUnary || o.unary;\n\t\t\t\tvar leftDefault = o.leftDefault === undefined ? o.default : o.leftDefault;\n\t\t\t\tvar rightDefault = o.rightDefault === undefined ? o.default : o.rightDefault;\n\n\t\t\t\tfor (let i = 0; i < max; i++) {\n\t\t\t\t\tif (o.comparison && (a[i] === undefined || b[i] === undefined)) {\n\t\t\t\t\t\tresult[i] = o.default;\n\t\t\t\t\t}\n\t\t\t\t\telse if (a[i] === undefined) {\n\t\t\t\t\t\tresult[i] = rightUnary ? rightUnary(b[i]) : o.scalar(leftDefault, b[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (b[i] === undefined) {\n\t\t\t\t\t\tresult[i] = leftUnary ? leftUnary(a[i]) : o.scalar(a[i], rightDefault);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult[i] = o.scalar(a[i], b[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = b.map(n => o.scalar(a, n));\n\t\t\t}\n\t\t}\n\t\telse if (Array.isArray(a)) {\n\t\t\tresult = a.map(n => o.scalar(n, b));\n\t\t}\n\t\telse {\n\t\t\tresult = o.scalar(a, b);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Extend a scalar operator to arrays, or arrays and scalars\n\t * The operation between arrays is applied element-wise.\n\t * The operation operation between a scalar and an array will result in\n\t * the operation being applied between the scalar and every array element.\n\t */\n\taddBinaryOperator: function(name, o) {\n\t\tif (o.symbol) {\n\t\t\t// Build map of symbols to function names for easy rewriting\n\t\t\tMavo.toArray(o.symbol).forEach(symbol => {\n\t\t\t\t_.symbols[symbol] = name;\n\n\t\t\t\tif (o.precedence) {\n\t\t\t\t\tjsep.addBinaryOp(symbol, o.precedence);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\to.default = o.default === undefined? 0 : o.default;\n\n\t\treturn o.code || function(...operands) {\n\t\t\tif (operands.length === 1) {\n\t\t\t\tif (Array.isArray(operands[0])) {\n\t\t\t\t\t// Operand is an array of operands, expand it out\n\t\t\t\t\toperands = [...operands[0]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!o.raw) {\n\t\t\t\toperands = operands.map(val);\n\t\t\t}\n\n\t\t\tvar prev = o.comparison ? true : operands[0], result;\n\n\t\t\tfor (let i = 1; i < operands.length; i++) {\n\t\t\t\tlet a = o.comparison? operands[i - 1] : prev;\n\t\t\t\tlet b = operands[i];\n\n\t\t\t\tif (Array.isArray(b) && typeof o.default == \"number\") {\n\t\t\t\t\tb = $u.numbers(b);\n\t\t\t\t}\n\n\t\t\t\tvar result = _.binaryOperation(a, b, o);\n\n\t\t\t\tif (o.comparison) {\n\t\t\t\t\tprev = _.binaryOperation(prev, result, _.operators[\"and\"]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprev = result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn prev;\n\t\t};\n\t},\n\n\t/**\n\t * Mapping of operator symbols (strings) to function names (strings).\n\t * Populated via addOperator() and addLogicalOperator()\n\t */\n\tsymbols: {},\n\tunarySymbols: {},\n\n\tgetOperatorName: (op, unary) => _[unary? \"unarySymbols\" : \"symbols\"][op] || op,\n\n\tisComparisonOperator: (op) => {\n\t\t// decides if op, a string, is a comparison operator like < or <=\n\t\tif (op) {\n\t\t\tlet operatorDefinition = _.operators[_.symbols[op]];\n\t\t\treturn operatorDefinition && operatorDefinition.comparison;\n\t\t}\n\t},\n\n\t// Is this variable?\n\t// E.g. foo or foo.bar is not static whereas \"foo\" or bar() is\n\tisStatic: node => {\n\t\tif (node.type === \"Identifier\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let property of _.childProperties) {\n\t\t\tif (node[property] && property !== \"callee\") {\n\t\t\t\tif (!_.isStatic(node[property])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Operations for elements and scalars.\n\t * Operations between arrays happen element-wise.\n\t * Operations between a scalar and an array will result in the operation being performed between the scalar and every array element.\n\t * Ordered by precedence (higher to lower)\n\t * @param scalar {Function} The operation between two scalars\n\t * @param unary/leftUnary/rightUnary Custom versions of scalar for when there is only 1 operand.\n\t * @param precedence {Number}\n\t * @param symbol {String} The operator's symbol\n\t * @param default The operations default/identity element. Defaults to 0.\n\t *                There are also leftDefault and rightDefault options if needed.\n\t * @param export {Boolean} Whether to add the resulting function to Mavo.Functions. It will always be available on Mavo.Script.operators[name].code anyway. Default: true\n\t * @param code {Function} The full implementation of the operator (including handling for array operands), if one prefers to provide instead of have it be generated.\n\t * @param transformation {Function}\n\t * @param postFlattenTransformation {Function}\n\t * @param raw {Boolean} If true, do not use Mavo.value() on operands\n\t */\n\toperators: {\n\t\t\"not\": {\n\t\t\tsymbol: \"!\",\n\t\t\tscalar: a => !val(a)\n\t\t},\n\t\t\"multiply\": {\n\t\t\tscalar: (a, b) => a * b,\n\t\t\tdefault: 1,\n\t\t\tsymbol: \"*\"\n\t\t},\n\t\t\"divide\": {\n\t\t\tscalar: (a, b) => a / b,\n\t\t\trightUnary: b => b,\n\t\t\tdefault: 1,\n\t\t\tsymbol: \"/\"\n\t\t},\n\t\t\"addition\": {\n\t\t\tscalar: (a, b) => {\n\t\t\t\tif (isNaN(a) || isNaN(b)) {\n\t\t\t\t\t// Handle dates\n\t\t\t\t\tvar dateA = $u.date(a), dateB = $u.date(b);\n\n\t\t\t\t\tif (dateA || dateB) {\n\t\t\t\t\t\treturn +dateA + +dateB;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn +a + +b;\n\t\t\t},\n\t\t\tsymbol: \"+\"\n\t\t},\n\t\t\"plus\": {\n\t\t\tscalar: a => +a,\n\t\t\tsymbol: \"+\"\n\t\t},\n\t\t\"subtract\": {\n\t\t\tscalar: (a, b) => {\n\t\t\t\tif (isNaN(a) || isNaN(b)) {\n\t\t\t\t\t// Handle dates\n\t\t\t\t\tvar dateA = $u.date(a), dateB = $u.date(b);\n\n\t\t\t\t\tif (dateA && dateB) {\n\t\t\t\t\t\treturn dateA - dateB;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn a - b;\n\t\t\t},\n\t\t\tsymbol: \"-\"\n\t\t},\n\t\t\"minus\": {\n\t\t\tscalar: a => -a,\n\t\t\tsymbol: \"-\"\n\t\t},\n\t\t\"mod\": {\n\t\t\tscalar: (a, b) => {\n\t\t\t\tvar ret = a % b;\n\t\t\t\tret += ret < 0? b : 0;\n\t\t\t\treturn ret;\n\t\t\t},\n\t\t\tsymbol: \"mod\",\n\t\t\tprecedence: 10\n\t\t},\n\t\t\"lte\": {\n\t\t\tcomparison: true,\n\t\t\tscalar: (a, b) => {\n\t\t\t\t[a, b] = _.getNumericalOperands(a, b);\n\t\t\t\treturn a <= b;\n\t\t\t},\n\t\t\tdefault: false,\n\t\t\tsymbol: \"<=\"\n\t\t},\n\t\t\"lt\": {\n\t\t\tcomparison: true,\n\t\t\tscalar: (a, b) => {\n\t\t\t\t[a, b] = _.getNumericalOperands(a, b);\n\t\t\t\treturn a < b;\n\t\t\t},\n\t\t\tdefault: false,\n\t\t\tsymbol: \"<\"\n\t\t},\n\t\t\"gte\": {\n\t\t\tcomparison: true,\n\t\t\tscalar: (a, b) => {\n\t\t\t\t[a, b] = _.getNumericalOperands(a, b);\n\t\t\t\treturn a >= b;\n\t\t\t},\n\t\t\tdefault: false,\n\t\t\tsymbol: \">=\"\n\t\t},\n\t\t\"gt\": {\n\t\t\tcomparison: true,\n\t\t\tscalar: (a, b) => {\n\t\t\t\t[a, b] = _.getNumericalOperands(a, b);\n\t\t\t\treturn a > b;\n\t\t\t},\n\t\t\tdefault: false,\n\t\t\tsymbol: \">\"\n\t\t},\n\t\t\"eq\": {\n\t\t\tcomparison: true,\n\t\t\tscalar: (a, b) => {\n\t\t\t\treturn a == b || Mavo.safeToJSON(a) === Mavo.safeToJSON(b);\n\t\t\t},\n\t\t\tsymbol: [\"=\", \"==\"],\n\t\t\tdefault: false,\n\t\t\tprecedence: 7 // to match other comparison operators in jsep\n\t\t},\n\t\t\"neq\": {\n\t\t\tcomparison: true,\n\t\t\tscalar: (a, b) => {\n\t\t\t\treturn a != b && Mavo.safeToJSON(a) !== Mavo.safeToJSON(b);\n\t\t\t},\n\t\t\tsymbol: [\"!=\"],\n\t\t\tdefault: true,\n\t\t\tprecedence: 7 // to match other comparison operators in jsep\n\t\t},\n\t\t\"and\": {\n\t\t\tscalar: (a, b) => a && b,\n\t\t\tdefault: false,\n\t\t\tsymbol: [\"&&\", \"and\"],\n\t\t\tprecedence: 2\n\t\t},\n\t\t\"or\": {\n\t\t\tscalar: (a, b) => a || b,\n\t\t\tdefault: false,\n\t\t\tsymbol: [\"||\", \"or\"],\n\t\t\tprecedence: 2\n\t\t},\n\t\t\"concatenate\": {\n\t\t\tsymbol: \"&\",\n\t\t\tdefault: \"\",\n\t\t\tscalar: (a, b) => {\n\t\t\t\ta = Mavo.value(a) ?? \"\";\n\t\t\t\tb = Mavo.value(b) ?? \"\";\n\n\t\t\t\treturn \"\" + a + b;\n\t\t\t},\n\t\t\tprecedence: 10\n\t\t},\n\t\t\"keyvalue\": {\n\t\t\tsymbol: \":\",\n\t\t\tcode: (...operands) => {\n\t\t\t\tvar i = operands.length - 1;\n\t\t\t\tvar value = operands[i];\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tvalue = {[operands[i]]: value};\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\ttransformation: node => {\n\t\t\t\t// Allow unquoted property names, just like JS\n\t\t\t\tif (node.left.type == \"Identifier\") {\n\t\t\t\t\tnode.left = {\n\t\t\t\t\t\ttype: \"Literal\",\n\t\t\t\t\t\tvalue: node.left.name,\n\t\t\t\t\t\traw: JSON.stringify(node.left.name)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t\tprecedence: 4\n\t\t},\n\t\t\"filter\": {\n\t\t\tsymbol: \"where\",\n\t\t\tcode: (a, ...filters) => {\n\t\t\t\tfor (let b of filters) {\n\t\t\t\t\tif (Array.isArray(a)) {\n\t\t\t\t\t\tif (Array.isArray(b)) {\n\t\t\t\t\t\t\ta = a.map((v, i) => val(b[i])? v : null);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tb = val(b);\n\n\t\t\t\t\t\t\tif (typeof b === \"boolean\") {\n\t\t\t\t\t\t\t\t// foo where true/false should equal foo/null respectively\n\t\t\t\t\t\t\t\ta = b? a : a.map(v => null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// foo where 5 should equal foo where foo = 5\n\t\t\t\t\t\t\t\ta = a.map(v => v == b? v : null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ta = val(b)? a : null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t\t},\n\t\t\tprecedence: 1,\n\t\t\tpostFlattenTransformation: node => {\n\t\t\t\t// Scope all identifiers (likely properties) in the where clause to the thing we're filtering from.\n\t\t\t\t// For example, assume you have a list of people and a list of cats, both with names and ages.\n\t\t\t\t// Without this, cat where age > 3 would return nonsensical results\n\t\t\t\tvar object = node.arguments[0];\n\n\t\t\t\tfor (let i=1; i<node.arguments.length; i++) {\n\t\t\t\t\tif (!_.isStatic(node.arguments[i])) {\n\t\t\t\t\t\tnode.arguments[i] = Object.assign(_.parse(\"scope()\"), {\n\t\t\t\t\t\t\targuments: [\n\t\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\t\tnode.arguments[i]\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"range\": {\n\t\t\tsymbol: \"..\",\n\t\t\tscalar: (a, b) => Mavo.Functions.range(a, b),\n\t\t\tprecedence: 2,\n\t\t\texport: false\n\t\t},\n\t\t\"has\": {\n\t\t\tsymbol: \"in\",\n\t\t\tcode: function(needle, ...haystacks) {\n\t\t\t\tvar ret;\n\t\t\t\thaystacks.map(b => {\n\t\t\t\t\tif (Array.isArray(b)) {\n\t\t\t\t\t\tvar op =  a => {\n\t\t\t\t\t\t\t// If object, comparison will fail because references. Must serialize first.\n\t\t\t\t\t\t\tvar fn = $.type(val(a)) === \"object\"? Mavo.safeToJSON : val;\n\n\t\t\t\t\t\t\treturn b.map(fn).indexOf(fn(a)) > -1;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\telse if ($.type(b) === \"object\") {\n\t\t\t\t\t\t// Mimic JS' in operator\n\t\t\t\t\t\tvar op = a => Mavo.in(val(a), b);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar op = a => Mavo.Functions.eq(a, b);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = Mavo.Script.unaryOperation(needle, op);\n\t\t\t\t\tret = ret === undefined? result : Mavo.Functions.and(result, ret);\n\t\t\t\t});\n\t\t\t\treturn ret;\n\t\t\t},\n\t\t\tprecedence: 3\n\t\t},\n\t\t\"groupby\": {\n\t\t\tsymbol: \"by\",\n\t\t\tcode: (array, key) => {\n\t\t\t\tarray = Mavo.toArray(array);\n\t\t\t\tkey = Mavo.toArray(key);\n\t\t\t\tvar property = key[Mavo.as] || key[0]?.[Mavo.toNode]?.property;\n\t\t\t\tvar groups = new Mavo.BucketMap({arrays: true});\n\t\t\t\tvar ret = [];\n\t\t\t\tret[Mavo.groupedBy] = true;\n\n\t\t\t\tarray.forEach((item, i) => {\n\t\t\t\t\tlet k = i < key.length ? Mavo.value(key[i]) : null;\n\t\t\t\t\tgroups.set(k, item);\n\t\t\t\t});\n\n\t\t\t\tif (Mavo.in(Mavo.route, array)) {\n\t\t\t\t\tret[Mavo.route] = Object.assign({}, array[Mavo.route]);\n\t\t\t\t}\n\n\t\t\t\tgroups.forEach((items, value) => {\n\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t$value: value,\n\t\t\t\t\t\t[property || \"$value\"]: value,\n\t\t\t\t\t\t$items: items\n\t\t\t\t\t};\n\n\t\t\t\t\tif (Mavo.in(Mavo.route, array)) {\n\t\t\t\t\t\titems[Mavo.route] = obj[Mavo.route] = Object.assign({}, array[Mavo.route]);\n\t\t\t\t\t\tobj[Mavo.route] = $.each(items[Mavo.route], (p, v) => new Set([\"$items\"]));\n\t\t\t\t\t}\n\n\t\t\t\t\tret.push(obj);\n\t\t\t\t});\n\n\t\t\t\treturn Mavo.Data.proxify(ret);\n\t\t\t},\n\t\t\tprecedence: 2\n\t\t},\n\t\t\"as\": {\n\t\t\tsymbol: \"as\",\n\t\t\tcode: (property, name) => {\n\t\t\t\tif (property !== undefined && $.type(property) === \"array\" && name !== undefined) {\n\t\t\t\t\tvar ret = property.slice();\n\n\t\t\t\t\tif (!Array.isArray(name) && name?.[Mavo.toNode]?.property !== undefined) {\n\t\t\t\t\t\tret[Mavo.as] = name?.[Mavo.toNode]?.property;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($.type(name) === \"string\") {\n\t\t\t\t\t\tret[Mavo.as] = name;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (name[0]?.[Mavo.toNode]?.property !== undefined) {\n\t\t\t\t\t\tret[Mavo.as] = name[0]?.[Mavo.toNode]?.property;\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn property;\n\t\t\t\t}\n\t\t\t\treturn property;\n\t\t\t},\n\t\t\tprecedence: 3\n\t\t},\n\t},\n\n\tgetNumericalOperands: function(a, b) {\n\t\tif (isNaN(a) || isNaN(b)) {\n\t\t\t// Try comparing as dates\n\t\t\tvar da = $u.date(a), db = $u.date(b);\n\n\t\t\tif (da && db) {\n\t\t\t\t// Both valid dates\n\t\t\t\treturn [da, db];\n\t\t\t}\n\t\t}\n\n\t\treturn [a, b];\n\t},\n\n\tchildProperties: [\n\t\t\"arguments\", \"callee\", // CallExpression\n\t\t\"left\", \"right\", // BinaryExpression, LogicalExpression\n\t\t\"argument\", // UnaryExpression\n\t\t\"elements\", // ArrayExpression\n\t\t\"test\", \"consequent\", \"alternate\", // ConditionalExpression\n\t\t\"object\",  \"property\", // MemberExpression\n\t\t\"body\"\n\t],\n\n\t/**\n\t * Recursively execute a callback on this node and all its children\n\t * Caveat: For CallExpression arguments, it will call callback with an array\n\t * callback needs to take care of iterating over the array\n\t */\n\twalk: function(node, callback, o = {}, property, parent) {\n\t\tif (!o.type || node.type === o.type) {\n\t\t\tvar ret = callback(node, property, parent);\n\t\t}\n\n\t\tif (!o.ignore || o.ignore.indexOf(node.type) === -1) {\n\t\t\tif (Array.isArray(node)) {\n\t\t\t\tfor (let n of node) {\n\t\t\t\t\t_.walk(n, callback, o, property, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_.childProperties.forEach(property => {\n\t\t\t\t\tif (node[property]) {\n\t\t\t\t\t\t_.walk(node[property], callback, o, property, node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (ret !== undefined && parent) {\n\t\t\t// Apply transformations after walking, otherwise it may recurse infinitely\n\t\t\tparent[property] = ret;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t/**\n\t * These serializers transform the AST into JS\n\t */\n\tserializers: {\n\t\t\"BinaryExpression\": node => `${_.serialize(node.left, node)} ${node.operator} ${_.serialize(node.right, node)}`,\n\t\t\"UnaryExpression\": node => `${node.operator}${_.serialize(node.argument, node)}`,\n\t\t\"CallExpression\": node => {\n\t\t\tvar callee = node.callee;\n\t\t\tlet root = node.callee;\n\t\t\tlet parent = node;\n\t\t\tlet prop = \"callee\";\n\n\t\t\t// Find left-most member\n\t\t\twhile (root.type === \"MemberExpression\") {\n\t\t\t\tparent = root;\n\t\t\t\troot = root.object;\n\t\t\t\tprop = \"object\";\n\t\t\t}\n\n\t\t\tif (node.callee.type === \"MemberExpression\") {\n\t\t\t\tif (node.callee.property.type === \"Identifier\" && node.callee.property.name === \"call\") {\n\t\t\t\t\tcallee = node.callee.object;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (root.type === \"Identifier\") {\n\t\t\t\t// Clashes with native prototype methods? If so, look first in Function trap\n\t\t\t\tvar name = root.name;\n\n\t\t\t\tif (name === \"scope\") {\n\t\t\t\t\treturn _.serializeScopeCall(node.arguments);\n\t\t\t\t}\n\t\t\t\telse if (name in Mavo.Script.$fn) {\n\t\t\t\t\tparent[prop] = {\n\t\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\tobject: {type: \"Identifier\", name: \"$fn\"},\n\t\t\t\t\t\tproperty: root\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar nameSerialized = _.serialize(node.callee, node);\n\t\t\tvar argsSerialized = node.arguments.map(n => _.serialize(n, node));\n\t\t\treturn `${nameSerialized}(${argsSerialized.join(\", \")})`;\n\t\t},\n\t\t\"ConditionalExpression\": node => `${_.serialize(node.test, node)}? ${_.serialize(node.consequent, node)} : ${_.serialize(node.alternate, node)}`,\n\t\t\"MemberExpression\": (node, parent) => {\n\t\t\tlet n = node, pn, callee;\n\n\t\t\tdo {\n\t\t\t\tif (n.type === \"CallExpression\" && n.callee === pn) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpn = n;\n\t\t\t} while (n = n.parent);\n\n\t\t\tif (n) { // Use plain serialization for foo.bar.baz()\n\t\t\t\tvar property = node.computed? `[${_.serialize(node.property, node)}]` : `.${node.property.name}`;\n\t\t\t\treturn `${_.serialize(node.object, node)}${property}`;\n\t\t\t}\n\n\t\t\tn = node;\n\t\t\tlet properties = [], object, objectParent;\n\n\t\t\twhile (n.type === \"MemberExpression\") {\n\t\t\t\tlet serialized = n.computed? _.serialize(n.property, n) : `\"${n.property.name}\"`;\n\t\t\t\tproperties.push(serialized);\n\t\t\t\tobjectParent = n;\n\t\t\t\tobject = n = n.object;\n\t\t\t}\n\n\t\t\treturn `$fn.get(${_.serialize(object, objectParent)}, ${properties.reverse().join(\", \")})`;\n\t\t},\n\t\t\"ArrayExpression\": node => `[${node.elements.map(n => _.serialize(n, node)).join(\", \")}]`,\n\t\t\"Literal\": node => {\n\t\t\tlet quote = node.raw[0];\n\n\t\t\tif (quote === \"'\" || quote === '\"') {\n\t\t\t\tlet content = node.raw.slice(1, -1);\n\t\t\t\tcontent = content.replace(/\\r/g, \"\\\\r\").replace(/\\n/g, \"\\\\n\");\n\t\t\t\t// jsep does not properly escape quotes, see https://github.com/EricSmekens/jsep/issues/192\n\t\t\t\t// let regex = quote === '\"'? /(?<!\\\\)\"/g : /(?<!\\\\)'/g\n\t\t\t\tcontent = content.replaceAll(quote, \"\\\\\" + quote);\n\t\t\t\treturn quote + content + quote;\n\t\t\t}\n\n\t\t\treturn node.raw;\n\t\t},\n\t\t\"Identifier\": node => node.name,\n\t\t\"ThisExpression\": node => \"this\",\n\t\t\"Compound\": node => node.body.map(n => _.serialize(n, node)).join(\", \")\n\t},\n\n\t/**\n\t * These are run before the serializers and transform the expression to support MavoScript\n\t */\n\ttransformations: {\n\t\t\"BinaryExpression\": node => {\n\t\t\tlet name = _.getOperatorName(node.operator);\n\t\t\tlet def = _.operators[name];\n\n\t\t\t// Operator-specific transformations\n\t\t\tdef.transformation?.(node);\n\n\t\t\tvar nodeLeft = node;\n\t\t\tvar ret = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\targuments: [],\n\t\t\t\tcallee: {type: \"Identifier\", name}\n\t\t\t};\n\n\t\t\tif (def.comparison) {\n\t\t\t\t// Flatten comparison operator calls. If all comparison\n\t\t\t\t// operators are the same, flatten into one call (to maintain\n\t\t\t\t// simplicity of output):\n\t\t\t\t// 3 < 4 < 5 becomes lt(3, 4, 5).\n\t\t\t\t// Otherwise, assemble an argument list like so:\n\t\t\t\t// 3 < 4 = 5 becomes compare(3, \"lt\", 4, \"eq\", 5).\n\n\t\t\t\t// Create list of {comparison, operand} objects\n\t\t\t\tlet comparisonOperands = [];\n\t\t\t\tdo {\n\t\t\t\t\tlet operatorName = _.getOperatorName(nodeLeft.operator); // e.g. \"lt\"\n\t\t\t\t\tcomparisonOperands.unshift({\n\t\t\t\t\t\tcomparison: operatorName,\n\t\t\t\t\t\toperand: nodeLeft.right\n\t\t\t\t\t});\n\t\t\t\t\tnodeLeft = nodeLeft.left;\n\t\t\t\t} while (def.flatten !== false && _.isComparisonOperator(nodeLeft.operator));\n\n\t\t\t\t// Determine if all comparison operators are the same\n\t\t\t\tlet comparisonsHeterogeneous = false;\n\t\t\t\tfor (let i = 0; i < comparisonOperands.length - 1; i++) {\n\t\t\t\t\tif (comparisonOperands[i].comparison != comparisonOperands[i+1].comparison) {\n\t\t\t\t\t\tcomparisonsHeterogeneous = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Assemble final callee and argument list\n\t\t\t\tret.arguments.push(nodeLeft); // first operand\n\t\t\t\tif (comparisonsHeterogeneous) {\n\t\t\t\t\tret.callee.name = \"compare\";\n\t\t\t\t\tcomparisonOperands.forEach(co => {\n\t\t\t\t\t\tret.arguments.push({\n\t\t\t\t\t\t\ttype: \"Literal\",\n\t\t\t\t\t\t\tvalue: co.comparison,\n\t\t\t\t\t\t\traw: `\"${co.comparison}\"`,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tret.arguments.push(co.operand);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcomparisonOperands.forEach(co => {\n\t\t\t\t\t\tret.arguments.push(co.operand);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Flatten same operator calls\n\t\t\t\tdo {\n\t\t\t\t\tret.arguments.unshift(nodeLeft.right);\n\t\t\t\t\tnodeLeft = nodeLeft.left;\n\t\t\t\t} while (def.flatten !== false && nodeLeft.right && _.getOperatorName(nodeLeft.operator) === name);\n\n\t\t\t\tret.arguments.unshift(nodeLeft);\n\t\t\t}\n\n\t\t\t// Operator-specific transformations\n\t\t\tdef.postFlattenTransformation?.(ret);\n\n\t\t\treturn ret;\n\t\t},\n\t\t\"UnaryExpression\": node => {\n\t\t\tvar name = _.getOperatorName(node.operator, true);\n\n\t\t\tif (name) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"CallExpression\",\n\t\t\t\t\targuments: [node.argument],\n\t\t\t\t\tcallee: {type: \"Identifier\", name}\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\"CallExpression\": node => {\n\t\t\tif (node.callee.type == \"Identifier\") {\n\t\t\t\tif (node.callee.name == \"if\") {\n\t\t\t\t\tnode.callee.name = \"iff\";\n\n\t\t\t\t\t// Traverse data actions inside if() and rewrite them to their *if() counterpart\n\t\t\t\t\tvar condition = node.arguments[0];\n\n\t\t\t\t\tfor (let i=1; i<node.arguments.length; i++) {\n\t\t\t\t\t\tif (i == 2) {\n\t\t\t\t\t\t\t// Else, negate condition\n\t\t\t\t\t\t\tcondition = _.parse(\"not()\");\n\t\t\t\t\t\t\tcondition.arguments.push(node.arguments[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_.walk(node.arguments[i], n => {\n\t\t\t\t\t\t\tvar name = n.callee.name;\n\n\t\t\t\t\t\t\tif (Mavo.Actions.Functions.hasOwnProperty(name) // is a data action\n\t\t\t\t\t\t\t    && !/if$/.test(name) // and not already the *if() version of itself\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tn.callee.name += \"if\";\n\n\t\t\t\t\t\t\t\t// Add condition as first argument of *if() function\n\t\t\t\t\t\t\t\tn.arguments.unshift(condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, {type: \"CallExpression\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (node.callee.name == \"delete\") {\n\t\t\t\t\tnode.callee.name = \"clear\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar def = Mavo.Functions[node.callee.name];\n\n\t\t\t\t\tif (def && def.needsContext) {\n\t\t\t\t\t\t// Rewrite to funcName.call($this, ...args)\n\t\t\t\t\t\tnode.callee = {\n\t\t\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\tobject: node.callee,\n\t\t\t\t\t\t\tproperty: {type: \"Identifier\", name: \"call\"}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tnode.arguments.unshift({type: \"Identifier\", name: \"$this\"});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"ThisExpression\": node => {\n\t\t\treturn {type: \"Identifier\", name: \"$this\"};\n\t\t}\n\t},\n\n\tclosest (node, type) {\n\t\tlet n = node;\n\n\t\tdo {\n\t\t\tif (n.type === type) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} while (n = n.parent);\n\n\t\treturn null;\n\t},\n\n\tserialize: (node, parent) => {\n\t\tif (typeof node === \"string\") {\n\t\t\treturn node; // already serialized\n\t\t}\n\n\t\tif (parent) {\n\t\t\tnode.parent = parent;\n\t\t}\n\n\t\tvar ret = _.transformations[node.type]?.(node, parent);\n\n\t\tif (typeof ret == \"object\" && ret?.type) {\n\t\t\tnode = ret;\n\t\t}\n\t\telse if (ret !== undefined) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!node.type || !_.serializers[node.type]) {\n\t\t\tthrow new TypeError(\"Cannot understand this expression at all \");\n\t\t}\n\n\t\treturn _.serializers[node.type](node, parent);\n\t},\n\n\trewrite: function(code, o) {\n\t\tlet ast = _.parse(code);\n\n\t\tif (o) {\n\t\t\to.ast = ast;\n\t\t}\n\n\t\treturn _.serialize(ast);\n\t},\n\n\tcompile: function(code, o) {\n\t\tif (!/\\S/.test(code)) {\n\t\t\t// If code contains only whitespace, including in particular if\n\t\t\t// code is just the empty string, treat it as an expression that\n\t\t\t// evaluates to an empty string. This is consistent with\n\t\t\t// interpreting bare words as their corresponding strings.\n\t\t\treturn () => \"\";\n\t\t}\n\n\t\tcode = _.rewrite(code, o);\n\n\t\tcode = `with (Mavo.Data.stub)\n\twith (data || {}) {\n\t\tlet $fn = Mavo.Script.$fn;\n\t\treturn (${code});\n\t}`;\n\n\t\tif (o?.actions) {\n\t\t\t// Yes this is a horrible, horrible hack and Im truly ashamed.\n\t\t\t// If you understand the reasons and can think of a better way, be my guest!\n\t\t\tcode = `\nMavo.Actions._running = Mavo.Actions.running;\nMavo.Actions.running = true;\n${code}\nMavo.Actions.running = Mavo.Actions._running;`;\n\t\t}\n\n\t\treturn new Function(\"data\", code);\n\t},\n\n\tparse: self.jsep,\n\n\t// scope() rewriting\n\tserializeScopeCall: (args) => {\n\t\tvar withCode = `with (Mavo.Script.subScope(scope, $this) || {}) { return (${_.serialize(args[1])}); }`;\n\t\treturn `(function() {\n\tvar scope = ${_.serialize(args[0])};\n\tif (Array.isArray(scope)) {\n\t\treturn scope.map(function(scope) {\n\t\t\t${withCode}\n\t\t});\n\t}\n\n\t${withCode}\n})()`;\n\t},\n\n\t// This is used for scope() rewriting, to support $this passing through\n\tsubScope: (proxy, $this) => {\n\t\tvar unscopables = Object.keys($this).reduce((o, k) => {\n\t\t\to[k] = true;\n\t\t\treturn o;\n\t\t}, {$this: true});\n\n\t\tif (!proxy || typeof proxy !== \"object\") {\n\t\t\treturn proxy;\n\t\t}\n\n\t\treturn new Proxy(proxy, {\n\t\t\tget: (t, property, r) => {\n\t\t\t\tif (property === Symbol.unscopables) {\n\t\t\t\t\treturn unscopables;\n\t\t\t\t}\n\n\t\t\t\treturn Reflect.get(t, property, r);\n\t\t\t}\n\t\t});\n\t}\n};\n\n_.serializers.LogicalExpression = _.serializers.BinaryExpression;\n_.transformations.LogicalExpression = _.transformations.BinaryExpression;\n\nfor (let name in _.operators) {\n\tlet details = _.operators[name];\n\n\tif (details.scalar?.length < 2) {\n\t\tvar ret = _.addUnaryOperator(name, details);\n\t}\n\telse {\n\t\tvar ret = _.addBinaryOperator(name, details);\n\t}\n\n\tdetails.code = details.code || ret;\n\n\tif (ret && details.export !== false) {\n\t\tMavo.Functions[name] = ret;\n\t}\n}\n\n// Takes a list of arguments that consist of interleaved operands and strings\n// representing comparison operations, and returns the result of evaluating the\n// chained comparison.\n// e.g. compare(3, \"lt\", 4, \"lt\", 5) means 3 < 4 < 5, or (3 < 4) && (4 < 5)\nMavo.Functions.compare = function(...operands) {\n\tlet result = true;\n\n\tfor (let i = 2; i < operands.length; i += 2) {\n\t\tlet a = operands[i - 2];\n\t\tlet op = operands[i - 1];\n\t\tlet b = operands[i];\n\t\tlet term = _.binaryOperation(a, b, Mavo.Script.operators[op]);\n\t\tresult = _.binaryOperation(result, term, Mavo.Script.operators[\"and\"]);\n\t}\n\n\treturn result;\n};\n\n})(Bliss, Mavo.value, Mavo.Functions.util);\n","(function($, $$) {\n\nMavo.attributes.push(\"mv-action\");\n\nlet _ = Mavo.Actions = {\n\tlistener: evt => {\n\t\tlet tag = evt.type === \"submit\"? \"form\" : \":not(form)\";\n\t\tlet element = evt.target.closest(tag + \"[mv-action]\");\n\n\t\tif (!element) {\n\t\t\treturn; // Not an action\n\t\t}\n\n\t\tlet node = Mavo.Node.get(element);\n\n\t\tif (node && node.editing && node.modes !== \"edit\") {\n\t\t\t// If this is a node, and being edited (and supports other modes), we don't want to have the action interfering.\n\t\t\treturn;\n\t\t}\n\n\t\tif (evt.type === \"submit\") {\n\t\t\tevt.preventDefault();\n\t\t}\n\n\t\tif (element) {\n\t\t\t_.run(element.getAttribute(\"mv-action\"), element, evt);\n\t\t}\n\t},\n\n\trun: (code, element, evt) => {\n\t\tif (code) {\n\t\t\tlet node = Mavo.Node.getClosest(element);\n\n\t\t\tif (node) {\n\t\t\t\tlet expression = new Mavo.Expression(code, {actions: true});\n\n\t\t\t\tlet previousEvt = Mavo.Functions.$evt;\n\t\t\t\tMavo.Functions.$evt = evt;\n\n\t\t\t\tlet ret = expression.eval(node.getLiveData());\n\n\t\t\t\tMavo.Functions.$evt = previousEvt;\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetNodes: ref => {\n\t\tlet node = _.getNode(ref);\n\n\t\tif (node) {\n\t\t\treturn [node];\n\t\t}\n\n\t\treturn Mavo.toArray(ref).map(n => _.getNode(n)).filter(n => n !== undefined);\n\t},\n\n\tgetNode: node => {\n\t\tif (node instanceof Mavo.Node) {\n\t\t\treturn node;\n\t\t}\n\t\telse if (node?.[Mavo.toNode]) {\n\t\t\treturn node[Mavo.toNode];\n\t\t}\n\t},\n\n\tgetCollection: ref => {\n\t\tlet collection = _.getNode(ref);\n\n\t\tif (collection instanceof Mavo.Collection) {\n\t\t\treturn collection;\n\t\t}\n\n\t\t// ref is not a collection. Either it's an item or we don't have a collection\n\t\treturn collection?.collection ?? null;\n\t},\n\n\t// Function to run instead of actions if actions are called outside mv-action\n\tnope: () => {\n\t\tlet actions = Object.keys(_.Functions).map(name => `${name}()`);\n\t\tMavo.warn(`Mavo actions (${actions}) can only be used in the mv-action attribute.`);\n\t},\n\n\tFunctions: {\n\t\t/**\n\t\t * @param data (Optional) data of new item(s)\n\t\t * @param ref Collection to add to\n\t\t * @param index {Number} index of new item(s).\n\t\t * @returns Newly added item(s)\n\t\t */\n\t\tadd: Object.assign(function(data, ref, index) {\n\t\t\tlet args = [...arguments], collection;\n\n\t\t\tif (arguments.length < 3) {\n\t\t\t\tif (arguments.length <= 1) {\n\t\t\t\t\t// add(ref) signature used\n\t\t\t\t\t[data, ref] = [undefined, data];\n\t\t\t\t}\n\t\t\t\telse if (arguments.length === 2) {\n\t\t\t\t\t// Is it (data, ref) or (ref, index)?\n\t\t\t\t\t// ref might be a number, if collection of numbers!\n\t\t\t\t\tcollection = _.getCollection(ref);\n\n\t\t\t\t\tif (!collection) {\n\t\t\t\t\t\t// No collection from ref, must be (ref, index)\n\t\t\t\t\t\tcollection = _.getCollection(data);\n\n\t\t\t\t\t\tif (collection) {\n\t\t\t\t\t\t\t// Yup, it's (ref, index)\n\t\t\t\t\t\t\t[data, ref, index] = [undefined, data, ref];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ref) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcollection = collection || _.getCollection(ref);\n\n\t\t\tif (!collection) {\n\t\t\t\tcollection = _.getCollection(this);\n\n\t\t\t\tif (collection) {\n\t\t\t\t\t// The collection is the context, re-interpret arguments\n\t\t\t\t\t[data, index] = args;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!collection) {\n\t\t\t\tMavo.warn(\"No collection or collection item provided to add().\", {once: false});\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tif (index === undefined) {\n\t\t\t\t// If there is no index and item provided instead of collection,\n\t\t\t\t// get index from collection item\n\t\t\t\tlet node = _.getNode(ref);\n\n\t\t\t\tif (node && node.collection === collection) {\n\t\t\t\t\tindex = node.index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (Array.isArray(data)? data : [data]).map(datum => {\n\t\t\t\tlet item = collection.add(undefined, index);\n\n\t\t\t\tif (datum !== undefined) {\n\t\t\t\t\titem.render(datum);\n\t\t\t\t}\n\n\t\t\t\tif (collection.editing) {\n\t\t\t\t\tcollection.editItem(item);\n\t\t\t\t}\n\n\t\t\t\treturn item.getLiveData();\n\t\t\t});\n\t\t}, {needsContext: true}),\n\n\t\t/**\n\t\t * @param from {Mavo.Node|Array<Mavo.Node>} one or more items to move\n\t\t * @param to where to move to, item or collection. Optional\n\t\t * @param index {Number} index. Optional\n\t\t * @returns Moved item(s)\n\t\t */\n\t\tmove: (from, to, index) => {\n\t\t\tif (!from || to === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet toNode = _.getNode(to);\n\n\t\t\tif ($.type(to) == \"number\" && !(toNode?.collection)) {\n\t\t\t\t// If to is a number and not a collection item, it's an index\n\t\t\t\t[index, to] = [to];\n\t\t\t\ttoNode = undefined;\n\t\t\t}\n\n\t\t\tlet fromNodes = Mavo.toArray(from).map(_.getNode).filter(n => n?.closestCollection);\n\t\t\tlet collection = (toNode || fromNodes[0]).closestCollection;\n\n\t\t\tif (!fromNodes.length) {\n\t\t\t\tif (collection) {\n\t\t\t\t\tMavo.warn(\"First parameter of move() was not a collection or collection item, using add() instead.\", {once: false});\n\t\t\t\t\treturn _.Functions.add(from, collection, index);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMavo.warn(\"You need to provide at least one collection or collection item for move() to have something to do.\", {once: false});\n\t\t\t\t\treturn from;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet ret = _.Functions.add(from, collection, index);\n\t\t\tMavo.Collection.delete(fromNodes, {silent: true});\n\t\t\treturn ret;\n\t\t},\n\n\t\t/**\n\t\t * @param ref Items to delete\n\t\t */\n\t\tclear: (...ref) => {\n\t\t\tif (!ref.length || !ref[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet nodes = _.getNodes(ref.flat());\n\t\t\tlet itemsToDelete = [];\n\n\t\t\tnodes.forEach(node => {\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (node instanceof Mavo.Collection) {\n\t\t\t\t\t// Clear collection\n\t\t\t\t\titemsToDelete.push(...node.children);\n\t\t\t\t}\n\t\t\t\telse if (node.collection) {\n\t\t\t\t\t// Collection item, delete\n\t\t\t\t\titemsToDelete.push(node);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Ordinary node, just clear its data\n\t\t\t\t\tnode.walk(n => {\n\t\t\t\t\t\tif (n instanceof Mavo.Primitive) {\n\t\t\t\t\t\t\tn.value = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (n !== node) {\n\t\t\t\t\t\t\t_.Functions.clear(n);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tMavo.Collection.delete(itemsToDelete);\n\n\t\t\treturn nodes.map(n => n.getLiveData());\n\t\t},\n\n\t\tclearif: (condition, ...targets) => {\n\t\t\ttargets = targets.map(t => Mavo.Functions.iff(condition, t));\n\t\t\treturn _.Functions.clear(...targets);\n\t\t},\n\n\t\t/**\n\t\t * Set node(s) to value(s)\n\t\t * If ref is a single node or a collection, render values on it\n\t\t * If ref is multiple nodes, set it to corresponding value\n\t\t * If ref is multiple nodes and values is not an array, set all nodes to values\n\t\t */\n\t\tset: (ref, values) => {\n\t\t\tif (!ref) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet node = _.getNode(ref);\n\n\t\t\tif (node) {\n\t\t\t\t// Single node, render values on it\n\t\t\t\tnode.render(values);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet wasArray = Array.isArray(ref);\n\t\t\t\tlet nodes = _.getNodes(ref);\n\n\t\t\t\tif (!nodes.length) {\n\t\t\t\t\tMavo.warn(`The first parameter of set() needs to be one or more existing properties, ${Mavo.safeToJSON(ref)} is not.`);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMavo.Script.binaryOperation(wasArray? nodes : nodes[0], values, {\n\t\t\t\t\t\tscalar: (node, value) => {\n\t\t\t\t\t\t\treturn node ? node.render(value) : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\t}\n};\n\n// Create *if() versions of data actions\nfor (let name in _.Functions) {\n\tlet nameif = name + \"if\";\n\n\tif (!(nameif in _.Functions)) {\n\t\t_.Functions[nameif] = (condition, target, ...rest) => {\n\t\t\ttarget = Mavo.Functions.iff(condition, target);\n\t\t\treturn Mavo.value(condition)? _.Functions[name](target, ...rest) : null;\n\t\t};\n\t}\n}\n\n_.Functions.deleteif = _.Functions.clearif;\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nvar _ = Mavo.Data = $.Class(class Data {\n\tconstructor(node, data) {\n\t\tthis.node = node;\n\n\t\tif (data !== undefined) {\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\n\tget parent() {\n\t\tvar parent = this.node.parent;\n\t\treturn parent?.liveData ?? null;\n\t}\n\n\tget collection() {\n\t\treturn this.node.collection;\n\t}\n\n\tget key() {\n\t\treturn this._key = this.collection? this.node.index : this.node.property;\n\t}\n\n\tproxify() {\n\t\treturn _.proxify(this.data);\n\t}\n\n\tupdate() {\n\t\tif (this.node instanceof Mavo.Collection || this.node instanceof Mavo.ImplicitCollection) {\n\t\t\t// TODO eventually we should do more granular updates than this O(N) stuff\n\t\t\tthis.data.length = 0;\n\n\t\t\tfor (var i=0; i<this.node.children.length; i++) {\n\t\t\t\tthis.data[i] = this.node.children[i].liveData.data;\n\t\t\t}\n\n\t\t\tif (this.node instanceof Mavo.ImplicitCollection) {\n\t\t\t\t// Implicit collections drop nulls\n\t\t\t\t// Filter array in place to maintain references\n\t\t\t\tfor (var i=0; i<this.data.length; i++) {\n\t\t\t\t\tif (Mavo.value(this.data[i]) === null) {\n\t\t\t\t\t\tthis.data.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Implicit collections can alternate between arrays and singletons\n\t\t\t\t// depending on which items are null\n\t\t\t\tthis.updateParent();\n\t\t\t}\n\t\t}\n\t\telse if (this.node instanceof Mavo.Primitive) {\n\t\t\tvar value = this.node.value;\n\n\t\t\tif (this.node.isDataNull({live: true})) {\n\t\t\t\tvalue = null;\n\t\t\t}\n\n\t\t\tthis.data = Mavo.objectify(value);\n\n\t\t\tif (Mavo.isPlainObject(value) || Array.isArray(value)) {\n\t\t\t\t// Object rendered on a primitive, we should traverse it and store its properties\n\t\t\t\t// Why check prototype instead of just type == \"object\"? Because instances of ES6 classes also return \"object\"\n\t\t\t\t_.computeRoutes(this.data);\n\t\t\t}\n\n\t\t\tthis.updateParent();\n\t\t}\n\t}\n\n\tupdateParent() {\n\t\tif (!this.parent) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.node instanceof Mavo.ImplicitCollection) {\n\t\t\t// Is implicit collection\n\t\t\t// See https://github.com/LeaVerou/mavo/issues/50#issuecomment-266079652\n\t\t\tvar data = this.data.length === 1? this.data[0] : this.data;\n\t\t\tthis.parent.set(this.node.property, data, true);\n\t\t}\n\t\telse if (this.collection instanceof Mavo.ImplicitCollection) {\n\t\t\t// Is implicit collection *Item*\n\t\t\tthis.parent.update();\n\t\t}\n\t\telse {\n\t\t\tvar key = this.key, isDeleted = false;\n\n\t\t\tif (this.collection instanceof Mavo.Collection) {\n\t\t\t\t// Is collection item, check if deleted\n\t\t\t\tisDeleted = this.collection.children[this.node.index] !== this.node;\n\t\t\t}\n\n\t\t\tif (key !== undefined && !isDeleted) {\n\t\t\t\tthis.parent.set(key, this.data, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tset(property, value, shallow) {\n\t\tthis.data[property] = value;\n\t\t_[\"computeRoute\" + (shallow? \"\" : \"s\")](value, property, this.data);\n\t}\n\n\tupdateKey() {\n\t\tvar oldKey = this._key;\n\n\t\tif (this.parent[oldKey] === this.data) {\n\t\t\tdelete this.parent[oldKey];\n\t\t}\n\n\t\tthis.updateParent();\n\t}\n\n\tresolve(property) {\n\t\treturn _.resolve(property, this.data);\n\t}\n}, {\n\tlive: {\n\t\tdata: function(data) {\n\t\t\tif (data !== this._data) {\n\t\t\t\tthis.isArray = Array.isArray(data);\n\n\t\t\t\tthis._data = data;\n\n\t\t\t\tdata[Mavo.toNode] = this.node;\n\t\t\t\tdata[Mavo.parent] = this.parent?.data;\n\t\t\t\tdata[Mavo.mavo] = this.node.mavo;\n\n\t\t\t\tthis.proxy = this.proxify();\n\n\t\t\t\tthis.updateParent();\n\n\t\t\t\treturn this._data;\n\t\t\t}\n\t\t}\n\t},\n\n\tstatic: {\n\t\t// The context for expression evaluation\n\t\tstub: self.Proxy? new Proxy({[Symbol.unscopables]: {data: true, undefined: true}}, {\n\t\t\tget: (data, property) => {\n\t\t\t\tvar ret = Reflect.get(data, property);\n\n\t\t\t\tif (ret !== undefined || typeof property !== \"string\") {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tvar propertyL = property.toLowerCase();\n\n\t\t\t\tif (propertyL[0] === \"$\" && propertyL in Mavo.Functions) {\n\t\t\t\t\t// Non-data $specialProperty\n\t\t\t\t\treturn Mavo.Functions[propertyL];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar propertyU = property.toUpperCase();\n\t\t\t\t\tif (propertyU in Math) {\n\t\t\t\t\t\t// Math constants\n\t\t\t\t\t\treturn Math[propertyU];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Still not found? Maybe it's a global\n\t\t\t\tif (typeof window !== \"undefined\" && window.hasOwnProperty(property)) {\n\t\t\t\t\t// hasOwnProperty to avoid elements with ids clobbering globals\n\t\t\t\t\treturn window[property];\n\t\t\t\t}\n\n\t\t\t\t// Still not found? Maybe it's a special property used without a $ (see #343)\n\t\t\t\tif (property[0] !== \"$\") {\n\t\t\t\t\tvar $property = \"$\" + property.toLowerCase();\n\n\t\t\t\t\tif ($property in Mavo.Functions) {\n\t\t\t\t\t\treturn Mavo.Functions[$property];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Prevent undefined at all costs\n\t\t\t\treturn property;\n\t\t\t},\n\t\t\thas: (data, property) => {\n\t\t\t\treturn Reflect.has(data, property) || typeof property === \"string\";\n\t\t\t}\n\t\t}) : Mavo.Functions,\n\n\t\tisItem (data) {\n\t\t\treturn Array.isArray(data?.[Mavo.parent]);\n\t\t},\n\n\t\tisCollection (data) {\n\t\t\treturn Array.isArray(data) && data?.[Mavo.toNode] instanceof Mavo.Collection;\n\t\t},\n\n\t\tclosest (obj, test) {\n\t\t\tvar path = [];\n\t\t\tdo {\n\t\t\t\tif (test(obj)) {\n\t\t\t\t\treturn {value: obj, path};\n\t\t\t\t}\n\n\t\t\t\tpath.push(obj[Mavo.property]);\n\t\t\t} while (obj = obj[Mavo.parent]);\n\n\t\t\treturn {value: null, path};\n\t\t},\n\n\t\troot (obj) {\n\t\t\treturn _.closest(obj, o => !o[Mavo.parent]);\n\t\t},\n\n\t\tclosestItem (obj) {\n\t\t\treturn _.closest(obj, _.isItem);\n\t\t},\n\n\t\tclosestArray(obj) {\n\t\t\treturn _.closest(obj, Array.isArray);\n\t\t},\n\n\t\tgetProperty (data) {\n\t\t\tvar ret = _.isItem(data)? data[Mavo.parent] : data;\n\n\t\t\treturn ret[Mavo.property];\n\t\t},\n\n\t\tfind (property, data, o = {}) {\n\t\t\tif (!data || o.exclude === data) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Mavo.in(property, data) && o.exclude !== data[property]) {\n\t\t\t\treturn data[property];\n\t\t\t}\n\n\t\t\tif (!data[Mavo.route] || !Mavo.in(property, data[Mavo.route])) {\n\t\t\t\tif (data[Mavo.property] === property) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\tif (_.isItem(data) && _.getProperty(data) === property) {\n\t\t\t\t\t// Inside collection items we want their property name\n\t\t\t\t\t// to return the current item, not the entire collection\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(data)) {\n\t\t\t\t\t// Perhaps it's an array of nodes, such as the one created with deep references?\n\t\t\t\t\tvar ret = data.map(a => _.find(property, a))\n\t\t\t\t\t              .filter(x => x !== undefined);\n\n\t\t\t\t\tif (ret.length) {\n\t\t\t\t\t\treturn ret.flat();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar results = [], returnArray = Array.isArray(data), ret;\n\n\t\t\tresults[Mavo.route] = {};\n\t\t\tresults[Mavo.mavo] = data[Mavo.mavo];\n\n\t\t\tvar findDown = prop => {\n\t\t\t\tvar ret = _.find(property, data[prop], o);\n\n\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t// FIXME How do we set a sensible Mavo.route when the returned array is empty?\n\t\t\t\t\t// E.g. because we were pointing to inner elements of a collection that currently has no items.\n\t\t\t\t\tif (Mavo.in(Mavo.route, ret)) {\n\t\t\t\t\t\tfor (var p in ret[Mavo.route]) {\n\t\t\t\t\t\t\tresults[Mavo.route][p] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Array.isArray(ret)) {\n\t\t\t\t\t\tresults.push(...ret);\n\t\t\t\t\t\treturnArray = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults.push(ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (Array.isArray(data) || data[Mavo.route][property] === true) {\n\t\t\t\tfor (var prop in data) {\n\t\t\t\t\tfindDown(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata[Mavo.route][property].forEach(findDown);\n\t\t\t}\n\n\t\t\treturn returnArray || results.length > 1? results : results[0];\n\t\t},\n\n\t\t// First look in descendants, then ancestors and their descendants\n\t\t// one level up at a time (excluding the subtree we've already explored and any siblings)\n\t\tfindUp (property, data) {\n\t\t\tlet parent = data;\n\t\t\tlet child;\n\t\t\tlet isDataArray = _.isCollection(data);\n\n\t\t\tdo {\n\t\t\t\t// console.log(parent, child);\n\t\t\t\tif (!_.isCollection(parent) || isDataArray) {\n\t\t\t\t\t// Skip arrays, we don't want to get siblings if we've written off the item\n\t\t\t\t\t// unless we're resolving against an array in the first place\n\t\t\t\t\t// so that things like collection.nestedProperty will still work\n\t\t\t\t\tlet ret = _.find(property, parent, {exclude: child});\n\n\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_.getProperty(parent) === property) {\n\t\t\t\t\t\treturn parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tchild = parent;\n\t\t\t\tparent = parent[Mavo.parent];\n\n\t\t\t} while (parent);\n\t\t},\n\n\t\tresolve (property, data) {\n\t\t\tif (property === Mavo.isProxy) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (typeof property === \"symbol\") {\n\t\t\t\t// We can't do much for symbols\n\t\t\t\treturn data[property];\n\t\t\t}\n\n\t\t\tvar ret;\n\t\t\tvar propertyIsNumeric = !isNaN(property);\n\n\t\t\tif (property in data) {\n\t\t\t\tret = data[property];\n\t\t\t}\n\t\t\telse if (_.isCollection(data) && data[Mavo.property] === property) {\n\t\t\t\t// On collections we want their property name to return the entire collection\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\telse if (!propertyIsNumeric) {\n\t\t\t\t// Property does not exist on data, if non-numeric, look for it elsewhere\n\t\t\t\tif (property in _.special) { // $special properties\n\t\t\t\t\tret = _.special[property](data);\n\t\t\t\t}\n\t\t\t\telse if (data[Mavo.mavo]) {\n\t\t\t\t\tvar all = data[Mavo.mavo].root.liveData.data[Mavo.route];\n\n\t\t\t\t\tif (Mavo.in(property, all)) {\n\t\t\t\t\t\tret = _.findUp(property, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Mavo.in(Mavo.route, data) && Mavo.in(property, data[Mavo.route])) {\n\t\t\t\t\tret = _.find(property, data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!propertyIsNumeric) {\n\t\t\t\tvar propertyL = property.toLowerCase();\n\t\t\t}\n\n\t\t\tif (ret !== undefined) {\n\t\t\t\t// Should we proxify value before returning it? Is it data?\n\t\t\t\tvar proxify = ret !== null && typeof ret === \"object\" // Can be a proxy\n\t\t\t\t              && (Mavo.route in ret || Mavo.toNode in ret); // Either has a route or comes from a node\n\n\t\t\t\treturn !proxify? ret : _.proxify(ret);\n\t\t\t}\n\n\t\t\tif (!propertyIsNumeric) {\n\t\t\t\t// Does it reference another Mavo?\n\t\t\t\tif (isNaN(property) && Mavo.all?.[property]?.root) {\n\t\t\t\t\treturn Mavo.all[property].root.getLiveData();\n\t\t\t\t}\n\n\t\t\t\t// Still not found? Maybe it's a special property used without a $ (see #343)\n\t\t\t\tif (property[0] !== \"$\") {\n\t\t\t\t\tvar $property = \"$\" + propertyL;\n\n\t\t\t\t\tif ($property in _.special) {\n\t\t\t\t\t\treturn _.resolve($property, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\thas (property, data) {\n\t\t\t// We don't care about priority here, just whether they exist\n\t\t\t// so we'll make the fastest searches first.\n\t\t\tif (property === Mavo.isProxy) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (typeof property !== \"string\") {\n\t\t\t\treturn Reflect.has(data, property);\n\t\t\t}\n\n\t\t\tif (_.getProperty(data) === property) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar objects = [data, Mavo.all, _.special];\n\n\t\t\tif (objects.some(obj => property in obj)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (typeof property === \"string\") {\n\t\t\t\tvar propertyL = property.toLowerCase();\n\n\t\t\t\tif (propertyL !== property && objects.some(obj => propertyL in obj)) {\n\t\t\t\t\treturn true;\n\t\t\t\t};\n\n\t\t\t\tif (propertyL[0] !== \"$\" && \"$\" + propertyL in _.special) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Slowest search last: Is the property present anywhere in the data?\n\t\t\tif (data[Mavo.mavo]) {\n\t\t\t\treturn Mavo.in(property, data[Mavo.mavo].root.liveData.data[Mavo.route]);\n\t\t\t}\n\t\t},\n\n\t\tproxify (data) {\n\t\t\tif (!data || typeof data !== \"object\" || !self.Proxy || data[Mavo.isProxy]) {\n\t\t\t\t// Data is a primitive, proxies are not supported, or is already a proxy\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\treturn new Proxy(data, {\n\t\t\t\tget: (data, property, proxy) => {\n\t\t\t\t\treturn _.resolve(property, data);\n\t\t\t\t},\n\n\t\t\t\thas: (data, property) => {\n\t\t\t\t\treturn _.has(property, data);\n\t\t\t\t},\n\n\t\t\t\tset: function(data, property = \"\", value) {\n\t\t\t\t\tif (typeof property !== \"symbol\") {\n\t\t\t\t\t\tMavo.warn(`You cannot set data via expressions. Attempt to set ${property.toString()} to ${value} ignored.`);\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.set(data, property, value);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tcomputeMetadata (object, property, parent) {\n\t\t\tif (object && typeof object === \"object\") { // not primitive\n\t\t\t\tif (property !== undefined) {\n\t\t\t\t\tobject[Mavo.property] = property;\n\t\t\t\t}\n\n\t\t\t\tif (parent && !object[Mavo.parent]) {\n\t\t\t\t\tobject[Mavo.parent] = parent;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tcomputeRoute (object, property, parent) {\n\t\t\tif (typeof object === \"function\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.computeMetadata(object, property, parent);\n\n\t\t\tif (Mavo.isPlainObject(object) || Array.isArray(object)) {\n\t\t\t\tif (!object[Mavo.route]) {\n\t\t\t\t\tobject[Mavo.route] = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($.type(property) !== \"number\") {\n\t\t\t\tvar child = object;\n\n\t\t\t\twhile (parent) {\n\t\t\t\t\tif (!parent[Mavo.route]) {\n\t\t\t\t\t\tparent[Mavo.route] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// parent[up] = child\n\t\t\t\t\tvar up = child?.[Mavo.property];\n\n\t\t\t\t\tif (up && parent[Mavo.route][property] !== true) {\n\t\t\t\t\t\tif (!parent[Mavo.route][property]) {\n\t\t\t\t\t\t\tparent[Mavo.route][property] = new Set();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parent[Mavo.route][property].has(up)) {\n\t\t\t\t\t\t\t// We've already computed routes on this subtree\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent[Mavo.route][property].add(up);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tparent[Mavo.route][property] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tchild = parent;\n\t\t\t\t\tparent = parent[Mavo.parent];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tcomputeRoutes (object, property, parent) {\n\t\t\t_.traverse(_.computeRoute, object, property, parent);\n\t\t},\n\n\t\t// Recursively traverse a JSON structure\n\t\t// Warning: No cycle detection. Will loop infinitely if there are cycles\n\t\ttraverseDown (callback, object, property, parent) {\n\t\t\tif (Array.isArray(object)) {\n\t\t\t\tobject.forEach((item, i) => _.traverse(callback, item, i, object));\n\t\t\t}\n\t\t\telse if (Mavo.isPlainObject(object)) {\n\t\t\t\tfor (var prop in object) {\n\t\t\t\t\t_.traverse(callback, object[prop], prop, object);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\ttraverse (callback, object, property, parent) {\n\t\t\tcallback(object, property, parent);\n\t\t\t_.traverseDown(callback, object, property, parent);\n\t\t},\n\n\t\tspecial: {\n\t\t\t$index: function(obj) {\n\t\t\t\tvar closestItem = _.closestItem(obj).value;\n\n\t\t\t\tif (!closestItem) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tvar property = closestItem[Mavo.property];\n\n\t\t\t\tif (isNaN(property)) {\n\t\t\t\t\t// Is an array item but its property is not a number! Search the array.\n\t\t\t\t\t// This happens with Implicit Collections of only 1 item.\n\t\t\t\t\treturn closestItem[Mavo.parent].indexOf(closestItem);\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\t\t\t},\n\n\t\t\t$item: function(obj) {\n\t\t\t\treturn _.closestItem(obj).value;\n\t\t\t},\n\n\t\t\t$all: function(obj) {\n\t\t\t\tvar arr = _.closestArray(obj);\n\t\t\t\tlet path = arr.path.reverse(), index;\n\t\t\t\t[index, ...path] = path;\n\t\t\t\tvar ret = arr.value.map(a => $.value(a, ...path));\n\n\t\t\t\tif (ret.length > 0 && ret?.[0]?.[Mavo.route]) {\n\t\t\t\t\tret[Mavo.route] = $.each(ret[0][Mavo.route], (p, v) => true);\n\t\t\t\t\tret[Mavo.mavo] = ret[0][Mavo.mavo];\n\t\t\t\t}\n\n\t\t\t\t$.lazy(ret, {\n\t\t\t\t\t$previous: function() {\n\t\t\t\t\t\treturn ret.slice(0, index);\n\t\t\t\t\t},\n\t\t\t\t\t$next: function() {\n\t\t\t\t\t\treturn ret.slice(index);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t$next: function(obj) {\n\t\t\t\tvar arr = _.closestArray(obj);\n\t\t\t\tvar path = arr.path.reverse();\n\t\t\t\tvar index = arr.path[0];\n\t\t\t\tpath = path.slice(1);\n\t\t\t\tvar nextClosestItem = arr.value?.[index + 1];\n\n\t\t\t\treturn nextClosestItem? $.value(nextClosestItem, ...path) : null;\n\t\t\t},\n\n\t\t\t$previous: function(obj) {\n\t\t\t\tvar arr = _.closestArray(obj);\n\t\t\t\tvar path = arr.path.reverse();\n\t\t\t\tvar index = arr.path[0];\n\t\t\t\tpath = path.slice(1);\n\t\t\t\tvar prevClosestItem = arr.value?.[index - 1];\n\n\t\t\t\treturn prevClosestItem? $.value(prevClosestItem, ...path) : null;\n\t\t\t},\n\n\t\t\t$this: function(obj) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\t}\n});\n\n})(Bliss, Bliss.$);\n","(function($, $$) {\n\nfunction delay(ms) {\n\treturn new Promise(r => setTimeout(r, ms));\n}\n\nlet _ = Mavo.Backend.register(class Github extends Mavo.Backend {\n\tid = \"Github\"\n\n\tconstructor (url, o) {\n\t\tsuper(url, o);\n\n\t\tthis.permissions.on([\"login\", \"read\"]);\n\n\t\tthis.login(true);\n\t}\n\n\tupdate (url, o) {\n\t\tsuper.update(url, o);\n\n\t\t// Extract info for username, repo, branch, filepath from URL\n\t\tlet extension = this.format.constructor.extensions[0] || \".json\";\n\n\t\tthis.defaults = {\n\t\t\trepo: \"mv-data\",\n\t\t\tfilename: `${this.mavo.id}${extension}`\n\t\t};\n\n\t\tthis.info = _.parseURL(this.source, this.defaults);\n\n\t\t// If an author provided backend metadata, use them\n\t\t// since they have higher priority\n\t\tfor (const prop in o) {\n\t\t\t// Skip the format and mavo properties\n\t\t\t// since they are already updated in the parent's update method\n\t\t\tif ([\"format\", \"mavo\"].includes(prop)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (this.info.apiCall === \"graphql\" && prop === \"query\") {\n\t\t\t\t// It makes sense to set/update the apiData property only for calls with GraphQL.\n\t\t\t\t// Otherwise, it will break the Github#get method.\n\t\t\t\tthis.info.apiData = { query: o.query };\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.info[prop] = o[prop];\n\t\t}\n\n\t\t$.extend(this, this.info);\n\t}\n\n\tasync get (url) {\n\t\tif (this.isAuthenticated() || !this.path || url) {\n\t\t\t// Authenticated or raw API call\n\t\t\tlet info = url? _.parseURL(url) : this.info;\n\n\t\t\tif (info.apiData) {\n\t\t\t\t// GraphQL\n\t\t\t\treturn this.request(info.apiCall, info.apiData, \"POST\")\n\t\t\t\t\t.then(response => {\n\t\t\t\t\t\tif (response.errors?.length) {\n\t\t\t\t\t\t\treturn Promise.reject(response.errors.map(x => x.message).join(\"\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn response.data;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet isRawAPICall = info.apiParams !== undefined;\n\t\t\tlet responseType = isRawAPICall ? \"response\" : \"json\";\n\t\t\tlet req = {\n\t\t\t\tresponseType,\n\t\t\t\theaders: {\n\t\t\t\t\t\"Accept\": \"application/vnd.github.squirrel-girl-preview\"\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet response = await this.request(info.apiCall, {ref:this.branch}, \"GET\", req);\n\n\t\t\tif (isRawAPICall) {\n\t\t\t\t// Raw API call\n\t\t\t\tlet json = await response.json();\n\n\t\t\t\tlet params = new URL(info.apiCall, this.constructor.apiDomain).searchParams;\n\t\t\t\tlet maxPages = params.get(\"max_pages\") - 1; /* subtract 1 because we already fetched a page */\n\n\t\t\t\tif (maxPages > 0 && params.get(\"page\") === null && Array.isArray(json)) {\n\t\t\t\t\t// Fetch more pages\n\t\t\t\t\tlet next;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnext = response.headers.get(\"Link\")?.match(/<(.+?)>; rel=\"next\"/)?.[1];\n\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\tresponse = await this.request(next, {ref:this.branch}, \"GET\", req);\n\n\t\t\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\t\t\tlet pageJSON = await response.json();\n\n\t\t\t\t\t\t\t\tif (Array.isArray(pageJSON)) {\n\t\t\t\t\t\t\t\t\tjson.push(...pageJSON);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} while (--maxPages > 0);\n\n\t\t\t\t}\n\n\t\t\t\treturn json;\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (info.repo && response.content) {\n\t\t\t\t\t// Fetching file contents\n\t\t\t\t\treturn _.atob(response.content);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Unauthenticated, use simple GET request to avoid rate limit\n\t\t\turl = new URL(`https://raw.githubusercontent.com/${this.username}/${this.repo}/${this.branch || \"main\"}/${this.path}`);\n\t\t\turl.searchParams.set(\"timestamp\", Date.now()); // ensure fresh copy\n\n\t\t\tlet response = await fetch(url.href);\n\n\t\t\tif (response.ok) {\n\t\t\t\tthis.branch = this.branch || \"main\";\n\t\t\t\treturn response.text();\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\tif (response.status === 404 && !this.branch) {\n\t\t\t\t\t// Possibly using older default branch \"master\", try again and store branch name\n\t\t\t\t\turl.pathname = `/${this.username}/${this.repo}/master/${this.path}`;\n\t\t\t\t\tresponse = await fetch(url.href);\n\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tthis.branch = \"master\";\n\t\t\t\t\t\treturn response.text();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tupload (file, path = this.path) {\n\t\treturn Mavo.readFile(file).then(dataURL => {\n\t\t\t\tlet base64 = dataURL.slice(5); // remove data:\n\t\t\t\tlet media = base64.match(/^\\w+\\/[\\w+]+/)[0];\n\t\t\t\tmedia = media.replace(\"+\", \"\\\\+\"); // Fix for #608\n\t\t\t\tbase64 = base64.replace(RegExp(`^${media}(;base64)?,`), \"\");\n\t\t\t\tpath = this.path.replace(/[^/]+$/, \"\") + path; // make upload path relative to existing path\n\n\t\t\t\treturn this.put(base64, path, {isEncoded: true});\n\t\t\t})\n\t\t\t.then(fileInfo => this.getURL(path, fileInfo.commit.sha));\n\t}\n\n\t/**\n\t * Saves a file to the backend.\n\t * @param {String} serialized - Serialized data\n\t * @param {String} path - Optional file path\n\t * @return {Promise} A promise that resolves when the file is saved.\n\t */\n\tasync put (serialized, path = this.path, o = {}) {\n\t\tif (!path) {\n\t\t\t// Raw API calls are read-only for now\n\t\t\treturn;\n\t\t}\n\n\t\tlet repoCall = `repos/${this.username}/${this.repo}`;\n\t\tlet fileCall = `${repoCall}/contents/${path}`;\n\t\tlet commitPrefix = this.mavo.element.getAttribute(\"mv-github-commit-prefix\") || \"\";\n\n\t\tserialized = o.isEncoded? serialized : _.btoa(serialized);\n\n\t\tlet repoInfo = await this.repoInfo;\n\n\t\tif (!repoInfo || repoInfo.owner.login !== this.username || repoInfo.name !== this.repo) {\n\t\t\t// No repo info available, or out of date, fetch it\n\t\t\ttry {\n\t\t\t\trepoInfo = await this.request(repoCall)\n\t\t\t\tthis.branch ??= repoInfo.default_branch;\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tif (e.status === 404) {\n\t\t\t\t\t// Create repo if it doesnt exist\n\t\t\t\t\trepoInfo = this.repoInfo = await this.request(\"user/repos\", {name: this.repo, private: !!(this.options.private ?? o.private)}, \"POST\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.canPush()) {\n\t\t\t// Does not have permission to commit, create a fork\n\t\t\tlet forkInfo = await this.request(`${repoCall}/forks`, {name: this.repo}, \"POST\");\n\t\t\tfileCall = `repos/${forkInfo.full_name}/contents/${path}`;\n\t\t\tthis.forkInfo = forkInfo;\n\n\t\t\t// Ensure that fork is created (they take a while)\n\t\t\tlet fetchedForkInfo;\n\n\t\t\tdo {\n\t\t\t\tawait delay(1000);\n\t\t\t\t// If we can get a list of commits, the fork is created\n\t\t\t\tfetchedForkInfo = await this.request(`repos/${forkInfo.full_name}/commits`, {until: \"1970-01-01T00:00:00Z\"}, \"HEAD\");\n\t\t\t} while (!fetchedForkInfo);\n\n\t\t\trepoInfo = forkInfo = fetchedForkInfo;\n\t\t}\n\n\t\tlet fileInfo;\n\t\ttry {\n\t\t\t// Get SHA\n\t\t\tfileInfo = await this.request(fileCall, { ref: this.branch});\n\n\t\t\t// If we're here, file exists\n\t\t\tfileInfo = await this.request(fileCall, {\n\t\t\t\tmessage: commitPrefix + this.mavo._(\"gh-updated-file\", {name: fileInfo.name || \"file\"}),\n\t\t\t\tcontent: serialized,\n\t\t\t\tbranch: this.branch,\n\t\t\t\tsha: fileInfo.sha\n\t\t\t}, \"PUT\");\n\t\t}\n\t\tcatch (xhr) {\n\t\t\tif (xhr.status == 404) {\n\t\t\t\t// File does not exist, create it\n\t\t\t\tfileInfo = await this.request(fileCall, {\n\t\t\t\t\tmessage: commitPrefix + \"Created file\",\n\t\t\t\t\tcontent: serialized,\n\t\t\t\t\tbranch: this.branch\n\t\t\t\t}, \"PUT\");\n\t\t\t}\n\t\t}\n\n\t\tconst env = {context: this, fileInfo};\n\n\t\tMavo.hooks.run(\"gh-after-commit\", env);\n\n\t\treturn env.fileInfo;\n\t}\n\n\tlogin (passive) {\n\t\treturn this.oAuthenticate(passive)\n\t\t\t.then(() => this.getUser())\n\t\t\t.catch(xhr => {\n\t\t\t\tif (xhr.status == 401) {\n\t\t\t\t\t// Unauthorized. Access token we have is invalid, discard it\n\t\t\t\t\tthis.logout();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(u => {\n\t\t\t\tif (this.user) {\n\n\t\t\t\t\tthis.permissions.on(\"logout\");\n\n\t\t\t\t\tif (this.info.path) {\n\t\t\t\t\t\tthis.permissions.on([\"edit\", \"save\"]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.repo) {\n\t\t\t\t\t\treturn this.request(`repos/${this.username}/${this.repo}`)\n\t\t\t\t\t\t.then(repoInfo => {\n\t\t\t\t\t\t\tthis.branch ??= repoInfo.default_branch;\n\n\t\t\t\t\t\t\tthis.repoInfo = repoInfo;\n\n\t\t\t\t\t\t\tif (!this.mavo.source) { // if url doesn't have source, check for forks\n\t\t\t\t\t\t\t\tif (!this.canPush()) { // Check if current user has a fork of this repo, and display dialog to switch\n\t\t\t\t\t\t\t\t\tif (this.user.info.public_repos < repoInfo.forks) { // graphql search of current user's forks\n\t\t\t\t\t\t\t\t\t\tlet query = `query {\n\t\t\t\t\t\t\t\t\t\t\t\t\t  viewer {\n\t\t\t\t\t\t\t\t\t\t\t\t\t    name\n\t\t\t\t\t\t\t\t\t\t\t\t\t      repositories(last: 100, isFork: true) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t      nodes {\n\t\t\t\t\t\t\t\t\t\t\t\t\t        url\n\t\t\t\t\t\t\t\t\t\t\t\t\t        parent {\n\t\t\t\t\t\t\t\t\t\t\t\t\t          nameWithOwner\n\t\t\t\t\t\t\t\t\t\t\t\t\t        }\n\t\t\t\t\t\t\t\t\t\t\t\t\t      }\n\t\t\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\t\t\t\treturn this.request(\"https://api.github.com/graphql\", {query: query}, \"POST\")\n\t\t\t\t\t\t\t\t\t\t.then(data => {\n\t\t\t\t\t\t\t\t\t\t\tlet repos = data.data.viewer.repositories.nodes;\n\n\t\t\t\t\t\t\t\t\t\t\tfor (let i in repos) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (repos[i].parent.nameWithOwner === repoInfo.full_name) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.switchToMyForkDialog(repos[i].url);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn repoInfo;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\treturn repoInfo;\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse { // search forks of this repo\n\t\t\t\t\t\t\t\t\t\treturn this.request(repoInfo.forks_url)\n\t\t\t\t\t\t\t\t\t\t.then(forks => {\n\t\t\t\t\t\t\t\t\t\t\tfor (let i in forks) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (forks[i].owner.login === this.user.username) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.switchToMyForkDialog(forks[i].html_url);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn repoInfo;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn repoInfo;\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn repoInfo;\n\t\t\t\t\t\t}).then(repoInfo => {\n\t\t\t\t\t\t\tconst env = { context: this, repoInfo };\n\n\t\t\t\t\t\t\tMavo.hooks.run(\"gh-after-login\", env);\n\n\t\t\t\t\t\t\treturn env.repoInfo;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tcanPush () {\n\t\tif (this.repoInfo) {\n\t\t\treturn this.repoInfo.permissions.push;\n\t\t}\n\n\t\t// Repo does not exist so we can't check permissions\n\t\t// Just check if authenticated user is the same as our URL username\n\t\treturn this.user?.username?.toLowerCase() == this.username.toLowerCase();\n\t}\n\n\toAuthParams = () => \"&scope=repo\"\n\n\tlogout () {\n\t\treturn this.oAuthLogout().then(() => {\n\t\t\tthis.user = null;\n\t\t});\n\t}\n\n\tgetUser () {\n\t\tif (this.user) {\n\t\t\treturn Promise.resolve(this.user);\n\t\t}\n\n\t\treturn this.request(\"user\").then(info => {\n\t\t\tthis.user = {\n\t\t\t\tusername: info.login,\n\t\t\t\tname: info.name || info.login,\n\t\t\t\tavatar: info.avatar_url,\n\t\t\t\turl: \"https://github.com/\" + info.login,\n\t\t\t\tinfo\n\t\t\t};\n\n\t\t\t$.fire(this, \"mv-login\");\n\t\t});\n\t}\n\n\tgetURL (path = this.path, sha) {\n\t\tlet repoInfo = this.forkInfo || this.repoInfo;\n\t\tlet repo = repoInfo.full_name;\n\t\tpath = path.replace(/ /g, \"%20\");\n\n\t\trepoInfo.pagesInfo = repoInfo.pagesInfo || this.request(`repos/${repo}/pages`, {}, \"GET\", {\n\t\t\theaders: {\n\t\t\t\t\"Accept\": \"application/vnd.github.mister-fantastic-preview+json\"\n\t\t\t}\n\t\t});\n\n\t\treturn repoInfo.pagesInfo.then(pagesInfo => pagesInfo.html_url + path)\n\t\t\t.catch(xhr => {\n\t\t\t\t// No Github Pages, return jsdelivr URLs\n\t\t\t\treturn `https://cdn.jsdelivr.net/gh/${repo}@${sha || this.branch || \"latest\"}/${path}`;\n\t\t\t});\n\t}\n\n\tswitchToMyForkDialog (forkURL) {\n\t\t\tlet params = (new URL(location)).searchParams;\n\t\t\tparams.append(`${this.mavo.id}-storage`, forkURL + \"/\" + this.path);\n\n\t\t\tthis.notice = this.mavo.message(`\n\t\t\t${this.mavo._(\"gh-login-fork-options\")}\n\t\t\t<form onsubmit=\"return false\">\n\t\t\t\t<a href=\"${location.pathname}?${params}\"><button>${this.mavo._(\"gh-use-my-fork\")}</button></a>\n\t\t\t</form>`, {\n\t\t\t\tclasses: \"mv-inline\",\n\t\t\t\tdismiss: [\"button\", \"submit\"]\n\t\t\t});\n\n\t\t\tthis.notice.closed.then(form => {\n\t\t\t\tif (!form) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\thistory.pushState({}, \"\", `${location.pathname}?${params}`);\n\t\t\t\tlocation.replace(`${location.pathname}?${params}`);\n\n\t\t\t});\n\t\t\treturn;\n\t}\n\n\tstatic apiDomain = \"https://api.github.com/\"\n\tstatic oAuth = \"https://github.com/login/oauth/authorize\"\n\tstatic key = \"7e08e016048000bc594e\"\n\n\tstatic test (url) {\n\t\turl = new URL(url, Mavo.base);\n\t\treturn /^((api\\.)?github\\.com|raw\\.githubusercontent\\.com)/.test(url.host);\n\t}\n\n\t/**\n\t * Parse Github URLs, return username, repo, branch, path\n\t */\n\tstatic parseURL (source, defaults = {}) {\n\t\tconst ret = {};\n\n\t\t// Define computed properties as writable accessors\n\t\tObject.defineProperties(ret, {\n\t\t\t\"apiCall\": {\n\t\t\t\tget() {\n\t\t\t\t\tlet call = `repos/${this.username}/${this.repo}/${this.resources ?? \"contents\"}`;\n\n\t\t\t\t\tconst path = this.path;\n\t\t\t\t\tif (path) {\n\t\t\t\t\t\tcall += `/${path}`;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't lose search params for raw API calls\n\t\t\t\t\treturn call + (this.apiParams ?? \"\");\n\t\t\t\t},\n\t\t\t\tset (v) {\n\t\t\t\t\tdelete this.apiCall;\n\t\t\t\t\tthis.apiCall = v;\n\t\t\t\t},\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true\n\t\t\t},\n\n\t\t\t\"path\": {\n\t\t\t\tget() {\n\t\t\t\t\tif (this.filename) {\n\t\t\t\t\t\treturn (this.filepath? this.filepath + \"/\" : \"\") + this.filename;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn this.filepath;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tset (v) {\n\t\t\t\t\tdelete this.path;\n\t\t\t\t\tthis.path = v;\n\t\t\t\t},\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true\n\t\t\t}\n\t\t});\n\n\t\tconst url = new URL(source, Mavo.base);\n\t\tlet path = url.pathname.slice(1).split(\"/\");\n\n\t\tret.username = path.shift();\n\t\tret.repo = path.shift() || defaults.repo;\n\n\t\tif (/raw.githubusercontent.com$/.test(url.host)) {\n\t\t\tret.branch = path.shift();\n\t\t}\n\t\telse if (/api.github.com$/.test(url.host)) {\n\t\t\t// Raw API call\n\t\t\tdelete ret.username;\n\t\t\tdelete ret.repo;\n\n\t\t\tret.apiParams = url.search;\n\t\t\tret.apiData = Mavo.Functions.from(source, \"#\"); // url.* drops line breaks\n\n\t\t\tconst apiCall = url.pathname.slice(1) + ret.apiParams;\n\n\t\t\tif (apiCall == \"graphql\") {\n\t\t\t\tret.apiCall = apiCall;\n\t\t\t\tret.apiData = { query: ret.apiData };\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath = url.pathname.slice(1).split(\"/\");\n\t\t\tconst firstSegment = path.shift();\n\n\t\t\tif (firstSegment != \"repos\") {\n\t\t\t\tret.apiCall = apiCall;\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret.username = path.shift();\n\t\t\tret.repo = path.shift();\n\t\t\tret.resources = path.shift();\n\t\t}\n\t\telse if (path[0] == \"blob\") {\n\t\t\tpath.shift();\n\t\t\tret.branch = path.shift();\n\t\t}\n\n\t\tconst lastSegment = path[path.length - 1];\n\n\t\tif (/\\.\\w+$/.test(lastSegment)) {\n\t\t\tret.filename = lastSegment;\n\t\t\tpath.splice(path.length - 1, 1);\n\t\t}\n\t\telse {\n\t\t\t// If we work with a raw API call and couldn't find the filename in the path,\n\t\t\t// leave the filename blank\n\t\t\tret.filename = ret.hasOwnProperty(\"apiParams\")? \"\" : defaults.filename;\n\t\t}\n\n\t\tret.filepath = path.join(\"/\") || defaults.filepath || \"\";\n\n\t\treturn ret;\n\t}\n\n\t// Fix atob() and btoa() so they can handle Unicode\n\tstatic btoa = str => btoa(unescape(encodeURIComponent(str)))\n\tstatic atob = str => decodeURIComponent(escape(window.atob(str)))\n});\n\n})(Bliss, Bliss.$);\n"]}